\hypertarget{namespacecheckpoint}{}\section{checkpoint Namespace Reference}
\label{namespacecheckpoint}\index{checkpoint@{checkpoint}}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespacecheckpoint_1_1buffer}{buffer}
\item 
 \hyperlink{namespacecheckpoint_1_1debug}{debug}
\item 
 \hyperlink{namespacecheckpoint_1_1detail}{detail}
\item 
 \hyperlink{namespacecheckpoint_1_1dispatch}{dispatch}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structcheckpoint_1_1_footprinter}{Footprinter}
\item 
struct \hyperlink{structcheckpoint_1_1_serialize_virtual_type_if_needed_3_01_t_00_01_serializer_t_00_01typename_01169395079d468e6ff618832a51e34843}{has\+\_\+not\+\_\+virtual\+\_\+serialize $>$$>$}
\item 
struct \hyperlink{structcheckpoint_1_1_reconstruct_as_virtual_if_needed_3_01_t_00_01_serializer_t_00_01typename_01ab92c606a95e76aaa723ec61628f6529}{has\+\_\+virtual\+\_\+serialize $>$$>$}
\item 
struct \hyperlink{structcheckpoint_1_1_serialize_virtual_type_if_needed_3_01_t_00_01_serializer_t_00_01typename_019c8f7fc8348eb3352805b18f8a3adb0b}{has\+\_\+virtual\+\_\+serialize $>$$>$}
\item 
struct \hyperlink{structcheckpoint_1_1is_byte_copyable}{is\+Byte\+Copyable}
\item 
struct \hyperlink{structcheckpoint_1_1_memory_serializer}{Memory\+Serializer}
\item 
struct \hyperlink{structcheckpoint_1_1_packer_buffer}{Packer\+Buffer}
\item 
struct \hyperlink{structcheckpoint_1_1_reconstruct_as_virtual_if_needed}{Reconstruct\+As\+Virtual\+If\+Needed}
\begin{DoxyCompactList}\small\item\em Do a static trait test on type to check for virtual serializability. If virtually serializable, we need to perform some extra work to register the type, allocate, and construct the proper type. Otherwise, we go through the normal path for allocating memory for T and serializing what the pointer points to. \end{DoxyCompactList}\item 
struct \hyperlink{structcheckpoint_1_1_serdes_byte_copy}{Serdes\+Byte\+Copy}
\item 
struct \hyperlink{structcheckpoint_1_1_serializable_traits}{Serializable\+Traits}
\item 
struct \hyperlink{structcheckpoint_1_1_serialized_info}{Serialized\+Info}
\begin{DoxyCompactList}\small\item\em Return of serialize that contains the buffer and size serialized. \end{DoxyCompactList}\item 
struct \hyperlink{structcheckpoint_1_1_serializer}{Serializer}
\begin{DoxyCompactList}\small\item\em General base class for serialiers. \end{DoxyCompactList}\item 
struct \hyperlink{structcheckpoint_1_1_serializer_traits}{Serializer\+Traits}
\item 
struct \hyperlink{structcheckpoint_1_1_serialize_virtual_type_if_needed}{Serialize\+Virtual\+Type\+If\+Needed}
\begin{DoxyCompactList}\small\item\em Do a static trait test on type to check for virtual serializability. \end{DoxyCompactList}\item 
struct \hyperlink{structcheckpoint_1_1_sizer}{Sizer}
\begin{DoxyCompactList}\small\item\em \hyperlink{structcheckpoint_1_1_sizer}{Sizer} serializers for sizing the contents of classes as a preprocessing pass before packing content so a properly sized buffer can be allocated. \end{DoxyCompactList}\item 
struct \hyperlink{structcheckpoint_1_1_unpacker_buffer}{Unpacker\+Buffer}
\item 
struct \hyperlink{structcheckpoint_1_1_reconstruct_as_virtual_if_needed_3_01_t_00_01_serializer_t_00_01typename_01bd353309780a1641c6b4da6107e9b732}{value $>$$>$}
\item 
struct \hyperlink{structcheckpoint_1_1_reconstruct_as_virtual_if_needed_3_01_t_00_01_serializer_t_00_01typename_0185cb3961b0806c240679cf17dd651016}{value $>$$>$}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{namespacecheckpoint_a70bc1b37eae8e32129df38d981ef90f6}{Buffer\+Callback\+Type} = std\+::function$<$ char $\ast$(std\+::size\+\_\+t size)$>$
\begin{DoxyCompactList}\small\item\em Callback for user to allocate bytes during serialization. \end{DoxyCompactList}\item 
using \hyperlink{namespacecheckpoint_aa61e2b491f405a63a394f9aad528c37a}{Serialized\+Return\+Type} = std\+::unique\+\_\+ptr$<$ \hyperlink{structcheckpoint_1_1_serialized_info}{Serialized\+Info} $>$
\begin{DoxyCompactList}\small\item\em Convenience typedef for {\ttfamily std\+::unique\+\_\+ptr$<$\+Serialized\+Info$>$} \end{DoxyCompactList}\item 
using \hyperlink{namespacecheckpoint_a083f6674da3f94c2901b18c6d238217c}{Serial\+Size\+Type} = size\+\_\+t
\item 
using \hyperlink{namespacecheckpoint_ae57f01cdc0b81776c23b6c7c934c58f5}{Serial\+Byte\+Type} = char
\item 
using \hyperlink{namespacecheckpoint_a8a2558a1dd0db386339dd81c193b7f10}{Buffer\+Obtain\+Fn\+Type} = std\+::function$<$ \hyperlink{namespacecheckpoint_ae57f01cdc0b81776c23b6c7c934c58f5}{Serial\+Byte\+Type} $\ast$(\hyperlink{namespacecheckpoint_a083f6674da3f94c2901b18c6d238217c}{Serial\+Size\+Type} size)$>$
\item 
using \hyperlink{namespacecheckpoint_a7ff642cff4d72d01a16ab10e9bc363ef}{S\+E\+R\+I\+A\+L\+I\+Z\+E\+\_\+\+C\+O\+N\+S\+T\+R\+U\+C\+T\+\_\+\+T\+AG} = \hyperlink{structcheckpoint_1_1dispatch_1_1_s_e_r_i_a_l_i_z_e___c_o_n_s_t_r_u_c_t___t_a_g}{dispatch\+::\+S\+E\+R\+I\+A\+L\+I\+Z\+E\+\_\+\+C\+O\+N\+S\+T\+R\+U\+C\+T\+\_\+\+T\+AG}
\item 
{\footnotesize template$<$typename BaseT $>$ }\\using \hyperlink{namespacecheckpoint_ae8adefa66d7575697f8e465bed48e3cc}{Serializable\+Base} = \hyperlink{structcheckpoint_1_1dispatch_1_1vrt_1_1_serializable_base}{dispatch\+::vrt\+::\+Serializable\+Base}$<$ BaseT $>$
\item 
{\footnotesize template$<$typename DerivedT , typename BaseT $>$ }\\using \hyperlink{namespacecheckpoint_a9c4afb2c8d1bc1f58b9e158d64331d65}{Serializable\+Derived} = \hyperlink{structcheckpoint_1_1dispatch_1_1vrt_1_1_serializable_derived}{dispatch\+::vrt\+::\+Serializable\+Derived}$<$ DerivedT, BaseT $>$
\item 
using \hyperlink{namespacecheckpoint_ad744c208c7b1da6ee19c10d071e74f7d}{Packer} = \hyperlink{structcheckpoint_1_1_packer_buffer}{Packer\+Buffer}$<$ \hyperlink{structcheckpoint_1_1buffer_1_1_managed_buffer}{buffer\+::\+Managed\+Buffer} $>$
\item 
using \hyperlink{namespacecheckpoint_a72c31e3d94e3b4d05bca5972bacc536a}{Packer\+User\+Buf} = \hyperlink{structcheckpoint_1_1_packer_buffer}{Packer\+Buffer}$<$ \hyperlink{structcheckpoint_1_1buffer_1_1_user_buffer}{buffer\+::\+User\+Buffer} $>$
\item 
using \hyperlink{namespacecheckpoint_a0c8b3f2f174fd1076b410c7a2128919b}{Packer\+IO} = \hyperlink{structcheckpoint_1_1_packer_buffer}{Packer\+Buffer}$<$ \hyperlink{structcheckpoint_1_1buffer_1_1_i_o_buffer}{buffer\+::\+I\+O\+Buffer} $>$
\item 
using \hyperlink{namespacecheckpoint_af36cfec8b3ef7476bb97b3b12908370d}{Unpacker} = \hyperlink{structcheckpoint_1_1_unpacker_buffer}{Unpacker\+Buffer}$<$ \hyperlink{structcheckpoint_1_1buffer_1_1_user_buffer}{buffer\+::\+User\+Buffer} $>$
\item 
using \hyperlink{namespacecheckpoint_a0efc06d99dce79e452b9d1b503059a74}{Unpacker\+IO} = \hyperlink{structcheckpoint_1_1_unpacker_buffer}{Unpacker\+Buffer}$<$ \hyperlink{structcheckpoint_1_1buffer_1_1_i_o_buffer}{buffer\+::\+I\+O\+Buffer} $>$
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059}{e\+Serialization\+Mode} \+: int8\+\_\+t \{ \newline
\hyperlink{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059a6adf97f83acf6453d4a6a4b1070f3754}{e\+Serialization\+Mode\+::\+None} = 0, 
\hyperlink{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059a9b87ab5a4e2e99d758991f06cad9c3bf}{e\+Serialization\+Mode\+::\+Unpacking} = 1, 
\hyperlink{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059ac46192253e8458f209a350a132cfc876}{e\+Serialization\+Mode\+::\+Packing} = 2, 
\hyperlink{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059a92672a7a2b909945fbfa9f44f057c7a1}{e\+Serialization\+Mode\+::\+Sizing} = 3, 
\newline
\hyperlink{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059afa42c5852085bf97b53b351ba4fcc474}{e\+Serialization\+Mode\+::\+Footprinting} = 4, 
\hyperlink{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059a4bbb8f967da6d1a610596d7257179c2b}{e\+Serialization\+Mode\+::\+Invalid} = -\/1
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T $>$ }\\\hyperlink{namespacecheckpoint_aa61e2b491f405a63a394f9aad528c37a}{Serialized\+Return\+Type} \hyperlink{namespacecheckpoint_a075da4e7344cf037943362517e606c3a}{serialize} (T \&target, \hyperlink{namespacecheckpoint_a70bc1b37eae8e32129df38d981ef90f6}{Buffer\+Callback\+Type} fn=nullptr)
\begin{DoxyCompactList}\small\item\em Serialize {\ttfamily T} into a byte buffer. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\T $\ast$ \hyperlink{namespacecheckpoint_aee0d7387d339b0275e9b95634748d63b}{deserialize} (char $\ast$buf, char $\ast$object\+\_\+buf)
\begin{DoxyCompactList}\small\item\em De-\/serialize and reify {\ttfamily T} from a byte buffer and corresponding {\ttfamily size}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\std\+::unique\+\_\+ptr$<$ T $>$ \hyperlink{namespacecheckpoint_ab8beefac6b3dc40c69e11dc430618c64}{deserialize} (char $\ast$buf)
\begin{DoxyCompactList}\small\item\em De-\/serialize and reify {\ttfamily T} from a byte buffer and corresponding {\ttfamily size}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{namespacecheckpoint_af605968a3b8731448c68e5c9fff917ee}{deserialize\+In\+Place} (char $\ast$buf, T $\ast$t)
\begin{DoxyCompactList}\small\item\em De-\/serialize and reify {\ttfamily T} from a byte buffer and corresponding {\ttfamily size} in-\/place on the user-\/provided {\ttfamily t}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\std\+::unique\+\_\+ptr$<$ T $>$ \hyperlink{namespacecheckpoint_a1fa5c2e70f11308a1a94b163924d88f3}{deserialize} (\hyperlink{namespacecheckpoint_aa61e2b491f405a63a394f9aad528c37a}{Serialized\+Return\+Type} \&\&in)
\begin{DoxyCompactList}\small\item\em Convenience function for de-\/serializing and reify {\ttfamily T} directly from {\ttfamily in} the return value from {\ttfamily serialize}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\std\+::size\+\_\+t \hyperlink{namespacecheckpoint_af0e68ef201b5e6831939bcd752e1b18b}{get\+Size} (T \&target)
\begin{DoxyCompactList}\small\item\em Get the number of bytes that {\ttfamily target} requires for serialization. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\std\+::size\+\_\+t \hyperlink{namespacecheckpoint_a3c06c0dd0b9bccfd2aa6b79570b9cda1}{get\+Memory\+Footprint} (T \&target, std\+::size\+\_\+t size\+\_\+offset=0)
\begin{DoxyCompactList}\small\item\em Get memory footprint of {\ttfamily target}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{namespacecheckpoint_a3d4326982e3c3feeb933e985758eea82}{serialize\+To\+File} (T \&target, std\+::string const \&file)
\begin{DoxyCompactList}\small\item\em Serialize {\ttfamily T} to file with filename {\ttfamily file}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\std\+::unique\+\_\+ptr$<$ T $>$ \hyperlink{namespacecheckpoint_ad71bcfe197379c59aa16f737b7e2cf3e}{deserialize\+From\+File} (std\+::string const \&file)
\begin{DoxyCompactList}\small\item\em De-\/serialize and reify {\ttfamily T} from a file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{namespacecheckpoint_a4a98c599eb8a73519cd643bfafb739d5}{deserialize\+In\+Place\+From\+File} (std\+::string const \&file, T $\ast$buf)
\begin{DoxyCompactList}\small\item\em De-\/serialize and reify {\ttfamily T} from a file in place on an existing pointer to {\ttfamily T}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Serializer , typename T , size\+\_\+t N$>$ }\\void \hyperlink{namespacecheckpoint_a976e83bf5f22b7bfc5036fd829be039e}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::array$<$ T, N $>$ \&array)
\item 
{\footnotesize template$<$typename SerializerT , typename T , typename  = std\+::enable\+\_\+if\+\_\+t$<$    std\+::is\+\_\+same$<$\+Serializer\+T, checkpoint\+::\+Footprinter$>$\+::value  $>$$>$ }\\void \hyperlink{namespacecheckpoint_a40ca9a5c99807bd8a0610098d94b5125}{serialize} (SerializerT \&s, const std\+::atomic$<$ T $>$ \&atomic)
\item 
{\footnotesize template$<$typename Serializer , typename Rep , typename Period $>$ }\\void \hyperlink{namespacecheckpoint_aec244476371c452d9d9318b9d5b24401}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::chrono\+::duration$<$ Rep, Period $>$ \&d)
\item 
{\footnotesize template$<$typename Serializer , typename ContainerT $>$ }\\Container\+T\+::size\+\_\+type \hyperlink{namespacecheckpoint_a3359595d5a4c6fcf5fc95069c71f869b}{serialize\+Container\+Size} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, ContainerT \&cont)
\item 
{\footnotesize template$<$typename Serializer , typename ContainerT $>$ }\\void \hyperlink{namespacecheckpoint_a9c880ba9bb9a106e784e06554b2fbcf2}{serialize\+Container\+Elems} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, ContainerT \&cont)
\item 
{\footnotesize template$<$typename Serializer , typename Enum , typename Underlying  = std\+::underlying\+\_\+type\+\_\+t$<$\+Enum$>$$>$ }\\void \hyperlink{namespacecheckpoint_a5f368cb543eec78bb608a68fe2401562}{serialize\+Enum} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, Enum \&e)
\item 
{\footnotesize template$<$typename SerializerT , typename Res , typename... Arg\+Types$>$ }\\void \hyperlink{namespacecheckpoint_ad3043fe034b7bf1d0d864e1e819c84d4}{serialize} (SerializerT \&s, std\+::function$<$ Res(Arg\+Types...)$>$ \&fn)
\begin{DoxyCompactList}\small\item\em Serialize function {\ttfamily func}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename SerializerT , typename Res , typename... Arg\+Types, typename  = std\+::enable\+\_\+if\+\_\+t$<$    std\+::is\+\_\+same$<$      Serializer\+T,      checkpoint\+::\+Footprinter    $>$\+::value  $>$$>$ }\\void \hyperlink{namespacecheckpoint_a4161978e6d6de385d942cbcbe659817a}{serialize\+Function} (SerializerT \&s, std\+::function$<$ Res(Arg\+Types...)$>$ \&fn)
\item 
{\footnotesize template$<$typename Serializer , typename ContainerT , typename ElmT $>$ }\\std\+::enable\+\_\+if\+\_\+t$<$ not std\+::is\+\_\+same$<$ \hyperlink{structcheckpoint_1_1_serializer}{Serializer}, \hyperlink{structcheckpoint_1_1_footprinter}{checkpoint\+::\+Footprinter} $>$\+::value, void $>$ \hyperlink{namespacecheckpoint_affdb2f2117fc38cb03d94aa59e1bdf48}{deserialize\+Ordered\+Elems} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, ContainerT \&cont, typename Container\+T\+::size\+\_\+type size)
\item 
{\footnotesize template$<$typename Serializer , typename ContainerT , typename ElmT $>$ }\\std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$ \hyperlink{structcheckpoint_1_1_serializer}{Serializer}, \hyperlink{structcheckpoint_1_1_footprinter}{checkpoint\+::\+Footprinter} $>$\+::value, void $>$ \hyperlink{namespacecheckpoint_a9976fffc8f39073e5b40ec61d93a5482}{deserialize\+Ordered\+Elems} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, ContainerT \&cont, typename Container\+T\+::size\+\_\+type size)
\item 
{\footnotesize template$<$typename Serializer , typename ContainerT $>$ }\\void \hyperlink{namespacecheckpoint_a0b15edc50a881e06260e7112b2c60742}{serialize\+Ordered\+Container} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, ContainerT \&cont)
\item 
{\footnotesize template$<$typename Serializer , typename T $>$ }\\void \hyperlink{namespacecheckpoint_afb32627049eb840e4f8b9fd3022f2eb2}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::list$<$ T $>$ \&lst)
\item 
{\footnotesize template$<$typename Serializer , typename T $>$ }\\void \hyperlink{namespacecheckpoint_a179b767294c9b23617f30fc4566d0be7}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::deque$<$ T $>$ \&lst)
\item 
{\footnotesize template$<$typename Serializer , typename ContainerT , typename ElmT $>$ }\\std\+::enable\+\_\+if\+\_\+t$<$ not std\+::is\+\_\+same$<$ \hyperlink{structcheckpoint_1_1_serializer}{Serializer}, \hyperlink{structcheckpoint_1_1_footprinter}{checkpoint\+::\+Footprinter} $>$\+::value, void $>$ \hyperlink{namespacecheckpoint_a9016e0756f91e6e982b3c824c007c251}{deserialize\+Emplace\+Elems} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, ContainerT \&cont, typename Container\+T\+::size\+\_\+type size)
\item 
{\footnotesize template$<$typename Serializer , typename ContainerT , typename ElmT $>$ }\\std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$ \hyperlink{structcheckpoint_1_1_serializer}{Serializer}, \hyperlink{structcheckpoint_1_1_footprinter}{checkpoint\+::\+Footprinter} $>$\+::value, void $>$ \hyperlink{namespacecheckpoint_a811956d461a3ebc7329272fd33e1084f}{deserialize\+Emplace\+Elems} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, ContainerT \&cont, typename Container\+T\+::size\+\_\+type size)
\item 
{\footnotesize template$<$typename Serializer , typename ContainerT $>$ }\\void \hyperlink{namespacecheckpoint_a99092baac18b33d03b1bb47ed1f2d7fa}{serialize\+Map\+Like\+Container} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, ContainerT \&cont)
\item 
{\footnotesize template$<$typename Serializer , typename T , typename U , typename Comp $>$ }\\void \hyperlink{namespacecheckpoint_a39ee0888319dc204dff7af20dd1e8238}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::map$<$ T, U, Comp $>$ \&map)
\item 
{\footnotesize template$<$typename Serializer , typename T , typename U , typename Comp $>$ }\\void \hyperlink{namespacecheckpoint_a44434f578fc304afa3a62a9305be2a65}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::multimap$<$ T, U, Comp $>$ \&map)
\item 
{\footnotesize template$<$typename Serializer , typename T , typename Comp $>$ }\\void \hyperlink{namespacecheckpoint_a9f1869781f4cce4db94c144174680b24}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::set$<$ T, Comp $>$ \&set)
\item 
{\footnotesize template$<$typename Serializer , typename T , typename Comp $>$ }\\void \hyperlink{namespacecheckpoint_ae032265314cdf8e9155a6bbc423ca1c9}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::multiset$<$ T, Comp $>$ \&set)
\item 
{\footnotesize template$<$typename Serializer , typename T , typename U , typename Hash , typename Eq $>$ }\\void \hyperlink{namespacecheckpoint_a9fc2f3eb20d3ce8d6145e99a2559ea58}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::unordered\+\_\+map$<$ T, U, Hash, Eq $>$ \&map)
\item 
{\footnotesize template$<$typename Serializer , typename T , typename U , typename Hash , typename Eq $>$ }\\void \hyperlink{namespacecheckpoint_aa77eeb7a036d253ef33ed2c9ef764a5e}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::unordered\+\_\+multimap$<$ T, U, Hash, Eq $>$ \&map)
\item 
{\footnotesize template$<$typename Serializer , typename T , typename Hash , typename Eq $>$ }\\void \hyperlink{namespacecheckpoint_ae4ca8cbc6daf2f5a2a20d44d9fe1cc9f}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::unordered\+\_\+set$<$ T, Hash, Eq $>$ \&set)
\item 
{\footnotesize template$<$typename Serializer , typename T , typename Hash , typename Eq $>$ }\\void \hyperlink{namespacecheckpoint_a64c8a1aa29d469bc71c88a8836264ecc}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::unordered\+\_\+multiset$<$ T, Hash, Eq $>$ \&set)
\item 
{\footnotesize template$<$typename Serializer , typename T $>$ }\\void \hyperlink{namespacecheckpoint_a5621e2549443d76acad6c83fdfdcbeab}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, const std\+::queue$<$ T $>$ \&q)
\item 
{\footnotesize template$<$typename Serializer , typename T $>$ }\\void \hyperlink{namespacecheckpoint_a9493433bed418b54358130463961ce50}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, const std\+::priority\+\_\+queue$<$ T $>$ \&q)
\item 
{\footnotesize template$<$typename Serializer , typename T $>$ }\\void \hyperlink{namespacecheckpoint_a1d399ef63dc7723f1b4387e4605b3259}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, const std\+::stack$<$ T $>$ \&stack)
\item 
{\footnotesize template$<$typename SerializerT , typename Q , typename  = std\+::enable\+\_\+if\+\_\+t$<$    std\+::is\+\_\+same$<$      Serializer\+T,      checkpoint\+::\+Footprinter    $>$\+::value  $>$$>$ }\\void \hyperlink{namespacecheckpoint_a33956387419a85cfe810fbce88f5bdf9}{serialize\+Queue\+Like\+Container} (SerializerT \&s, const Q \&q)
\item 
{\footnotesize template$<$typename SerializerT , typename T , typename  = std\+::enable\+\_\+if\+\_\+t$<$    std\+::is\+\_\+same$<$      Serializer\+T,      checkpoint\+::\+Footprinter    $>$\+::value  $>$$>$ }\\void \hyperlink{namespacecheckpoint_a5242b8701b19ff5eeb7587fb4a07bfe9}{serialize} (SerializerT \&s, T $\ast$ptr)
\begin{DoxyCompactList}\small\item\em Serialize raw pointer {\ttfamily ptr}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename SerializerT , typename T $>$ }\\void \hyperlink{namespacecheckpoint_a6113644a35f5023a57e2ed3ca4814490}{serialize\+Raw\+Ptr} (SerializerT \&s, T $\ast$ptr)
\item 
{\footnotesize template$<$typename SerializerT $>$ }\\void \hyperlink{namespacecheckpoint_aaadeb0ab61d069afc8a97ec6b6dc630c}{serialize\+Raw\+Ptr} (SerializerT \&s, void $\ast$ptr)
\item 
{\footnotesize template$<$typename SerializerT , typename T , typename  = std\+::enable\+\_\+if\+\_\+t$<$    std\+::is\+\_\+same$<$      Serializer\+T,      checkpoint\+::\+Footprinter    $>$\+::value  $>$$>$ }\\void \hyperlink{namespacecheckpoint_aff1bebba5ce7fda79f83d2af8c859254}{serialize} (SerializerT \&s, std\+::shared\+\_\+ptr$<$ T $>$ \&ptr)
\item 
{\footnotesize template$<$typename Serializer $>$ }\\void \hyperlink{namespacecheckpoint_a1ea8e1ef9d0a10d26df77cb5309435aa}{serialize\+String\+Meta} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::string \&str)
\item 
{\footnotesize template$<$typename Serializer $>$ }\\void \hyperlink{namespacecheckpoint_aef8e8717e4cc129379525653730c4eba}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::string \&str)
\begin{DoxyCompactList}\small\item\em Serialize string {\ttfamily str}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename SerializerT , typename  = std\+::enable\+\_\+if\+\_\+t$<$    std\+::is\+\_\+same$<$\+Serializer\+T, checkpoint\+::\+Footprinter$>$\+::value  $>$$>$ }\\void \hyperlink{namespacecheckpoint_ab9c05efe18a47d990fb20e84f73e9943}{serialize} (SerializerT \&s, const std\+::thread \&t)
\item 
{\footnotesize template$<$typename Serializer , typename... T, size\+\_\+t... Idxs$>$ }\\void \hyperlink{namespacecheckpoint_ab763d3ca9396ff9a1896f5da6c2b3c54}{tuple\+\_\+helper} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::tuple$<$ T... $>$ \&tup, std\+::index\+\_\+sequence$<$ Idxs... $>$)
\item 
{\footnotesize template$<$typename Serializer , typename... Args$>$ }\\void \hyperlink{namespacecheckpoint_a7ac21fa6ad08fd64a47c789c32966019}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::tuple$<$ Args... $>$ \&tuple)
\item 
{\footnotesize template$<$typename Serializer , typename T , typename U $>$ }\\void \hyperlink{namespacecheckpoint_a7b5c3ff67d3f7b65cfb46da7617e87ad}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::pair$<$ T, U $>$ \&pair)
\item 
{\footnotesize template$<$typename Serializer , typename T , typename Deleter $>$ }\\void \hyperlink{namespacecheckpoint_a617341cb0473cbdce921a3a4d049f4fc}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::unique\+\_\+ptr$<$ T, Deleter $>$ \&ptr)
\item 
{\footnotesize template$<$typename SerializerT , typename T , typename Vector\+Allocator $>$ }\\std\+::enable\+\_\+if\+\_\+t$<$ not std\+::is\+\_\+same$<$ SerializerT, \hyperlink{structcheckpoint_1_1_footprinter}{checkpoint\+::\+Footprinter} $>$\+::value, void $>$ \hyperlink{namespacecheckpoint_ae257a02737b213492283962cc645c6a5}{serialize\+Vector\+Meta} (SerializerT \&s, std\+::vector$<$ T, Vector\+Allocator $>$ \&vec)
\item 
{\footnotesize template$<$typename SerializerT , typename T , typename Vector\+Allocator $>$ }\\std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$ SerializerT, \hyperlink{structcheckpoint_1_1_footprinter}{checkpoint\+::\+Footprinter} $>$\+::value, void $>$ \hyperlink{namespacecheckpoint_a0133c00735e3d54bb46ffa9e24d59d7b}{serialize\+Vector\+Meta} (SerializerT \&s, std\+::vector$<$ T, Vector\+Allocator $>$ \&vec)
\item 
{\footnotesize template$<$typename Serializer , typename T , typename Vector\+Allocator $>$ }\\void \hyperlink{namespacecheckpoint_a3a422f601605de1c02c6bdd57f3dc93b}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::vector$<$ T, Vector\+Allocator $>$ \&vec)
\item 
{\footnotesize template$<$typename Serializer , typename Vector\+Allocator $>$ }\\void \hyperlink{namespacecheckpoint_aef7e26930d4d3446970f8aca0640b11d}{serialize} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, std\+::vector$<$ bool, Vector\+Allocator $>$ \&vec)
\item 
{\footnotesize template$<$typename Serializer , typename T $>$ }\\\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \& \hyperlink{namespacecheckpoint_a5c9a1c4d05ec6880270c9a6d0dded825}{operator$\vert$} (\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&s, T \&target)
\item 
{\footnotesize template$<$typename ObjT , typename... Serializer\+Ts$>$ }\\void \hyperlink{namespacecheckpoint_a09875c2d3c012be868f3fd88b3ed55be}{instantiate\+Obj\+Serializer} ()
\item 
{\footnotesize template$<$typename SerializerT , typename T $>$ }\\void \hyperlink{namespacecheckpoint_a9ffb72abb4d8c3fe031626dbf526d70c}{reconstruct\+Pointed\+To\+Object\+If\+Needed} (SerializerT \&s, T $\ast$\&target)
\begin{DoxyCompactList}\small\item\em Allocate and construct memory for a pointer with type {\ttfamily T}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{namespacecheckpoint_a6254f2e220f905a2b0c797c08092a7a1}{reconstruct} (T)
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\mbox{\Hypertarget{namespacecheckpoint_a70bc1b37eae8e32129df38d981ef90f6}\label{namespacecheckpoint_a70bc1b37eae8e32129df38d981ef90f6}} 
\index{checkpoint@{checkpoint}!Buffer\+Callback\+Type@{Buffer\+Callback\+Type}}
\index{Buffer\+Callback\+Type@{Buffer\+Callback\+Type}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{Buffer\+Callback\+Type}{BufferCallbackType}}
{\footnotesize\ttfamily using \hyperlink{namespacecheckpoint_a70bc1b37eae8e32129df38d981ef90f6}{checkpoint\+::\+Buffer\+Callback\+Type} = typedef std\+::function$<$char$\ast$(std\+::size\+\_\+t size)$>$}



Callback for user to allocate bytes during serialization. 

\mbox{\Hypertarget{namespacecheckpoint_a8a2558a1dd0db386339dd81c193b7f10}\label{namespacecheckpoint_a8a2558a1dd0db386339dd81c193b7f10}} 
\index{checkpoint@{checkpoint}!Buffer\+Obtain\+Fn\+Type@{Buffer\+Obtain\+Fn\+Type}}
\index{Buffer\+Obtain\+Fn\+Type@{Buffer\+Obtain\+Fn\+Type}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{Buffer\+Obtain\+Fn\+Type}{BufferObtainFnType}}
{\footnotesize\ttfamily using \hyperlink{namespacecheckpoint_a8a2558a1dd0db386339dd81c193b7f10}{checkpoint\+::\+Buffer\+Obtain\+Fn\+Type} = typedef std\+::function$<$\hyperlink{namespacecheckpoint_ae57f01cdc0b81776c23b6c7c934c58f5}{Serial\+Byte\+Type}$\ast$(\hyperlink{namespacecheckpoint_a083f6674da3f94c2901b18c6d238217c}{Serial\+Size\+Type} size)$>$}

\mbox{\Hypertarget{namespacecheckpoint_ad744c208c7b1da6ee19c10d071e74f7d}\label{namespacecheckpoint_ad744c208c7b1da6ee19c10d071e74f7d}} 
\index{checkpoint@{checkpoint}!Packer@{Packer}}
\index{Packer@{Packer}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{Packer}{Packer}}
{\footnotesize\ttfamily using \hyperlink{namespacecheckpoint_ad744c208c7b1da6ee19c10d071e74f7d}{checkpoint\+::\+Packer} = typedef \hyperlink{structcheckpoint_1_1_packer_buffer}{Packer\+Buffer}$<$\hyperlink{structcheckpoint_1_1buffer_1_1_managed_buffer}{buffer\+::\+Managed\+Buffer}$>$}

\mbox{\Hypertarget{namespacecheckpoint_a0c8b3f2f174fd1076b410c7a2128919b}\label{namespacecheckpoint_a0c8b3f2f174fd1076b410c7a2128919b}} 
\index{checkpoint@{checkpoint}!Packer\+IO@{Packer\+IO}}
\index{Packer\+IO@{Packer\+IO}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{Packer\+IO}{PackerIO}}
{\footnotesize\ttfamily using \hyperlink{namespacecheckpoint_a0c8b3f2f174fd1076b410c7a2128919b}{checkpoint\+::\+Packer\+IO} = typedef \hyperlink{structcheckpoint_1_1_packer_buffer}{Packer\+Buffer}$<$\hyperlink{structcheckpoint_1_1buffer_1_1_i_o_buffer}{buffer\+::\+I\+O\+Buffer}$>$}

\mbox{\Hypertarget{namespacecheckpoint_a72c31e3d94e3b4d05bca5972bacc536a}\label{namespacecheckpoint_a72c31e3d94e3b4d05bca5972bacc536a}} 
\index{checkpoint@{checkpoint}!Packer\+User\+Buf@{Packer\+User\+Buf}}
\index{Packer\+User\+Buf@{Packer\+User\+Buf}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{Packer\+User\+Buf}{PackerUserBuf}}
{\footnotesize\ttfamily using \hyperlink{namespacecheckpoint_a72c31e3d94e3b4d05bca5972bacc536a}{checkpoint\+::\+Packer\+User\+Buf} = typedef \hyperlink{structcheckpoint_1_1_packer_buffer}{Packer\+Buffer}$<$\hyperlink{structcheckpoint_1_1buffer_1_1_user_buffer}{buffer\+::\+User\+Buffer}$>$}

\mbox{\Hypertarget{namespacecheckpoint_ae57f01cdc0b81776c23b6c7c934c58f5}\label{namespacecheckpoint_ae57f01cdc0b81776c23b6c7c934c58f5}} 
\index{checkpoint@{checkpoint}!Serial\+Byte\+Type@{Serial\+Byte\+Type}}
\index{Serial\+Byte\+Type@{Serial\+Byte\+Type}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{Serial\+Byte\+Type}{SerialByteType}}
{\footnotesize\ttfamily using \hyperlink{namespacecheckpoint_ae57f01cdc0b81776c23b6c7c934c58f5}{checkpoint\+::\+Serial\+Byte\+Type} = typedef char}

\mbox{\Hypertarget{namespacecheckpoint_ae8adefa66d7575697f8e465bed48e3cc}\label{namespacecheckpoint_ae8adefa66d7575697f8e465bed48e3cc}} 
\index{checkpoint@{checkpoint}!Serializable\+Base@{Serializable\+Base}}
\index{Serializable\+Base@{Serializable\+Base}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{Serializable\+Base}{SerializableBase}}
{\footnotesize\ttfamily template$<$typename BaseT $>$ \\
using \hyperlink{namespacecheckpoint_ae8adefa66d7575697f8e465bed48e3cc}{checkpoint\+::\+Serializable\+Base} = typedef \hyperlink{structcheckpoint_1_1dispatch_1_1vrt_1_1_serializable_base}{dispatch\+::vrt\+::\+Serializable\+Base}$<$BaseT$>$}

\mbox{\Hypertarget{namespacecheckpoint_a9c4afb2c8d1bc1f58b9e158d64331d65}\label{namespacecheckpoint_a9c4afb2c8d1bc1f58b9e158d64331d65}} 
\index{checkpoint@{checkpoint}!Serializable\+Derived@{Serializable\+Derived}}
\index{Serializable\+Derived@{Serializable\+Derived}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{Serializable\+Derived}{SerializableDerived}}
{\footnotesize\ttfamily template$<$typename DerivedT , typename BaseT $>$ \\
using \hyperlink{namespacecheckpoint_a9c4afb2c8d1bc1f58b9e158d64331d65}{checkpoint\+::\+Serializable\+Derived} = typedef \hyperlink{structcheckpoint_1_1dispatch_1_1vrt_1_1_serializable_derived}{dispatch\+::vrt\+::\+Serializable\+Derived}$<$DerivedT, BaseT$>$}

\mbox{\Hypertarget{namespacecheckpoint_a7ff642cff4d72d01a16ab10e9bc363ef}\label{namespacecheckpoint_a7ff642cff4d72d01a16ab10e9bc363ef}} 
\index{checkpoint@{checkpoint}!S\+E\+R\+I\+A\+L\+I\+Z\+E\+\_\+\+C\+O\+N\+S\+T\+R\+U\+C\+T\+\_\+\+T\+AG@{S\+E\+R\+I\+A\+L\+I\+Z\+E\+\_\+\+C\+O\+N\+S\+T\+R\+U\+C\+T\+\_\+\+T\+AG}}
\index{S\+E\+R\+I\+A\+L\+I\+Z\+E\+\_\+\+C\+O\+N\+S\+T\+R\+U\+C\+T\+\_\+\+T\+AG@{S\+E\+R\+I\+A\+L\+I\+Z\+E\+\_\+\+C\+O\+N\+S\+T\+R\+U\+C\+T\+\_\+\+T\+AG}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{S\+E\+R\+I\+A\+L\+I\+Z\+E\+\_\+\+C\+O\+N\+S\+T\+R\+U\+C\+T\+\_\+\+T\+AG}{SERIALIZE\_CONSTRUCT\_TAG}}
{\footnotesize\ttfamily using \hyperlink{namespacecheckpoint_a7ff642cff4d72d01a16ab10e9bc363ef}{checkpoint\+::\+S\+E\+R\+I\+A\+L\+I\+Z\+E\+\_\+\+C\+O\+N\+S\+T\+R\+U\+C\+T\+\_\+\+T\+AG} = typedef \hyperlink{structcheckpoint_1_1dispatch_1_1_s_e_r_i_a_l_i_z_e___c_o_n_s_t_r_u_c_t___t_a_g}{dispatch\+::\+S\+E\+R\+I\+A\+L\+I\+Z\+E\+\_\+\+C\+O\+N\+S\+T\+R\+U\+C\+T\+\_\+\+T\+AG}}

\mbox{\Hypertarget{namespacecheckpoint_aa61e2b491f405a63a394f9aad528c37a}\label{namespacecheckpoint_aa61e2b491f405a63a394f9aad528c37a}} 
\index{checkpoint@{checkpoint}!Serialized\+Return\+Type@{Serialized\+Return\+Type}}
\index{Serialized\+Return\+Type@{Serialized\+Return\+Type}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{Serialized\+Return\+Type}{SerializedReturnType}}
{\footnotesize\ttfamily using \hyperlink{namespacecheckpoint_aa61e2b491f405a63a394f9aad528c37a}{checkpoint\+::\+Serialized\+Return\+Type} = typedef std\+::unique\+\_\+ptr$<$\hyperlink{structcheckpoint_1_1_serialized_info}{Serialized\+Info}$>$}



Convenience typedef for {\ttfamily std\+::unique\+\_\+ptr$<$\+Serialized\+Info$>$} 

\mbox{\Hypertarget{namespacecheckpoint_a083f6674da3f94c2901b18c6d238217c}\label{namespacecheckpoint_a083f6674da3f94c2901b18c6d238217c}} 
\index{checkpoint@{checkpoint}!Serial\+Size\+Type@{Serial\+Size\+Type}}
\index{Serial\+Size\+Type@{Serial\+Size\+Type}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{Serial\+Size\+Type}{SerialSizeType}}
{\footnotesize\ttfamily using \hyperlink{namespacecheckpoint_a083f6674da3f94c2901b18c6d238217c}{checkpoint\+::\+Serial\+Size\+Type} = typedef size\+\_\+t}

\mbox{\Hypertarget{namespacecheckpoint_af36cfec8b3ef7476bb97b3b12908370d}\label{namespacecheckpoint_af36cfec8b3ef7476bb97b3b12908370d}} 
\index{checkpoint@{checkpoint}!Unpacker@{Unpacker}}
\index{Unpacker@{Unpacker}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{Unpacker}{Unpacker}}
{\footnotesize\ttfamily using \hyperlink{namespacecheckpoint_af36cfec8b3ef7476bb97b3b12908370d}{checkpoint\+::\+Unpacker} = typedef \hyperlink{structcheckpoint_1_1_unpacker_buffer}{Unpacker\+Buffer}$<$\hyperlink{structcheckpoint_1_1buffer_1_1_user_buffer}{buffer\+::\+User\+Buffer}$>$}

\mbox{\Hypertarget{namespacecheckpoint_a0efc06d99dce79e452b9d1b503059a74}\label{namespacecheckpoint_a0efc06d99dce79e452b9d1b503059a74}} 
\index{checkpoint@{checkpoint}!Unpacker\+IO@{Unpacker\+IO}}
\index{Unpacker\+IO@{Unpacker\+IO}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{Unpacker\+IO}{UnpackerIO}}
{\footnotesize\ttfamily using \hyperlink{namespacecheckpoint_a0efc06d99dce79e452b9d1b503059a74}{checkpoint\+::\+Unpacker\+IO} = typedef \hyperlink{structcheckpoint_1_1_unpacker_buffer}{Unpacker\+Buffer}$<$\hyperlink{structcheckpoint_1_1buffer_1_1_i_o_buffer}{buffer\+::\+I\+O\+Buffer}$>$}



\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059}\label{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059}} 
\index{checkpoint@{checkpoint}!e\+Serialization\+Mode@{e\+Serialization\+Mode}}
\index{e\+Serialization\+Mode@{e\+Serialization\+Mode}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{e\+Serialization\+Mode}{eSerializationMode}}
{\footnotesize\ttfamily enum \hyperlink{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059}{checkpoint\+::e\+Serialization\+Mode} \+: int8\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{None@{None}!checkpoint@{checkpoint}}\index{checkpoint@{checkpoint}!None@{None}}}\mbox{\Hypertarget{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059a6adf97f83acf6453d4a6a4b1070f3754}\label{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059a6adf97f83acf6453d4a6a4b1070f3754}} 
None&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Unpacking@{Unpacking}!checkpoint@{checkpoint}}\index{checkpoint@{checkpoint}!Unpacking@{Unpacking}}}\mbox{\Hypertarget{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059a9b87ab5a4e2e99d758991f06cad9c3bf}\label{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059a9b87ab5a4e2e99d758991f06cad9c3bf}} 
Unpacking&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Packing@{Packing}!checkpoint@{checkpoint}}\index{checkpoint@{checkpoint}!Packing@{Packing}}}\mbox{\Hypertarget{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059ac46192253e8458f209a350a132cfc876}\label{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059ac46192253e8458f209a350a132cfc876}} 
Packing&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Sizing@{Sizing}!checkpoint@{checkpoint}}\index{checkpoint@{checkpoint}!Sizing@{Sizing}}}\mbox{\Hypertarget{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059a92672a7a2b909945fbfa9f44f057c7a1}\label{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059a92672a7a2b909945fbfa9f44f057c7a1}} 
Sizing&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Footprinting@{Footprinting}!checkpoint@{checkpoint}}\index{checkpoint@{checkpoint}!Footprinting@{Footprinting}}}\mbox{\Hypertarget{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059afa42c5852085bf97b53b351ba4fcc474}\label{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059afa42c5852085bf97b53b351ba4fcc474}} 
Footprinting&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Invalid@{Invalid}!checkpoint@{checkpoint}}\index{checkpoint@{checkpoint}!Invalid@{Invalid}}}\mbox{\Hypertarget{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059a4bbb8f967da6d1a610596d7257179c2b}\label{namespacecheckpoint_ae2509499ccd8b1dc48fb535bf8aa3059a4bbb8f967da6d1a610596d7257179c2b}} 
Invalid&\\
\hline

\end{DoxyEnumFields}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespacecheckpoint_aee0d7387d339b0275e9b95634748d63b}\label{namespacecheckpoint_aee0d7387d339b0275e9b95634748d63b}} 
\index{checkpoint@{checkpoint}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{deserialize()}{deserialize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T $\ast$ checkpoint\+::deserialize (\begin{DoxyParamCaption}\item[{char $\ast$}]{buf,  }\item[{char $\ast$}]{object\+\_\+buf }\end{DoxyParamCaption})}



De-\/serialize and reify {\ttfamily T} from a byte buffer and corresponding {\ttfamily size}. 

De-\/serializes an object recursively by first invoking the reconstruction strategy and then {\ttfamily serialize} functions/methods recursively to rebuild the state of the object as serialized. During reconstruction, based on trait detection, {\ttfamily T} will either be default constructed on {\ttfamily user\+\_\+buf} (or a system allocated buffer) or reconstructed based on a user-\/defined reconstruct method. If {\ttfamily user\+\_\+buf} is not passed, the returned object point must be deallocated with {\ttfamily delete} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em buf} & the buffer containing the bytes to reify {\ttfamily T} \\
\hline
\mbox{\tt in}  & {\em object\+\_\+buf} & (optional) buffer containing bytes allocated with sufficient size for {\ttfamily T}. If this buffer != null, the caller is responsible for deallocating the buffer. If it is not passed, the system will allocate a buffer that must be de-\/allocated with {\ttfamily delete} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to the newly reified {\ttfamily T} based on bytes in {\ttfamily buf} 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecheckpoint_ab8beefac6b3dc40c69e11dc430618c64}\label{namespacecheckpoint_ab8beefac6b3dc40c69e11dc430618c64}} 
\index{checkpoint@{checkpoint}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{deserialize()}{deserialize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::unique\+\_\+ptr$<$ T $>$ checkpoint\+::deserialize (\begin{DoxyParamCaption}\item[{char $\ast$}]{buf }\end{DoxyParamCaption})}



De-\/serialize and reify {\ttfamily T} from a byte buffer and corresponding {\ttfamily size}. 

De-\/serializes an object recursively by first invoking the reconstruction strategy and then {\ttfamily serialize} functions/methods recursively to rebuild the state of the object as serialized. During reconstruction, based on trait detection, {\ttfamily T} will either be default constructed or reconstructed based on a user-\/defined reconstruct method.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em buf} & the buffer containing the bytes to reify {\ttfamily T} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a unique pointer to the newly reified {\ttfamily T} based on bytes in {\ttfamily buf} 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecheckpoint_a1fa5c2e70f11308a1a94b163924d88f3}\label{namespacecheckpoint_a1fa5c2e70f11308a1a94b163924d88f3}} 
\index{checkpoint@{checkpoint}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{deserialize()}{deserialize()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::unique\+\_\+ptr$<$ T $>$ checkpoint\+::deserialize (\begin{DoxyParamCaption}\item[{\hyperlink{namespacecheckpoint_aa61e2b491f405a63a394f9aad528c37a}{Serialized\+Return\+Type} \&\&}]{in }\end{DoxyParamCaption})}



Convenience function for de-\/serializing and reify {\ttfamily T} directly from {\ttfamily in} the return value from {\ttfamily serialize}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em in} & the buffer and size combo returned from {\ttfamily serialize} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a unique pointer to {\ttfamily T} that must be deallocated 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecheckpoint_a9016e0756f91e6e982b3c824c007c251}\label{namespacecheckpoint_a9016e0756f91e6e982b3c824c007c251}} 
\index{checkpoint@{checkpoint}!deserialize\+Emplace\+Elems@{deserialize\+Emplace\+Elems}}
\index{deserialize\+Emplace\+Elems@{deserialize\+Emplace\+Elems}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{deserialize\+Emplace\+Elems()}{deserializeEmplaceElems()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename ContainerT , typename ElmT $>$ \\
std\+::enable\+\_\+if\+\_\+t$<$ not std\+::is\+\_\+same$<$\hyperlink{structcheckpoint_1_1_serializer}{Serializer}, \hyperlink{structcheckpoint_1_1_footprinter}{checkpoint\+::\+Footprinter}$>$\+::value, void$>$ checkpoint\+::deserialize\+Emplace\+Elems (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{ContainerT \&}]{cont,  }\item[{typename Container\+T\+::size\+\_\+type}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a811956d461a3ebc7329272fd33e1084f}\label{namespacecheckpoint_a811956d461a3ebc7329272fd33e1084f}} 
\index{checkpoint@{checkpoint}!deserialize\+Emplace\+Elems@{deserialize\+Emplace\+Elems}}
\index{deserialize\+Emplace\+Elems@{deserialize\+Emplace\+Elems}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{deserialize\+Emplace\+Elems()}{deserializeEmplaceElems()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename ContainerT , typename ElmT $>$ \\
std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$\hyperlink{structcheckpoint_1_1_serializer}{Serializer}, \hyperlink{structcheckpoint_1_1_footprinter}{checkpoint\+::\+Footprinter}$>$\+::value, void$>$ checkpoint\+::deserialize\+Emplace\+Elems (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{ContainerT \&}]{cont,  }\item[{typename Container\+T\+::size\+\_\+type}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_ad71bcfe197379c59aa16f737b7e2cf3e}\label{namespacecheckpoint_ad71bcfe197379c59aa16f737b7e2cf3e}} 
\index{checkpoint@{checkpoint}!deserialize\+From\+File@{deserialize\+From\+File}}
\index{deserialize\+From\+File@{deserialize\+From\+File}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{deserialize\+From\+File()}{deserializeFromFile()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::unique\+\_\+ptr$<$ T $>$ checkpoint\+::deserialize\+From\+File (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{file }\end{DoxyParamCaption})}



De-\/serialize and reify {\ttfamily T} from a file. 

De-\/serializes an object recursively by first invoking the reconstruction strategy and then {\ttfamily serialize} functions/methods recursively to rebuild the state of the object as serialized. During reconstruction, based on trait detection, {\ttfamily T} will either be default constructed or reconstructed based on a user-\/defined reconstruct method.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file} & the filename to read with bytes for {\ttfamily T} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
unique pointer to the new object {\ttfamily T} 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecheckpoint_af605968a3b8731448c68e5c9fff917ee}\label{namespacecheckpoint_af605968a3b8731448c68e5c9fff917ee}} 
\index{checkpoint@{checkpoint}!deserialize\+In\+Place@{deserialize\+In\+Place}}
\index{deserialize\+In\+Place@{deserialize\+In\+Place}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{deserialize\+In\+Place()}{deserializeInPlace()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void checkpoint\+::deserialize\+In\+Place (\begin{DoxyParamCaption}\item[{char $\ast$}]{buf,  }\item[{T $\ast$}]{t }\end{DoxyParamCaption})}



De-\/serialize and reify {\ttfamily T} from a byte buffer and corresponding {\ttfamily size} in-\/place on the user-\/provided {\ttfamily t}. 

Note\+: the other form of {\ttfamily deserialize} will either reconstruct to default construct {\ttfamily T} in-\/place. This overload will not allocate or construct {\ttfamily T} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em buf} & the buffer containing the bytes to reify {\ttfamily T} \\
\hline
\mbox{\tt in}  & {\em t} & a valid pointer to a {\ttfamily T} that has been user-\/allocated and constructed \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacecheckpoint_a4a98c599eb8a73519cd643bfafb739d5}\label{namespacecheckpoint_a4a98c599eb8a73519cd643bfafb739d5}} 
\index{checkpoint@{checkpoint}!deserialize\+In\+Place\+From\+File@{deserialize\+In\+Place\+From\+File}}
\index{deserialize\+In\+Place\+From\+File@{deserialize\+In\+Place\+From\+File}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{deserialize\+In\+Place\+From\+File()}{deserializeInPlaceFromFile()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void checkpoint\+::deserialize\+In\+Place\+From\+File (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{file,  }\item[{T $\ast$}]{buf }\end{DoxyParamCaption})}



De-\/serialize and reify {\ttfamily T} from a file in place on an existing pointer to {\ttfamily T}. 

De-\/serializes an object recursively by invoking the {\ttfamily serialize} functions/methods recursively to rebuild the state of the object as serialized.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file} & the filename to read with bytes for {\ttfamily T} \\
\hline
\mbox{\tt in}  & {\em t} & a valid, constructed {\ttfamily T} to deserialize into \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacecheckpoint_affdb2f2117fc38cb03d94aa59e1bdf48}\label{namespacecheckpoint_affdb2f2117fc38cb03d94aa59e1bdf48}} 
\index{checkpoint@{checkpoint}!deserialize\+Ordered\+Elems@{deserialize\+Ordered\+Elems}}
\index{deserialize\+Ordered\+Elems@{deserialize\+Ordered\+Elems}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{deserialize\+Ordered\+Elems()}{deserializeOrderedElems()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename ContainerT , typename ElmT $>$ \\
std\+::enable\+\_\+if\+\_\+t$<$ not std\+::is\+\_\+same$<$\hyperlink{structcheckpoint_1_1_serializer}{Serializer}, \hyperlink{structcheckpoint_1_1_footprinter}{checkpoint\+::\+Footprinter}$>$\+::value, void$>$ checkpoint\+::deserialize\+Ordered\+Elems (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{ContainerT \&}]{cont,  }\item[{typename Container\+T\+::size\+\_\+type}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a9976fffc8f39073e5b40ec61d93a5482}\label{namespacecheckpoint_a9976fffc8f39073e5b40ec61d93a5482}} 
\index{checkpoint@{checkpoint}!deserialize\+Ordered\+Elems@{deserialize\+Ordered\+Elems}}
\index{deserialize\+Ordered\+Elems@{deserialize\+Ordered\+Elems}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{deserialize\+Ordered\+Elems()}{deserializeOrderedElems()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename ContainerT , typename ElmT $>$ \\
std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$\hyperlink{structcheckpoint_1_1_serializer}{Serializer}, \hyperlink{structcheckpoint_1_1_footprinter}{checkpoint\+::\+Footprinter}$>$\+::value, void$>$ checkpoint\+::deserialize\+Ordered\+Elems (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{ContainerT \&}]{cont,  }\item[{typename Container\+T\+::size\+\_\+type}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a3c06c0dd0b9bccfd2aa6b79570b9cda1}\label{namespacecheckpoint_a3c06c0dd0b9bccfd2aa6b79570b9cda1}} 
\index{checkpoint@{checkpoint}!get\+Memory\+Footprint@{get\+Memory\+Footprint}}
\index{get\+Memory\+Footprint@{get\+Memory\+Footprint}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{get\+Memory\+Footprint()}{getMemoryFootprint()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::size\+\_\+t checkpoint\+::get\+Memory\+Footprint (\begin{DoxyParamCaption}\item[{T \&}]{target,  }\item[{std\+::size\+\_\+t}]{size\+\_\+offset = {\ttfamily 0} }\end{DoxyParamCaption})}



Get memory footprint of {\ttfamily target}. 

Calculates memory footprint for both serializable and non-\/serializable objects. Uses serialize functions/methods recursively when they are available. For non-\/serializable objects, simplified footprinting is performed by just applying \textquotesingle{}sizeof\textquotesingle{} operator (note\+: this means that complex objects will not be traversed).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em target} & reference to {\ttfamily T} to measure footprint \\
\hline
\mbox{\tt in}  & {\em size\+\_\+offset} & add an arbitrary {\ttfamily size\+\_\+offset} to the footprint\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
memory footprint of the {\ttfamily target} 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecheckpoint_af0e68ef201b5e6831939bcd752e1b18b}\label{namespacecheckpoint_af0e68ef201b5e6831939bcd752e1b18b}} 
\index{checkpoint@{checkpoint}!get\+Size@{get\+Size}}
\index{get\+Size@{get\+Size}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{get\+Size()}{getSize()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::size\+\_\+t checkpoint\+::get\+Size (\begin{DoxyParamCaption}\item[{T \&}]{target }\end{DoxyParamCaption})}



Get the number of bytes that {\ttfamily target} requires for serialization. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em target} & reference to {\ttfamily T} to size\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of bytes for the {\ttfamily target} 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecheckpoint_a09875c2d3c012be868f3fd88b3ed55be}\label{namespacecheckpoint_a09875c2d3c012be868f3fd88b3ed55be}} 
\index{checkpoint@{checkpoint}!instantiate\+Obj\+Serializer@{instantiate\+Obj\+Serializer}}
\index{instantiate\+Obj\+Serializer@{instantiate\+Obj\+Serializer}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{instantiate\+Obj\+Serializer()}{instantiateObjSerializer()}}
{\footnotesize\ttfamily template$<$typename ObjT , typename... Serializer\+Ts$>$ \\
void checkpoint\+::instantiate\+Obj\+Serializer (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a5c9a1c4d05ec6880270c9a6d0dded825}\label{namespacecheckpoint_a5c9a1c4d05ec6880270c9a6d0dded825}} 
\index{checkpoint@{checkpoint}!operator\texttt{"|}@{operator\texttt{"|}}}
\index{operator\texttt{"|}@{operator\texttt{"|}}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{operator\texttt{"|}()}{operator|()}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T $>$ \\
\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \& checkpoint\+::operator$\vert$ (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{T \&}]{target }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a6254f2e220f905a2b0c797c08092a7a1}\label{namespacecheckpoint_a6254f2e220f905a2b0c797c08092a7a1}} 
\index{checkpoint@{checkpoint}!reconstruct@{reconstruct}}
\index{reconstruct@{reconstruct}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{reconstruct()}{reconstruct()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void checkpoint\+::reconstruct (\begin{DoxyParamCaption}\item[{T}]{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a9ffb72abb4d8c3fe031626dbf526d70c}\label{namespacecheckpoint_a9ffb72abb4d8c3fe031626dbf526d70c}} 
\index{checkpoint@{checkpoint}!reconstruct\+Pointed\+To\+Object\+If\+Needed@{reconstruct\+Pointed\+To\+Object\+If\+Needed}}
\index{reconstruct\+Pointed\+To\+Object\+If\+Needed@{reconstruct\+Pointed\+To\+Object\+If\+Needed}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{reconstruct\+Pointed\+To\+Object\+If\+Needed()}{reconstructPointedToObjectIfNeeded()}}
{\footnotesize\ttfamily template$<$typename SerializerT , typename T $>$ \\
void checkpoint\+::reconstruct\+Pointed\+To\+Object\+If\+Needed (\begin{DoxyParamCaption}\item[{SerializerT \&}]{s,  }\item[{T $\ast$\&}]{target }\end{DoxyParamCaption})}



Allocate and construct memory for a pointer with type {\ttfamily T}. 

This function automatically handles allocating and constructing the right type for virtually serialized pointers or non-\/virtual static allocation and construction.

An example of how to use this to properly serialize a std\+::shared\+\_\+ptr$<$\+T$>$\+:

template $<$typename t$>$=\char`\"{}\char`\"{}$>$ struct X \{ std\+::shared\+\_\+ptr$<$\+T$>$ a;

template $<$typename serializert$>$=\char`\"{}\char`\"{}$>$ void serialize(\+Serializer\+T\& s) \{ T$\ast$ raw = elm.\+get(); checkpoint\+::reconstruct\+Pointed\+To\+Object\+If\+Needed(s, raw); if (s.\+is\+Unpacking()) \{ a = std\+::shared\+\_\+ptr$<$\+T$>$(raw); \} s $\vert$ $\ast$a; \} \};


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em s} & the serializer \\
\hline
\mbox{\tt in}  & {\em target} & a reference to a pointer to the target object \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacecheckpoint_aec244476371c452d9d9318b9d5b24401}\label{namespacecheckpoint_aec244476371c452d9d9318b9d5b24401}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename Rep , typename Period $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::chrono\+::duration$<$ Rep, Period $>$ \&}]{d }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a617341cb0473cbdce921a3a4d049f4fc}\label{namespacecheckpoint_a617341cb0473cbdce921a3a4d049f4fc}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T , typename Deleter $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::unique\+\_\+ptr$<$ T, Deleter $>$ \&}]{ptr }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a5621e2549443d76acad6c83fdfdcbeab}\label{namespacecheckpoint_a5621e2549443d76acad6c83fdfdcbeab}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [3/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{const std\+::queue$<$ T $>$ \&}]{q }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a976e83bf5f22b7bfc5036fd829be039e}\label{namespacecheckpoint_a976e83bf5f22b7bfc5036fd829be039e}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [4/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T , size\+\_\+t N$>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::array$<$ T, N $>$ \&}]{array }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_ab9c05efe18a47d990fb20e84f73e9943}\label{namespacecheckpoint_ab9c05efe18a47d990fb20e84f73e9943}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [5/27]}}
{\footnotesize\ttfamily template$<$typename SerializerT , typename  = std\+::enable\+\_\+if\+\_\+t$<$    std\+::is\+\_\+same$<$\+Serializer\+T, checkpoint\+::\+Footprinter$>$\+::value  $>$$>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{SerializerT \&}]{s,  }\item[{const std\+::thread \&}]{t }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a40ca9a5c99807bd8a0610098d94b5125}\label{namespacecheckpoint_a40ca9a5c99807bd8a0610098d94b5125}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [6/27]}}
{\footnotesize\ttfamily template$<$typename SerializerT , typename T , typename  = std\+::enable\+\_\+if\+\_\+t$<$    std\+::is\+\_\+same$<$\+Serializer\+T, checkpoint\+::\+Footprinter$>$\+::value  $>$$>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{SerializerT \&}]{s,  }\item[{const std\+::atomic$<$ T $>$ \&}]{atomic }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a9493433bed418b54358130463961ce50}\label{namespacecheckpoint_a9493433bed418b54358130463961ce50}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [7/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{const std\+::priority\+\_\+queue$<$ T $>$ \&}]{q }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_aff1bebba5ce7fda79f83d2af8c859254}\label{namespacecheckpoint_aff1bebba5ce7fda79f83d2af8c859254}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [8/27]}}
{\footnotesize\ttfamily template$<$typename SerializerT , typename T , typename  = std\+::enable\+\_\+if\+\_\+t$<$    std\+::is\+\_\+same$<$      Serializer\+T,      checkpoint\+::\+Footprinter    $>$\+::value  $>$$>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{SerializerT \&}]{s,  }\item[{std\+::shared\+\_\+ptr$<$ T $>$ \&}]{ptr }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_ad3043fe034b7bf1d0d864e1e819c84d4}\label{namespacecheckpoint_ad3043fe034b7bf1d0d864e1e819c84d4}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [9/27]}}
{\footnotesize\ttfamily template$<$typename SerializerT , typename Res , typename... Arg\+Types$>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{SerializerT \&}]{s,  }\item[{std\+::function$<$ Res(Arg\+Types...)$>$ \&}]{fn }\end{DoxyParamCaption})}



Serialize function {\ttfamily func}. 

Only footprinting mode is supported at the moment.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em serializer} & serializer to use \\
\hline
\mbox{\tt in}  & {\em func} & function to serialize \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacecheckpoint_a7ac21fa6ad08fd64a47c789c32966019}\label{namespacecheckpoint_a7ac21fa6ad08fd64a47c789c32966019}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [10/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename... Args$>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::tuple$<$ Args... $>$ \&}]{tuple }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a1d399ef63dc7723f1b4387e4605b3259}\label{namespacecheckpoint_a1d399ef63dc7723f1b4387e4605b3259}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [11/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{const std\+::stack$<$ T $>$ \&}]{stack }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a7b5c3ff67d3f7b65cfb46da7617e87ad}\label{namespacecheckpoint_a7b5c3ff67d3f7b65cfb46da7617e87ad}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [12/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T , typename U $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::pair$<$ T, U $>$ \&}]{pair }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a5242b8701b19ff5eeb7587fb4a07bfe9}\label{namespacecheckpoint_a5242b8701b19ff5eeb7587fb4a07bfe9}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [13/27]}}
{\footnotesize\ttfamily template$<$typename SerializerT , typename T , typename  = std\+::enable\+\_\+if\+\_\+t$<$    std\+::is\+\_\+same$<$      Serializer\+T,      checkpoint\+::\+Footprinter    $>$\+::value  $>$$>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{SerializerT \&}]{s,  }\item[{T $\ast$}]{ptr }\end{DoxyParamCaption})}



Serialize raw pointer {\ttfamily ptr}. 

Only footprinting mode is supported at the moment. Counts the pointer size and follows it (note that it doesn\textquotesingle{}t work correctly for C-\/style arrays!).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em serializer} & serializer to use \\
\hline
\mbox{\tt in}  & {\em ptr} & pointer to serialize \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacecheckpoint_aef8e8717e4cc129379525653730c4eba}\label{namespacecheckpoint_aef8e8717e4cc129379525653730c4eba}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [14/27]}}
{\footnotesize\ttfamily template$<$typename Serializer $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::string \&}]{str }\end{DoxyParamCaption})}



Serialize string {\ttfamily str}. 

Resizes a string to its actual size and serializes it. Note\+: footprinting mode does not detect small string optimization, so a limited overcount is possible.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em serializer} & serializer to use \\
\hline
\mbox{\tt in}  & {\em str} & string to serialize \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacecheckpoint_a3a422f601605de1c02c6bdd57f3dc93b}\label{namespacecheckpoint_a3a422f601605de1c02c6bdd57f3dc93b}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [15/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T , typename Vector\+Allocator $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::vector$<$ T, Vector\+Allocator $>$ \&}]{vec }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a075da4e7344cf037943362517e606c3a}\label{namespacecheckpoint_a075da4e7344cf037943362517e606c3a}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [16/27]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\hyperlink{namespacecheckpoint_aa61e2b491f405a63a394f9aad528c37a}{Serialized\+Return\+Type} checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{T \&}]{target,  }\item[{\hyperlink{namespacecheckpoint_a70bc1b37eae8e32129df38d981ef90f6}{Buffer\+Callback\+Type}}]{fn = {\ttfamily nullptr} }\end{DoxyParamCaption})}



Serialize {\ttfamily T} into a byte buffer. 

Serializes an object recursively by invoking the {\ttfamily serialize} functions/methods recursively.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em target} & the {\ttfamily T} to serialize \\
\hline
\mbox{\tt in}  & {\em fn} & (optional) callback to supply buffer for to allow user allocation of the produced byte buffer. The callback will be passed the number of bytes required and return a char$\ast$ to a buffer of at least that many bytes.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a {\ttfamily std\+::unique\+\_\+ptr} to a {\ttfamily \hyperlink{structcheckpoint_1_1_serialized_info}{Serialized\+Info}} containing the buffer with serialized data and the size of the buffer 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecheckpoint_aef7e26930d4d3446970f8aca0640b11d}\label{namespacecheckpoint_aef7e26930d4d3446970f8aca0640b11d}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [17/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename Vector\+Allocator $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::vector$<$ bool, Vector\+Allocator $>$ \&}]{vec }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_afb32627049eb840e4f8b9fd3022f2eb2}\label{namespacecheckpoint_afb32627049eb840e4f8b9fd3022f2eb2}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [18/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::list$<$ T $>$ \&}]{lst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a39ee0888319dc204dff7af20dd1e8238}\label{namespacecheckpoint_a39ee0888319dc204dff7af20dd1e8238}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [19/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T , typename U , typename Comp $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::map$<$ T, U, Comp $>$ \&}]{map }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a179b767294c9b23617f30fc4566d0be7}\label{namespacecheckpoint_a179b767294c9b23617f30fc4566d0be7}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [20/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::deque$<$ T $>$ \&}]{lst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a44434f578fc304afa3a62a9305be2a65}\label{namespacecheckpoint_a44434f578fc304afa3a62a9305be2a65}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [21/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T , typename U , typename Comp $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::multimap$<$ T, U, Comp $>$ \&}]{map }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a9f1869781f4cce4db94c144174680b24}\label{namespacecheckpoint_a9f1869781f4cce4db94c144174680b24}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [22/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T , typename Comp $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::set$<$ T, Comp $>$ \&}]{set }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_ae032265314cdf8e9155a6bbc423ca1c9}\label{namespacecheckpoint_ae032265314cdf8e9155a6bbc423ca1c9}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [23/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T , typename Comp $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::multiset$<$ T, Comp $>$ \&}]{set }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a9fc2f3eb20d3ce8d6145e99a2559ea58}\label{namespacecheckpoint_a9fc2f3eb20d3ce8d6145e99a2559ea58}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [24/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T , typename U , typename Hash , typename Eq $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::unordered\+\_\+map$<$ T, U, Hash, Eq $>$ \&}]{map }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_aa77eeb7a036d253ef33ed2c9ef764a5e}\label{namespacecheckpoint_aa77eeb7a036d253ef33ed2c9ef764a5e}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [25/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T , typename U , typename Hash , typename Eq $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::unordered\+\_\+multimap$<$ T, U, Hash, Eq $>$ \&}]{map }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_ae4ca8cbc6daf2f5a2a20d44d9fe1cc9f}\label{namespacecheckpoint_ae4ca8cbc6daf2f5a2a20d44d9fe1cc9f}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [26/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T , typename Hash , typename Eq $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::unordered\+\_\+set$<$ T, Hash, Eq $>$ \&}]{set }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a64c8a1aa29d469bc71c88a8836264ecc}\label{namespacecheckpoint_a64c8a1aa29d469bc71c88a8836264ecc}} 
\index{checkpoint@{checkpoint}!serialize@{serialize}}
\index{serialize@{serialize}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [27/27]}}
{\footnotesize\ttfamily template$<$typename Serializer , typename T , typename Hash , typename Eq $>$ \\
void checkpoint\+::serialize (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::unordered\+\_\+multiset$<$ T, Hash, Eq $>$ \&}]{set }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a9c880ba9bb9a106e784e06554b2fbcf2}\label{namespacecheckpoint_a9c880ba9bb9a106e784e06554b2fbcf2}} 
\index{checkpoint@{checkpoint}!serialize\+Container\+Elems@{serialize\+Container\+Elems}}
\index{serialize\+Container\+Elems@{serialize\+Container\+Elems}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize\+Container\+Elems()}{serializeContainerElems()}}
{\footnotesize\ttfamily template$<$typename Serializer , typename ContainerT $>$ \\
void checkpoint\+::serialize\+Container\+Elems (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{ContainerT \&}]{cont }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a3359595d5a4c6fcf5fc95069c71f869b}\label{namespacecheckpoint_a3359595d5a4c6fcf5fc95069c71f869b}} 
\index{checkpoint@{checkpoint}!serialize\+Container\+Size@{serialize\+Container\+Size}}
\index{serialize\+Container\+Size@{serialize\+Container\+Size}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize\+Container\+Size()}{serializeContainerSize()}}
{\footnotesize\ttfamily template$<$typename Serializer , typename ContainerT $>$ \\
Container\+T\+::size\+\_\+type checkpoint\+::serialize\+Container\+Size (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{ContainerT \&}]{cont }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a5f368cb543eec78bb608a68fe2401562}\label{namespacecheckpoint_a5f368cb543eec78bb608a68fe2401562}} 
\index{checkpoint@{checkpoint}!serialize\+Enum@{serialize\+Enum}}
\index{serialize\+Enum@{serialize\+Enum}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize\+Enum()}{serializeEnum()}}
{\footnotesize\ttfamily template$<$typename Serializer , typename Enum , typename Underlying  = std\+::underlying\+\_\+type\+\_\+t$<$\+Enum$>$$>$ \\
void checkpoint\+::serialize\+Enum (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{Enum \&}]{e }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a4161978e6d6de385d942cbcbe659817a}\label{namespacecheckpoint_a4161978e6d6de385d942cbcbe659817a}} 
\index{checkpoint@{checkpoint}!serialize\+Function@{serialize\+Function}}
\index{serialize\+Function@{serialize\+Function}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize\+Function()}{serializeFunction()}}
{\footnotesize\ttfamily template$<$typename SerializerT , typename Res , typename... Arg\+Types, typename  = std\+::enable\+\_\+if\+\_\+t$<$    std\+::is\+\_\+same$<$      Serializer\+T,      checkpoint\+::\+Footprinter    $>$\+::value  $>$$>$ \\
void checkpoint\+::serialize\+Function (\begin{DoxyParamCaption}\item[{SerializerT \&}]{s,  }\item[{std\+::function$<$ Res(Arg\+Types...)$>$ \&}]{fn }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a99092baac18b33d03b1bb47ed1f2d7fa}\label{namespacecheckpoint_a99092baac18b33d03b1bb47ed1f2d7fa}} 
\index{checkpoint@{checkpoint}!serialize\+Map\+Like\+Container@{serialize\+Map\+Like\+Container}}
\index{serialize\+Map\+Like\+Container@{serialize\+Map\+Like\+Container}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize\+Map\+Like\+Container()}{serializeMapLikeContainer()}}
{\footnotesize\ttfamily template$<$typename Serializer , typename ContainerT $>$ \\
void checkpoint\+::serialize\+Map\+Like\+Container (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{ContainerT \&}]{cont }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a0b15edc50a881e06260e7112b2c60742}\label{namespacecheckpoint_a0b15edc50a881e06260e7112b2c60742}} 
\index{checkpoint@{checkpoint}!serialize\+Ordered\+Container@{serialize\+Ordered\+Container}}
\index{serialize\+Ordered\+Container@{serialize\+Ordered\+Container}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize\+Ordered\+Container()}{serializeOrderedContainer()}}
{\footnotesize\ttfamily template$<$typename Serializer , typename ContainerT $>$ \\
void checkpoint\+::serialize\+Ordered\+Container (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{ContainerT \&}]{cont }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespacecheckpoint_a33956387419a85cfe810fbce88f5bdf9}\label{namespacecheckpoint_a33956387419a85cfe810fbce88f5bdf9}} 
\index{checkpoint@{checkpoint}!serialize\+Queue\+Like\+Container@{serialize\+Queue\+Like\+Container}}
\index{serialize\+Queue\+Like\+Container@{serialize\+Queue\+Like\+Container}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize\+Queue\+Like\+Container()}{serializeQueueLikeContainer()}}
{\footnotesize\ttfamily template$<$typename SerializerT , typename Q , typename  = std\+::enable\+\_\+if\+\_\+t$<$    std\+::is\+\_\+same$<$      Serializer\+T,      checkpoint\+::\+Footprinter    $>$\+::value  $>$$>$ \\
void checkpoint\+::serialize\+Queue\+Like\+Container (\begin{DoxyParamCaption}\item[{SerializerT \&}]{s,  }\item[{const Q \&}]{q }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a6113644a35f5023a57e2ed3ca4814490}\label{namespacecheckpoint_a6113644a35f5023a57e2ed3ca4814490}} 
\index{checkpoint@{checkpoint}!serialize\+Raw\+Ptr@{serialize\+Raw\+Ptr}}
\index{serialize\+Raw\+Ptr@{serialize\+Raw\+Ptr}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize\+Raw\+Ptr()}{serializeRawPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename SerializerT , typename T $>$ \\
void checkpoint\+::serialize\+Raw\+Ptr (\begin{DoxyParamCaption}\item[{SerializerT \&}]{s,  }\item[{T $\ast$}]{ptr }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_aaadeb0ab61d069afc8a97ec6b6dc630c}\label{namespacecheckpoint_aaadeb0ab61d069afc8a97ec6b6dc630c}} 
\index{checkpoint@{checkpoint}!serialize\+Raw\+Ptr@{serialize\+Raw\+Ptr}}
\index{serialize\+Raw\+Ptr@{serialize\+Raw\+Ptr}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize\+Raw\+Ptr()}{serializeRawPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename SerializerT $>$ \\
void checkpoint\+::serialize\+Raw\+Ptr (\begin{DoxyParamCaption}\item[{SerializerT \&}]{s,  }\item[{void $\ast$}]{ptr }\end{DoxyParamCaption})}

Note\+: do not follow void pointer. \mbox{\Hypertarget{namespacecheckpoint_a1ea8e1ef9d0a10d26df77cb5309435aa}\label{namespacecheckpoint_a1ea8e1ef9d0a10d26df77cb5309435aa}} 
\index{checkpoint@{checkpoint}!serialize\+String\+Meta@{serialize\+String\+Meta}}
\index{serialize\+String\+Meta@{serialize\+String\+Meta}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize\+String\+Meta()}{serializeStringMeta()}}
{\footnotesize\ttfamily template$<$typename Serializer $>$ \\
void checkpoint\+::serialize\+String\+Meta (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::string \&}]{str }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a3d4326982e3c3feeb933e985758eea82}\label{namespacecheckpoint_a3d4326982e3c3feeb933e985758eea82}} 
\index{checkpoint@{checkpoint}!serialize\+To\+File@{serialize\+To\+File}}
\index{serialize\+To\+File@{serialize\+To\+File}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize\+To\+File()}{serializeToFile()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void checkpoint\+::serialize\+To\+File (\begin{DoxyParamCaption}\item[{T \&}]{target,  }\item[{std\+::string const \&}]{file }\end{DoxyParamCaption})}



Serialize {\ttfamily T} to file with filename {\ttfamily file}. 

Byte-\/serializes {\ttfamily T} to file, truncating {\ttfamily file} if it already exists. If any error occurs while opening/closing/mapping the file, {\ttfamily std\+::runtime\+\_\+error} will be thrown with an appropriate error message containing the corresponding errno.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em target} & the {\ttfamily T} to serialize \\
\hline
\mbox{\tt in}  & {\em file} & name of the file to create \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacecheckpoint_ae257a02737b213492283962cc645c6a5}\label{namespacecheckpoint_ae257a02737b213492283962cc645c6a5}} 
\index{checkpoint@{checkpoint}!serialize\+Vector\+Meta@{serialize\+Vector\+Meta}}
\index{serialize\+Vector\+Meta@{serialize\+Vector\+Meta}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize\+Vector\+Meta()}{serializeVectorMeta()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename SerializerT , typename T , typename Vector\+Allocator $>$ \\
std\+::enable\+\_\+if\+\_\+t$<$ not std\+::is\+\_\+same$<$SerializerT, \hyperlink{structcheckpoint_1_1_footprinter}{checkpoint\+::\+Footprinter}$>$\+::value, void$>$ checkpoint\+::serialize\+Vector\+Meta (\begin{DoxyParamCaption}\item[{SerializerT \&}]{s,  }\item[{std\+::vector$<$ T, Vector\+Allocator $>$ \&}]{vec }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_a0133c00735e3d54bb46ffa9e24d59d7b}\label{namespacecheckpoint_a0133c00735e3d54bb46ffa9e24d59d7b}} 
\index{checkpoint@{checkpoint}!serialize\+Vector\+Meta@{serialize\+Vector\+Meta}}
\index{serialize\+Vector\+Meta@{serialize\+Vector\+Meta}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{serialize\+Vector\+Meta()}{serializeVectorMeta()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename SerializerT , typename T , typename Vector\+Allocator $>$ \\
std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$SerializerT, \hyperlink{structcheckpoint_1_1_footprinter}{checkpoint\+::\+Footprinter}$>$\+::value, void$>$ checkpoint\+::serialize\+Vector\+Meta (\begin{DoxyParamCaption}\item[{SerializerT \&}]{s,  }\item[{std\+::vector$<$ T, Vector\+Allocator $>$ \&}]{vec }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecheckpoint_ab763d3ca9396ff9a1896f5da6c2b3c54}\label{namespacecheckpoint_ab763d3ca9396ff9a1896f5da6c2b3c54}} 
\index{checkpoint@{checkpoint}!tuple\+\_\+helper@{tuple\+\_\+helper}}
\index{tuple\+\_\+helper@{tuple\+\_\+helper}!checkpoint@{checkpoint}}
\subsubsection{\texorpdfstring{tuple\+\_\+helper()}{tuple\_helper()}}
{\footnotesize\ttfamily template$<$typename Serializer , typename... T, size\+\_\+t... Idxs$>$ \\
void checkpoint\+::tuple\+\_\+helper (\begin{DoxyParamCaption}\item[{\hyperlink{structcheckpoint_1_1_serializer}{Serializer} \&}]{s,  }\item[{std\+::tuple$<$ T... $>$ \&}]{tup,  }\item[{std\+::index\+\_\+sequence$<$ Idxs... $>$}]{ }\end{DoxyParamCaption})}

