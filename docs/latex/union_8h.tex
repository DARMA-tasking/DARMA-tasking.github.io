\hypertarget{union_8h}{}\section{src/vt/utils/adt/union.h File Reference}
\label{union_8h}\index{src/vt/utils/adt/union.\+h@{src/vt/utils/adt/union.\+h}}
{\ttfamily \#include \char`\"{}vt/config.\+h\char`\"{}}\newline
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{unionvt_1_1util_1_1adt_1_1detail_1_1_sizer}{vt\+::util\+::adt\+::detail\+::\+Sizer$<$ T, Ts $>$}
\begin{DoxyCompactList}\small\item\em Union of char\mbox{[}sizeof(\+U)\mbox{]} all types (T, Ts...) which is never constructed but used to calculate the appropriate size of the {\ttfamily \hyperlink{structvt_1_1util_1_1adt_1_1_aligned_char_union}{Aligned\+Char\+Union}} to hold any of these types. \end{DoxyCompactList}\item 
union \hyperlink{unionvt_1_1util_1_1adt_1_1detail_1_1_sizer_3_01_t_01_4}{vt\+::util\+::adt\+::detail\+::\+Sizer$<$ T $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_aligner}{vt\+::util\+::adt\+::detail\+::\+Aligner$<$ T, Ts $>$}
\begin{DoxyCompactList}\small\item\em Contains all the types (T, Ts...) to determine the max alignment required for them for the alignas in the {\ttfamily \hyperlink{structvt_1_1util_1_1adt_1_1_aligned_char_union}{Aligned\+Char\+Union}}. \end{DoxyCompactList}\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_aligner_3_01_t_01_4}{vt\+::util\+::adt\+::detail\+::\+Aligner$<$ T $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_must_be}{vt\+::util\+::adt\+::detail\+::\+Must\+Be$<$ T, Us $>$}
\begin{DoxyCompactList}\small\item\em Used to assert that {\ttfamily T} is included in {\ttfamily Us}. \end{DoxyCompactList}\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_must_be_3_01_t_00_01_u_00_01_us_8_8_8_01_4}{vt\+::util\+::adt\+::detail\+::\+Must\+Be$<$ T, U, Us... $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_must_be_3_01_t_01_4}{vt\+::util\+::adt\+::detail\+::\+Must\+Be$<$ T $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_get_place}{vt\+::util\+::adt\+::detail\+::\+Get\+Place$<$ Us $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_which}{vt\+::util\+::adt\+::detail\+::\+Which$<$ T, U, Us $>$}
\begin{DoxyCompactList}\small\item\em Find the place of a given {\ttfamily T} inside a pack {\ttfamily U}, Us... \end{DoxyCompactList}\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_which_impl}{vt\+::util\+::adt\+::detail\+::\+Which\+Impl$<$ T, U, Enable, Us $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_which_impl_3_01_t_00_01_u_00_01typename_01std_1_1enable__i0f067a3d2e31ed39b40aceedb711df3e}{vt\+::util\+::adt\+::detail\+::\+Which\+Impl$<$ T, U, typename std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$ T, U $>$\+::value $>$, Us... $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_which_impl_3_01_t_00_01_u_00_01typename_01std_1_1enable__i4d9447de0f2954cce0452213fa3ad5db}{vt\+::util\+::adt\+::detail\+::\+Which\+Impl$<$ T, U, typename std\+::enable\+\_\+if\+\_\+t$<$ not std\+::is\+\_\+same$<$ T, U $>$\+::value $>$, Us... $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_which}{vt\+::util\+::adt\+::detail\+::\+Which$<$ T, U, Us $>$}
\begin{DoxyCompactList}\small\item\em Find the place of a given {\ttfamily T} inside a pack {\ttfamily U}, Us... \end{DoxyCompactList}\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_deallocate}{vt\+::util\+::adt\+::detail\+::\+Deallocate$<$ T, Ts $>$}
\begin{DoxyCompactList}\small\item\em Automatically deallocate based on active element. \end{DoxyCompactList}\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_deallocate_3_01_t_01_4}{vt\+::util\+::adt\+::detail\+::\+Deallocate$<$ T $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_copy}{vt\+::util\+::adt\+::detail\+::\+Copy$<$ T, Ts $>$}
\begin{DoxyCompactList}\small\item\em Automatically invoke the right copy constructor. \end{DoxyCompactList}\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_copy_3_01_t_01_4}{vt\+::util\+::adt\+::detail\+::\+Copy$<$ T $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_move}{vt\+::util\+::adt\+::detail\+::\+Move$<$ T, Ts $>$}
\begin{DoxyCompactList}\small\item\em Automatically invoke the right move constructor. \end{DoxyCompactList}\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_move_3_01_t_01_4}{vt\+::util\+::adt\+::detail\+::\+Move$<$ T $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_serialize}{vt\+::util\+::adt\+::detail\+::\+Serialize$<$ T, Ts $>$}
\begin{DoxyCompactList}\small\item\em Automatically invoke the right serializer. \end{DoxyCompactList}\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_serialize_3_01_t_01_4}{vt\+::util\+::adt\+::detail\+::\+Serialize$<$ T $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_compare}{vt\+::util\+::adt\+::detail\+::\+Compare$<$ T, Ts $>$}
\begin{DoxyCompactList}\small\item\em Automatically invoke the underlying comparison. \end{DoxyCompactList}\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_compare_3_01_t_01_4}{vt\+::util\+::adt\+::detail\+::\+Compare$<$ T $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_hash}{vt\+::util\+::adt\+::detail\+::\+Hash$<$ T, Ts $>$}
\begin{DoxyCompactList}\small\item\em Automatically invoke the right hash. \end{DoxyCompactList}\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_hash_3_01_t_01_4}{vt\+::util\+::adt\+::detail\+::\+Hash$<$ T $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_is_trivially_destructible}{vt\+::util\+::adt\+::detail\+::\+Is\+Trivially\+Destructible$<$ T, Ts $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_is_trivially_destructible_3_01_t_01_4}{vt\+::util\+::adt\+::detail\+::\+Is\+Trivially\+Destructible$<$ T $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_is_trivially_copyable}{vt\+::util\+::adt\+::detail\+::\+Is\+Trivially\+Copyable$<$ T, Ts $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_is_trivially_copyable_3_01_t_01_4}{vt\+::util\+::adt\+::detail\+::\+Is\+Trivially\+Copyable$<$ T $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_all_unique}{vt\+::util\+::adt\+::detail\+::\+All\+Unique$<$ Ts $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_all_unique_3_01_u_00_01_t_00_01_ts_8_8_8_01_4}{vt\+::util\+::adt\+::detail\+::\+All\+Unique$<$ U, T, Ts... $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1detail_1_1_all_unique_3_01_u_00_01_t_01_4}{vt\+::util\+::adt\+::detail\+::\+All\+Unique$<$ U, T $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1_union_base}{vt\+::util\+::adt\+::\+Union\+Base$<$ T, Ts $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1_union_destroy}{vt\+::util\+::adt\+::\+Union\+Destroy$<$ T, Enable, Ts $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1_union_destroy_3_01_t_00_01typename_01std_1_1enable__if__t_3_01detail42179a636679a7a81522739bdddb7210}{vt\+::util\+::adt\+::\+Union\+Destroy$<$ T, typename std\+::enable\+\_\+if\+\_\+t$<$ detail\+::\+Is\+Trivially\+Destructible$<$ T, Ts... $>$\+::value $>$, Ts... $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1_union_destroy_3_01_t_00_01typename_01std_1_1enable__if__t_3_01not_0117947c5b8b44b7d9f4a4df27d8795277}{vt\+::util\+::adt\+::\+Union\+Destroy$<$ T, typename std\+::enable\+\_\+if\+\_\+t$<$ not detail\+::\+Is\+Trivially\+Destructible$<$ T, Ts... $>$\+::value $>$, Ts... $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1_union_copy}{vt\+::util\+::adt\+::\+Union\+Copy$<$ T, Enable, Ts $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1_union_copy_3_01_t_00_01typename_01std_1_1enable__if__t_3_01detail_1_39951ca88dc847bbf698c46d828c8188}{vt\+::util\+::adt\+::\+Union\+Copy$<$ T, typename std\+::enable\+\_\+if\+\_\+t$<$ detail\+::\+Is\+Trivially\+Copyable$<$ T, Ts... $>$\+::value $>$, Ts... $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1_union_copy_3_01_t_00_01typename_01std_1_1enable__if__t_3_01not_01det4a1e3b5522a7a77cb5d4fb8991a6197b}{vt\+::util\+::adt\+::\+Union\+Copy$<$ T, typename std\+::enable\+\_\+if\+\_\+t$<$ not detail\+::\+Is\+Trivially\+Copyable$<$ T, Ts... $>$\+::value $>$, Ts... $>$}
\item 
struct \hyperlink{structvt_1_1util_1_1adt_1_1_aligned_char_union}{vt\+::util\+::adt\+::\+Aligned\+Char\+Union$<$ T, Ts $>$}
\begin{DoxyCompactList}\small\item\em An aligned type-\/safe union that remembers its last type and runtime checks to ensure correctness. \end{DoxyCompactList}\item 
struct \hyperlink{structstd_1_1hash_3_01vt_1_1util_1_1adt_1_1_aligned_char_union_3_01_t_00_01_ts_8_8_8_01_4_01_4}{std\+::hash$<$ vt\+::util\+::adt\+::\+Aligned\+Char\+Union$<$ T, Ts... $>$ $>$}
\end{DoxyCompactItemize}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespacevt}{vt}
\item 
 \hyperlink{namespacevt_1_1util}{vt\+::util}
\item 
 \hyperlink{namespacevt_1_1util_1_1adt}{vt\+::util\+::adt}
\item 
 \hyperlink{namespacevt_1_1util_1_1adt_1_1detail}{vt\+::util\+::adt\+::detail}
\item 
 \hyperlink{namespacestd}{std}
\item 
 \hyperlink{namespacevt_1_1adt}{vt\+::adt}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T , typename... Ts$>$ }\\using \hyperlink{namespacevt_1_1adt_ad2a7bbcb5f4735ae9d847f96ee62f144}{vt\+::adt\+::\+Safe\+Union} = util\+::adt\+::\+Aligned\+Char\+Union$<$ T, Ts... $>$
\end{DoxyCompactItemize}
