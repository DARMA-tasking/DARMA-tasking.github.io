\hypertarget{structvt_1_1pool_1_1_pool}{}\doxysection{vt\+::pool\+::Pool Struct Reference}
\label{structvt_1_1pool_1_1_pool}\index{vt::pool::Pool@{vt::pool::Pool}}


A core VT component that manages efficient pools of memory for quick allocation/deallocation.  




{\ttfamily \#include $<$pool.\+h$>$}

Inheritance diagram for vt\+::pool\+::Pool\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.671756cm]{structvt_1_1pool_1_1_pool}
\end{center}
\end{figure}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28}{e\+Pool\+Size}} \{ \mbox{\hyperlink{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28a2660064e68655415da2628c2ae2f7592}{e\+Pool\+Size\+::\+Small}} = 1, 
\mbox{\hyperlink{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28a87f8a6ab85c9ced3702b4ea641ad4bb5}{e\+Pool\+Size\+::\+Medium}} = 2, 
\mbox{\hyperlink{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28a3a69b34ce86dacb205936a8094f6c743}{e\+Pool\+Size\+::\+Large}} = 3, 
\mbox{\hyperlink{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28a1131a914388fac73e5f07b0ba0aad523}{e\+Pool\+Size\+::\+Malloc}} = 4
 \}
\begin{DoxyCompactList}\small\item\em Different pool sizes\+: small, medium, large, and the backup malloc. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a4030898e09d0160c24743a7b949c0d46}{Size\+Type}} = size\+\_\+t
\item 
using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a887de970f8d8fbec63df120348c31404}{Header\+Type}} = \mbox{\hyperlink{structvt_1_1pool_1_1_header}{Header}}
\item 
using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_acc5ad2d64bf6ff58fead958a69c12d74}{Header\+Manager\+Type}} = \mbox{\hyperlink{structvt_1_1pool_1_1_header_manager}{Header\+Manager}}
\item 
{\footnotesize template$<$int64\+\_\+t num\+\_\+bytes\+\_\+t$>$ }\\using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a06673914350d933ad5205155eca14a3b}{Memory\+Pool\+Type}} = \mbox{\hyperlink{structvt_1_1pool_1_1_memory_pool_equal}{Memory\+Pool\+Equal}}$<$ num\+\_\+bytes\+\_\+t $>$
\item 
{\footnotesize template$<$int64\+\_\+t num\+\_\+bytes\+\_\+t$>$ }\\using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a21e20f5b56c3bae4f0d0cc36ed9c5eee}{Memory\+Pool\+Ptr\+Type}} = std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a06673914350d933ad5205155eca14a3b}{Memory\+Pool\+Type}}$<$ num\+\_\+bytes\+\_\+t $>$ $>$
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structvt_1_1pool_1_1_pool_a55a236c42c331940884370c85fb18e36}{Pool}} ()
\begin{DoxyCompactList}\small\item\em System construction of the pool component. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a02fa54fc3cca0d388f25f397dfd997ab}{name}} () override
\begin{DoxyCompactList}\small\item\em Get the name of the component. \end{DoxyCompactList}\item 
std\+::byte $\ast$ \mbox{\hyperlink{structvt_1_1pool_1_1_pool_ab26d54516b6337e4a3b9d00a8ded8e7b}{alloc}} (size\+\_\+t const \&num\+\_\+bytes, size\+\_\+t oversize=0)
\begin{DoxyCompactList}\small\item\em Allocate some number of bytes plus extra size at the end. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a663e56d8623fa74119aede185dac5e1d}{dealloc}} (std\+::byte $\ast$const buf)
\begin{DoxyCompactList}\small\item\em De-\/allocate a pool-\/allocated buffer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28}{e\+Pool\+Size}} \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a6b0dea52c80b6493431ce94840e7bc4a}{get\+Pool\+Type}} (size\+\_\+t const \&num\+\_\+bytes, size\+\_\+t const \&oversize) const
\begin{DoxyCompactList}\small\item\em Decided which pool bucket to target based on size. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structvt_1_1pool_1_1_pool_a4030898e09d0160c24743a7b949c0d46}{Size\+Type}} \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a0ad85d6ace3fda593f75aed336b67b8b}{remaining\+Size}} (std\+::byte $\ast$const buf) const
\begin{DoxyCompactList}\small\item\em Get remaining bytes for a pool allocation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structvt_1_1pool_1_1_pool_a4030898e09d0160c24743a7b949c0d46}{Size\+Type}} \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a63f58f48115ea54006b33fff98bb0888}{allocated\+Size}} (std\+::byte $\ast$const buf) const
\begin{DoxyCompactList}\small\item\em Get total allocated bytes for a pool allocation. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a530440f3cd5728541404fa21742db67b}{try\+Grow\+Allocation}} (std\+::byte $\ast$const buf, size\+\_\+t grow\+\_\+amount)
\begin{DoxyCompactList}\small\item\em Attempt to increase the size of an allocation without reallocating. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a3f34112821d767815d5049dc83503033}{active}} () const
\begin{DoxyCompactList}\small\item\em Whether the pool is enabled at compile-\/time. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{structvt_1_1pool_1_1_pool_aa11bdd76d9f6491ac412d5abc5c63274}{active\+\_\+env}} () const
\begin{DoxyCompactList}\small\item\em Whether the pool is enabled at compile-\/time and used as the default allocator for messages. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename SerializerT $>$ }\\void \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a7a81f11ae46f0c953c600b223bc09c70}{serialize}} (SerializerT \&s)
\end{DoxyCompactItemize}
\doxysubsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a9f94985824d12c43357cfe50eaaefd38}{Mem\+Pool\+S\+Type}} = \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a21e20f5b56c3bae4f0d0cc36ed9c5eee}{Memory\+Pool\+Ptr\+Type}}$<$ memory\+\_\+size\+\_\+small $>$
\item 
using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a8a201b9a843e47cd4e7b568a8e4483da}{Mem\+Pool\+M\+Type}} = \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a21e20f5b56c3bae4f0d0cc36ed9c5eee}{Memory\+Pool\+Ptr\+Type}}$<$ memory\+\_\+size\+\_\+medium $>$
\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
std\+::byte $\ast$ \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a631cce45e88f1cf1e23a8ac149909f8f}{try\+Pooled\+Alloc}} (size\+\_\+t const \&num\+\_\+bytes, size\+\_\+t const \&oversize)
\begin{DoxyCompactList}\small\item\em Attempt allocation via pooled allocator and fall back to standard allocation if it fails. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a9ee0259f4e26f6f51854726dd48a6f99}{try\+Pooled\+Dealloc}} (std\+::byte $\ast$const buf)
\begin{DoxyCompactList}\small\item\em Attempt to de-\/allocate a buffer. \end{DoxyCompactList}\item 
std\+::byte $\ast$ \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a666c21cfa0ccb0cdae9e2d2bb9c451d5}{pooled\+Alloc}} (size\+\_\+t const \&num\+\_\+bytes, size\+\_\+t const \&oversize, \mbox{\hyperlink{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28}{e\+Pool\+Size}} const pool\+\_\+type)
\begin{DoxyCompactList}\small\item\em Allocate memory from a specific pool. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{structvt_1_1pool_1_1_pool_ad2c9725e9fb05acffff18a4e67786960}{pool\+Dealloc}} (std\+::byte $\ast$const buf, \mbox{\hyperlink{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28}{e\+Pool\+Size}} const pool\+\_\+type)
\begin{DoxyCompactList}\small\item\em De-\/allocate memory from pool. \end{DoxyCompactList}\item 
std\+::byte $\ast$ \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a22428fa710aecd16480741c9326b21fd}{default\+Alloc}} (size\+\_\+t const \&num\+\_\+bytes, size\+\_\+t const \&oversize)
\begin{DoxyCompactList}\small\item\em Allocate from standard allocator. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a568405bb08f51b476b51f50abcda1710}{default\+Dealloc}} (std\+::byte $\ast$const ptr)
\begin{DoxyCompactList}\small\item\em De-\/allocate from standard allocator. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a9f94985824d12c43357cfe50eaaefd38}{Mem\+Pool\+S\+Type}} \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a833da3cd4d410ba607b6e7b000810882}{init\+S\+Pool}} ()
\item 
static \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a8a201b9a843e47cd4e7b568a8e4483da}{Mem\+Pool\+M\+Type}} \mbox{\hyperlink{structvt_1_1pool_1_1_pool_ab768c364b348107112f960ce0704565d}{init\+M\+Pool}} ()
\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structvt_1_1pool_1_1_pool_a9f94985824d12c43357cfe50eaaefd38}{Mem\+Pool\+S\+Type}} \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a8f14f2f9b344882cf727200eb8d41845}{small\+\_\+msg}} = nullptr
\item 
\mbox{\hyperlink{structvt_1_1pool_1_1_pool_a8a201b9a843e47cd4e7b568a8e4483da}{Mem\+Pool\+M\+Type}} \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a268cb9b30cde3272c49e67e781f0345e}{medium\+\_\+msg}} = nullptr
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
A core VT component that manages efficient pools of memory for quick allocation/deallocation. 

Highly efficient memory pool that is not thread-\/safe. Utilizes fixed-\/size buckets with free-\/list to quickly allocate and de-\/allocate. 

\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_acc5ad2d64bf6ff58fead958a69c12d74}\label{structvt_1_1pool_1_1_pool_acc5ad2d64bf6ff58fead958a69c12d74}} 
\index{vt::pool::Pool@{vt::pool::Pool}!HeaderManagerType@{HeaderManagerType}}
\index{HeaderManagerType@{HeaderManagerType}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{HeaderManagerType}{HeaderManagerType}}
{\footnotesize\ttfamily using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_acc5ad2d64bf6ff58fead958a69c12d74}{vt\+::pool\+::\+Pool\+::\+Header\+Manager\+Type}} =  \mbox{\hyperlink{structvt_1_1pool_1_1_header_manager}{Header\+Manager}}}

\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a887de970f8d8fbec63df120348c31404}\label{structvt_1_1pool_1_1_pool_a887de970f8d8fbec63df120348c31404}} 
\index{vt::pool::Pool@{vt::pool::Pool}!HeaderType@{HeaderType}}
\index{HeaderType@{HeaderType}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{HeaderType}{HeaderType}}
{\footnotesize\ttfamily using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a887de970f8d8fbec63df120348c31404}{vt\+::pool\+::\+Pool\+::\+Header\+Type}} =  \mbox{\hyperlink{structvt_1_1pool_1_1_header}{Header}}}

\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a21e20f5b56c3bae4f0d0cc36ed9c5eee}\label{structvt_1_1pool_1_1_pool_a21e20f5b56c3bae4f0d0cc36ed9c5eee}} 
\index{vt::pool::Pool@{vt::pool::Pool}!MemoryPoolPtrType@{MemoryPoolPtrType}}
\index{MemoryPoolPtrType@{MemoryPoolPtrType}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{MemoryPoolPtrType}{MemoryPoolPtrType}}
{\footnotesize\ttfamily template$<$int64\+\_\+t num\+\_\+bytes\+\_\+t$>$ \\
using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a21e20f5b56c3bae4f0d0cc36ed9c5eee}{vt\+::pool\+::\+Pool\+::\+Memory\+Pool\+Ptr\+Type}} =  std\+::unique\+\_\+ptr$<$\mbox{\hyperlink{structvt_1_1pool_1_1_pool_a06673914350d933ad5205155eca14a3b}{Memory\+Pool\+Type}}$<$num\+\_\+bytes\+\_\+t$>$ $>$}

\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a06673914350d933ad5205155eca14a3b}\label{structvt_1_1pool_1_1_pool_a06673914350d933ad5205155eca14a3b}} 
\index{vt::pool::Pool@{vt::pool::Pool}!MemoryPoolType@{MemoryPoolType}}
\index{MemoryPoolType@{MemoryPoolType}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{MemoryPoolType}{MemoryPoolType}}
{\footnotesize\ttfamily template$<$int64\+\_\+t num\+\_\+bytes\+\_\+t$>$ \\
using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a06673914350d933ad5205155eca14a3b}{vt\+::pool\+::\+Pool\+::\+Memory\+Pool\+Type}} =  \mbox{\hyperlink{structvt_1_1pool_1_1_memory_pool_equal}{Memory\+Pool\+Equal}}$<$num\+\_\+bytes\+\_\+t$>$}

\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a8a201b9a843e47cd4e7b568a8e4483da}\label{structvt_1_1pool_1_1_pool_a8a201b9a843e47cd4e7b568a8e4483da}} 
\index{vt::pool::Pool@{vt::pool::Pool}!MemPoolMType@{MemPoolMType}}
\index{MemPoolMType@{MemPoolMType}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{MemPoolMType}{MemPoolMType}}
{\footnotesize\ttfamily using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a8a201b9a843e47cd4e7b568a8e4483da}{vt\+::pool\+::\+Pool\+::\+Mem\+Pool\+M\+Type}} =  \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a21e20f5b56c3bae4f0d0cc36ed9c5eee}{Memory\+Pool\+Ptr\+Type}}$<$memory\+\_\+size\+\_\+medium$>$\hspace{0.3cm}{\ttfamily [private]}}

\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a9f94985824d12c43357cfe50eaaefd38}\label{structvt_1_1pool_1_1_pool_a9f94985824d12c43357cfe50eaaefd38}} 
\index{vt::pool::Pool@{vt::pool::Pool}!MemPoolSType@{MemPoolSType}}
\index{MemPoolSType@{MemPoolSType}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{MemPoolSType}{MemPoolSType}}
{\footnotesize\ttfamily using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a9f94985824d12c43357cfe50eaaefd38}{vt\+::pool\+::\+Pool\+::\+Mem\+Pool\+S\+Type}} =  \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a21e20f5b56c3bae4f0d0cc36ed9c5eee}{Memory\+Pool\+Ptr\+Type}}$<$memory\+\_\+size\+\_\+small$>$\hspace{0.3cm}{\ttfamily [private]}}

\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a4030898e09d0160c24743a7b949c0d46}\label{structvt_1_1pool_1_1_pool_a4030898e09d0160c24743a7b949c0d46}} 
\index{vt::pool::Pool@{vt::pool::Pool}!SizeType@{SizeType}}
\index{SizeType@{SizeType}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{SizeType}{SizeType}}
{\footnotesize\ttfamily using \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a4030898e09d0160c24743a7b949c0d46}{vt\+::pool\+::\+Pool\+::\+Size\+Type}} =  size\+\_\+t}



\doxysubsection{Member Enumeration Documentation}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28}\label{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28}} 
\index{vt::pool::Pool@{vt::pool::Pool}!ePoolSize@{ePoolSize}}
\index{ePoolSize@{ePoolSize}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{ePoolSize}{ePoolSize}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28}{vt\+::pool\+::\+Pool\+::e\+Pool\+Size}}\hspace{0.3cm}{\ttfamily [strong]}}



Different pool sizes\+: small, medium, large, and the backup malloc. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Small@{Small}!vt::pool::Pool@{vt::pool::Pool}}\index{vt::pool::Pool@{vt::pool::Pool}!Small@{Small}}}\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28a2660064e68655415da2628c2ae2f7592}\label{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28a2660064e68655415da2628c2ae2f7592}} 
Small&Small bucket \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Medium@{Medium}!vt::pool::Pool@{vt::pool::Pool}}\index{vt::pool::Pool@{vt::pool::Pool}!Medium@{Medium}}}\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28a87f8a6ab85c9ced3702b4ea641ad4bb5}\label{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28a87f8a6ab85c9ced3702b4ea641ad4bb5}} 
Medium&Medium bucket \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Large@{Large}!vt::pool::Pool@{vt::pool::Pool}}\index{vt::pool::Pool@{vt::pool::Pool}!Large@{Large}}}\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28a3a69b34ce86dacb205936a8094f6c743}\label{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28a3a69b34ce86dacb205936a8094f6c743}} 
Large&Large bucket \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Malloc@{Malloc}!vt::pool::Pool@{vt::pool::Pool}}\index{vt::pool::Pool@{vt::pool::Pool}!Malloc@{Malloc}}}\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28a1131a914388fac73e5f07b0ba0aad523}\label{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28a1131a914388fac73e5f07b0ba0aad523}} 
Malloc&Backup malloc allocation \\
\hline

\end{DoxyEnumFields}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a55a236c42c331940884370c85fb18e36}\label{structvt_1_1pool_1_1_pool_a55a236c42c331940884370c85fb18e36}} 
\index{vt::pool::Pool@{vt::pool::Pool}!Pool@{Pool}}
\index{Pool@{Pool}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{Pool()}{Pool()}}
{\footnotesize\ttfamily vt\+::pool\+::\+Pool\+::\+Pool (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



System construction of the pool component. 



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a3f34112821d767815d5049dc83503033}\label{structvt_1_1pool_1_1_pool_a3f34112821d767815d5049dc83503033}} 
\index{vt::pool::Pool@{vt::pool::Pool}!active@{active}}
\index{active@{active}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{active()}{active()}}
{\footnotesize\ttfamily bool vt\+::pool\+::\+Pool\+::active (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Whether the pool is enabled at compile-\/time. 

\begin{DoxyReturn}{Returns}
whether its enabled 
\end{DoxyReturn}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_aa11bdd76d9f6491ac412d5abc5c63274}\label{structvt_1_1pool_1_1_pool_aa11bdd76d9f6491ac412d5abc5c63274}} 
\index{vt::pool::Pool@{vt::pool::Pool}!active\_env@{active\_env}}
\index{active\_env@{active\_env}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{active\_env()}{active\_env()}}
{\footnotesize\ttfamily bool vt\+::pool\+::\+Pool\+::active\+\_\+env (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Whether the pool is enabled at compile-\/time and used as the default allocator for messages. 

\begin{DoxyReturn}{Returns}
whether its enabled 
\end{DoxyReturn}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_ab26d54516b6337e4a3b9d00a8ded8e7b}\label{structvt_1_1pool_1_1_pool_ab26d54516b6337e4a3b9d00a8ded8e7b}} 
\index{vt::pool::Pool@{vt::pool::Pool}!alloc@{alloc}}
\index{alloc@{alloc}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{alloc()}{alloc()}}
{\footnotesize\ttfamily std\+::byte $\ast$ vt\+::pool\+::\+Pool\+::alloc (\begin{DoxyParamCaption}\item[{size\+\_\+t const \&}]{num\+\_\+bytes,  }\item[{size\+\_\+t}]{oversize = {\ttfamily 0} }\end{DoxyParamCaption})}



Allocate some number of bytes plus extra size at the end. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em num\+\_\+bytes} & main payload \\
\hline
\mbox{\texttt{ in}}  & {\em oversize} & extra bytes\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to new allocation 
\end{DoxyReturn}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a63f58f48115ea54006b33fff98bb0888}\label{structvt_1_1pool_1_1_pool_a63f58f48115ea54006b33fff98bb0888}} 
\index{vt::pool::Pool@{vt::pool::Pool}!allocatedSize@{allocatedSize}}
\index{allocatedSize@{allocatedSize}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{allocatedSize()}{allocatedSize()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a4030898e09d0160c24743a7b949c0d46}{Pool\+::\+Size\+Type}} vt\+::pool\+::\+Pool\+::allocated\+Size (\begin{DoxyParamCaption}\item[{std\+::byte $\ast$const}]{buf }\end{DoxyParamCaption}) const}



Get total allocated bytes for a pool allocation. 

\textbackslash{}internal\+The result of this includes both the requested and oversize bytes.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em buf} & the buffer allocated from the pool\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the total number of allocated bytes 
\end{DoxyReturn}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a663e56d8623fa74119aede185dac5e1d}\label{structvt_1_1pool_1_1_pool_a663e56d8623fa74119aede185dac5e1d}} 
\index{vt::pool::Pool@{vt::pool::Pool}!dealloc@{dealloc}}
\index{dealloc@{dealloc}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{dealloc()}{dealloc()}}
{\footnotesize\ttfamily void vt\+::pool\+::\+Pool\+::dealloc (\begin{DoxyParamCaption}\item[{std\+::byte $\ast$const}]{buf }\end{DoxyParamCaption})}



De-\/allocate a pool-\/allocated buffer. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em buf} & the buffer to deallocate \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a22428fa710aecd16480741c9326b21fd}\label{structvt_1_1pool_1_1_pool_a22428fa710aecd16480741c9326b21fd}} 
\index{vt::pool::Pool@{vt::pool::Pool}!defaultAlloc@{defaultAlloc}}
\index{defaultAlloc@{defaultAlloc}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{defaultAlloc()}{defaultAlloc()}}
{\footnotesize\ttfamily std\+::byte $\ast$ vt\+::pool\+::\+Pool\+::default\+Alloc (\begin{DoxyParamCaption}\item[{size\+\_\+t const \&}]{num\+\_\+bytes,  }\item[{size\+\_\+t const \&}]{oversize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Allocate from standard allocator. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em num\+\_\+bytes} & main payload size \\
\hline
\mbox{\texttt{ in}}  & {\em oversize} & extra size requested\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the allocated buffer 
\end{DoxyReturn}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a568405bb08f51b476b51f50abcda1710}\label{structvt_1_1pool_1_1_pool_a568405bb08f51b476b51f50abcda1710}} 
\index{vt::pool::Pool@{vt::pool::Pool}!defaultDealloc@{defaultDealloc}}
\index{defaultDealloc@{defaultDealloc}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{defaultDealloc()}{defaultDealloc()}}
{\footnotesize\ttfamily void vt\+::pool\+::\+Pool\+::default\+Dealloc (\begin{DoxyParamCaption}\item[{std\+::byte $\ast$const}]{ptr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



De-\/allocate from standard allocator. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ptr} & buffer to deallocate \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a6b0dea52c80b6493431ce94840e7bc4a}\label{structvt_1_1pool_1_1_pool_a6b0dea52c80b6493431ce94840e7bc4a}} 
\index{vt::pool::Pool@{vt::pool::Pool}!getPoolType@{getPoolType}}
\index{getPoolType@{getPoolType}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{getPoolType()}{getPoolType()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28}{Pool\+::e\+Pool\+Size}} vt\+::pool\+::\+Pool\+::get\+Pool\+Type (\begin{DoxyParamCaption}\item[{size\+\_\+t const \&}]{num\+\_\+bytes,  }\item[{size\+\_\+t const \&}]{oversize }\end{DoxyParamCaption}) const}



Decided which pool bucket to target based on size. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em num\+\_\+bytes} & main payload \\
\hline
\mbox{\texttt{ in}}  & {\em oversize} & extra bytes\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
enum {\ttfamily e\+Pool\+Size} of which pool to target 
\end{DoxyReturn}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_ab768c364b348107112f960ce0704565d}\label{structvt_1_1pool_1_1_pool_ab768c364b348107112f960ce0704565d}} 
\index{vt::pool::Pool@{vt::pool::Pool}!initMPool@{initMPool}}
\index{initMPool@{initMPool}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{initMPool()}{initMPool()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a8a201b9a843e47cd4e7b568a8e4483da}{Pool\+::\+Mem\+Pool\+M\+Type}} vt\+::pool\+::\+Pool\+::init\+M\+Pool (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}

\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a833da3cd4d410ba607b6e7b000810882}\label{structvt_1_1pool_1_1_pool_a833da3cd4d410ba607b6e7b000810882}} 
\index{vt::pool::Pool@{vt::pool::Pool}!initSPool@{initSPool}}
\index{initSPool@{initSPool}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{initSPool()}{initSPool()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a9f94985824d12c43357cfe50eaaefd38}{Pool\+::\+Mem\+Pool\+S\+Type}} vt\+::pool\+::\+Pool\+::init\+S\+Pool (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}

\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a02fa54fc3cca0d388f25f397dfd997ab}\label{structvt_1_1pool_1_1_pool_a02fa54fc3cca0d388f25f397dfd997ab}} 
\index{vt::pool::Pool@{vt::pool::Pool}!name@{name}}
\index{name@{name}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{name()}{name()}}
{\footnotesize\ttfamily std\+::string vt\+::pool\+::\+Pool\+::name (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Get the name of the component. 



Implements \mbox{\hyperlink{structvt_1_1runtime_1_1component_1_1_component_name_a33c06229bb605a2b2ceff68830d6d773}{vt\+::runtime\+::component\+::\+Component\+Name}}.

\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_ad2c9725e9fb05acffff18a4e67786960}\label{structvt_1_1pool_1_1_pool_ad2c9725e9fb05acffff18a4e67786960}} 
\index{vt::pool::Pool@{vt::pool::Pool}!poolDealloc@{poolDealloc}}
\index{poolDealloc@{poolDealloc}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{poolDealloc()}{poolDealloc()}}
{\footnotesize\ttfamily void vt\+::pool\+::\+Pool\+::pool\+Dealloc (\begin{DoxyParamCaption}\item[{std\+::byte $\ast$const}]{buf,  }\item[{\mbox{\hyperlink{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28}{e\+Pool\+Size}} const}]{pool\+\_\+type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



De-\/allocate memory from pool. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em buf} & the buffer \\
\hline
\mbox{\texttt{ in}}  & {\em pool\+\_\+type} & which pool to target \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a666c21cfa0ccb0cdae9e2d2bb9c451d5}\label{structvt_1_1pool_1_1_pool_a666c21cfa0ccb0cdae9e2d2bb9c451d5}} 
\index{vt::pool::Pool@{vt::pool::Pool}!pooledAlloc@{pooledAlloc}}
\index{pooledAlloc@{pooledAlloc}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{pooledAlloc()}{pooledAlloc()}}
{\footnotesize\ttfamily std\+::byte $\ast$ vt\+::pool\+::\+Pool\+::pooled\+Alloc (\begin{DoxyParamCaption}\item[{size\+\_\+t const \&}]{num\+\_\+bytes,  }\item[{size\+\_\+t const \&}]{oversize,  }\item[{\mbox{\hyperlink{structvt_1_1pool_1_1_pool_ace8d36439e5e599a8ee68b2f1a6a6b28}{e\+Pool\+Size}} const}]{pool\+\_\+type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Allocate memory from a specific pool. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em num\+\_\+bytes} & main payload size \\
\hline
\mbox{\texttt{ in}}  & {\em oversize} & extra size requested \\
\hline
\mbox{\texttt{ in}}  & {\em pool\+\_\+type} & the pool to target of sufficient size\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the buffer allocated 
\end{DoxyReturn}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a0ad85d6ace3fda593f75aed336b67b8b}\label{structvt_1_1pool_1_1_pool_a0ad85d6ace3fda593f75aed336b67b8b}} 
\index{vt::pool::Pool@{vt::pool::Pool}!remainingSize@{remainingSize}}
\index{remainingSize@{remainingSize}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{remainingSize()}{remainingSize()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a4030898e09d0160c24743a7b949c0d46}{Pool\+::\+Size\+Type}} vt\+::pool\+::\+Pool\+::remaining\+Size (\begin{DoxyParamCaption}\item[{std\+::byte $\ast$const}]{buf }\end{DoxyParamCaption}) const}



Get remaining bytes for a pool allocation. 

\textbackslash{}internal\+When using the memory pool, often extra bytes are at the end of the allocation because the user did not request the whole block assigned. Some components use this extra memory to pack in extra meta-\/data (or send serialized data) when sending a message.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em buf} & the buffer allocated from the pool\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of extra bytes 
\end{DoxyReturn}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a7a81f11ae46f0c953c600b223bc09c70}\label{structvt_1_1pool_1_1_pool_a7a81f11ae46f0c953c600b223bc09c70}} 
\index{vt::pool::Pool@{vt::pool::Pool}!serialize@{serialize}}
\index{serialize@{serialize}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{serialize()}{serialize()}}
{\footnotesize\ttfamily template$<$typename SerializerT $>$ \\
void vt\+::pool\+::\+Pool\+::serialize (\begin{DoxyParamCaption}\item[{SerializerT \&}]{s }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a530440f3cd5728541404fa21742db67b}\label{structvt_1_1pool_1_1_pool_a530440f3cd5728541404fa21742db67b}} 
\index{vt::pool::Pool@{vt::pool::Pool}!tryGrowAllocation@{tryGrowAllocation}}
\index{tryGrowAllocation@{tryGrowAllocation}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{tryGrowAllocation()}{tryGrowAllocation()}}
{\footnotesize\ttfamily bool vt\+::pool\+::\+Pool\+::try\+Grow\+Allocation (\begin{DoxyParamCaption}\item[{std\+::byte $\ast$const}]{buf,  }\item[{size\+\_\+t}]{grow\+\_\+amount }\end{DoxyParamCaption})}



Attempt to increase the size of an allocation without reallocating. 

\textbackslash{}internal\+The allocation will only be grown if grow\+\_\+amount is less than or equal to the remaining size in the allocated block. If the grow\+\_\+amount is too large, this function will return false and the allocation size will not be increased. On success, the new size will be reflected in the allocated\+Size of the buffer.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em buf} & the buffer allocated from the pool that should be grown \\
\hline
\mbox{\texttt{ in}}  & {\em grow\+\_\+amount} & the amount to grow the buffer\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false if the grow\+\_\+amount is too large for the allocated block, true if the operation succeeded 
\end{DoxyReturn}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a631cce45e88f1cf1e23a8ac149909f8f}\label{structvt_1_1pool_1_1_pool_a631cce45e88f1cf1e23a8ac149909f8f}} 
\index{vt::pool::Pool@{vt::pool::Pool}!tryPooledAlloc@{tryPooledAlloc}}
\index{tryPooledAlloc@{tryPooledAlloc}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{tryPooledAlloc()}{tryPooledAlloc()}}
{\footnotesize\ttfamily std\+::byte $\ast$ vt\+::pool\+::\+Pool\+::try\+Pooled\+Alloc (\begin{DoxyParamCaption}\item[{size\+\_\+t const \&}]{num\+\_\+bytes,  }\item[{size\+\_\+t const \&}]{oversize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Attempt allocation via pooled allocator and fall back to standard allocation if it fails. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em num\+\_\+bytes} & main payload size \\
\hline
\mbox{\texttt{ in}}  & {\em oversize} & extra size requested\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to memory if succeeds 
\end{DoxyReturn}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a9ee0259f4e26f6f51854726dd48a6f99}\label{structvt_1_1pool_1_1_pool_a9ee0259f4e26f6f51854726dd48a6f99}} 
\index{vt::pool::Pool@{vt::pool::Pool}!tryPooledDealloc@{tryPooledDealloc}}
\index{tryPooledDealloc@{tryPooledDealloc}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{tryPooledDealloc()}{tryPooledDealloc()}}
{\footnotesize\ttfamily bool vt\+::pool\+::\+Pool\+::try\+Pooled\+Dealloc (\begin{DoxyParamCaption}\item[{std\+::byte $\ast$const}]{buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Attempt to de-\/allocate a buffer. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em buf} & buffer to deallocate\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether it succeeded or wasn\textquotesingle{}t allocated by the pool 
\end{DoxyReturn}


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a268cb9b30cde3272c49e67e781f0345e}\label{structvt_1_1pool_1_1_pool_a268cb9b30cde3272c49e67e781f0345e}} 
\index{vt::pool::Pool@{vt::pool::Pool}!medium\_msg@{medium\_msg}}
\index{medium\_msg@{medium\_msg}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{medium\_msg}{medium\_msg}}
{\footnotesize\ttfamily \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a8a201b9a843e47cd4e7b568a8e4483da}{Mem\+Pool\+M\+Type}} vt\+::pool\+::\+Pool\+::medium\+\_\+msg = nullptr\hspace{0.3cm}{\ttfamily [private]}}

\mbox{\Hypertarget{structvt_1_1pool_1_1_pool_a8f14f2f9b344882cf727200eb8d41845}\label{structvt_1_1pool_1_1_pool_a8f14f2f9b344882cf727200eb8d41845}} 
\index{vt::pool::Pool@{vt::pool::Pool}!small\_msg@{small\_msg}}
\index{small\_msg@{small\_msg}!vt::pool::Pool@{vt::pool::Pool}}
\doxysubsubsection{\texorpdfstring{small\_msg}{small\_msg}}
{\footnotesize\ttfamily \mbox{\hyperlink{structvt_1_1pool_1_1_pool_a9f94985824d12c43357cfe50eaaefd38}{Mem\+Pool\+S\+Type}} vt\+::pool\+::\+Pool\+::small\+\_\+msg = nullptr\hspace{0.3cm}{\ttfamily [private]}}



The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/vt/pool/\mbox{\hyperlink{pool_8h}{pool.\+h}}\item 
src/vt/pool/\mbox{\hyperlink{pool_8cc}{pool.\+cc}}\end{DoxyCompactItemize}
