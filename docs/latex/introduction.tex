Overview of functionality in {\bfseries {\itshape vt}}\hypertarget{introduction_what-is}{}\section{What is vt?}\label{introduction_what-is}
{\bfseries {\itshape vt}} is an active messaging layer that utilizes C++ object virtualization to manage virtual endpoints with automatic location management. {\bfseries {\itshape vt}} is directly built on top of M\+PI to provide efficient portability across different machine architectures. Empowered with virtualization, {\bfseries {\itshape vt}} can automatically perform dynamic load balancing to schedule scientific applications across diverse platforms with minimal user input.

{\bfseries {\itshape vt}} abstracts the concept of a {\ttfamily node}/{\ttfamily rank}/{\ttfamily worker}/{\ttfamily thread} so a program can be written in terms of virtual entities that are location independent. Thus, they can be automatically migrated and thereby executed on varying hardware resources without explicit programmer mapping, location, and communication management.\hypertarget{introduction_vt-features}{}\section{Features in vt}\label{introduction_vt-features}

\begin{DoxyItemize}
\item Active messaging to type-\/safe handlers across nodes
\item Groups for scalable construction of node subsets
\item Optional serialization of messages
\item Termination detection across all work or subsets of work with {\itshape epochs} 
\item Opaque callbacks/pipes to generalized endpoints
\item Efficient memory pooling for message allocation
\item R\+D\+MA using M\+PI one-\/sided for data transfer
\item Asynchronous Collectives across nodes/groups (scatter, async barrier, reduce, ...)
\item General scheduler with prioritization
\item Built-\/in interoperability with M\+PI and threading libraries (e.\+g. Kokkos, fcontext)
\item Object groups for node-\/level encapsulation
\item Virtual contexts for migratable virtualization and dispatch
\item Abstractions for multi-\/dimensional indices, mapping, and linearization
\item Virtual collections (dense, sparse, dynamic insertable) for decomposing domains
\item Fully distributed load balancer for virtual entities
\end{DoxyItemize}\hypertarget{introduction_vt-components}{}\section{Components in vt}\label{introduction_vt-components}
\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Component }&\textbf{ Singleton }&\textbf{ Details }&\textbf{ Type  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Component }&\textbf{ Singleton }&\textbf{ Details }&\textbf{ Type  }\\\cline{1-4}
\endhead
\hyperlink{context}{Context} &{\ttfamily \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt\+::the\+Context()}} &Node-\/aware context. & {\bfseries Core} \\\cline{1-4}
\hyperlink{active-messenger}{Active Messenger} &{\ttfamily \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt\+::the\+Msg()}} &Asynchronous send/receive of messages. & {\bfseries Core} \\\cline{1-4}
\hyperlink{collection}{Virtual Context Collection} &{\ttfamily \hyperlink{namespacevt_a1c45ce63bfd2c327ff7d76a319a371d8}{vt\+::the\+Collection()}} &Collection of tasks. & {\bfseries Core} \\\cline{1-4}
\hyperlink{collective}{Collectives} &{\ttfamily \hyperlink{namespacevt_aa8e0c0ab253e7ad1acd5d09e36fea769}{vt\+::the\+Collective()}} &Collective operations. & {\bfseries Core} \\\cline{1-4}
\hyperlink{event}{Event Manager} &{\ttfamily \hyperlink{namespacevt_aa297fcaadc8a330890eb90c5b0081ec5}{vt\+::the\+Event()}} &Manage asynchronous events. & {\bfseries Core} \\\cline{1-4}
\hyperlink{group}{Group Manager} &{\ttfamily \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt\+::the\+Group()}} &Create a grouping of nodes. & {\bfseries Core} \\\cline{1-4}
\hyperlink{lb-manager}{LB Manager} &{\ttfamily \hyperlink{namespacevt_a05187076eac8c66c9951b062b0955520}{vt\+::the\+L\+B\+Manager()}} &Manage load balancers. & {\bfseries Optional} \\\cline{1-4}
\hyperlink{location}{Location Manager} &{\ttfamily \hyperlink{namespacevt_ace1c9d64e09732e3b7414d02517ecfdb}{vt\+::the\+Loc\+Man()}} &Virtual entity location management. & {\bfseries Core} \\\cline{1-4}
\hyperlink{mem-usage}{Memory Usage Tracker} &{\ttfamily \hyperlink{namespacevt_a38d485d3cf840b9a623e47e7754ef72e}{vt\+::the\+Mem\+Usage()}} &Track memory usage. & {\bfseries Optional} \\\cline{1-4}
\hyperlink{objgroup}{Object Group Manager} &{\ttfamily \hyperlink{namespacevt_a833f0115b692f578167cbd88e30d39c5}{vt\+::the\+Obj\+Group()}} &Create object instances across nodes. & {\bfseries Core} \\\cline{1-4}
\hyperlink{pipe}{Pipe Manager} &{\ttfamily \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt\+::the\+C\+B()}} &Create opaque callback endpoints. & {\bfseries Core} \\\cline{1-4}
\hyperlink{node-lb-data}{Node LB Data} &{\ttfamily \hyperlink{namespacevt_af2ddfbdc455e98a0d46732522d8cf589}{vt\+::the\+Node\+L\+B\+Data()}} &Manager object profiling data. & {\bfseries Optional} \\\cline{1-4}
\hyperlink{phase}{Phase Manager} &{\ttfamily \hyperlink{namespacevt_a3799d6b51fb71d7b6505760aad457e61}{vt\+::the\+Phase()}} &Manage phases of time. & {\bfseries Core} \\\cline{1-4}
\hyperlink{pool}{Memory Pool} &{\ttfamily \hyperlink{namespacevt_aab3530d89a64e5ea903b0ccf303ecbb7}{vt\+::the\+Pool()}} &Memory pool for efficient allocation. & {\bfseries Core} \\\cline{1-4}
\hyperlink{rdma}{R\+D\+MA Manager} &{\ttfamily \hyperlink{namespacevt_a68b8410bc2b86d3b5228d7dbb6b40bac}{vt\+::the\+R\+D\+M\+A()}} &Node-\/level R\+D\+MA. & {\bfseries Experimental} \\\cline{1-4}
\hyperlink{rdmahandle}{R\+D\+MA Handle Manager} &{\ttfamily \hyperlink{namespacevt_aecb87ec2c40b5b7fc57ba4cf8ea838b0}{vt\+::the\+Handle\+R\+D\+M\+A()}} &R\+D\+MA handles backed by M\+PI. & {\bfseries Optional} \\\cline{1-4}
\hyperlink{registry}{Registry} &{\ttfamily vt\+::the\+Registry()} &Registered handlers. & {\bfseries Core} \\\cline{1-4}
\hyperlink{scheduler}{Scheduler} &{\ttfamily \hyperlink{namespacevt_a4508b38e6ab664b64f1415aecbb83571}{vt\+::the\+Sched()}} &General scheduling of work. & {\bfseries Core} \\\cline{1-4}
\hyperlink{term}{Termination Detector} &{\ttfamily \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt\+::the\+Term()}} &Detect termination of work. & {\bfseries Core} \\\cline{1-4}
\hyperlink{epoch}{Epoch Manager} &{\ttfamily \hyperlink{namespacevt_ad246530e523687095c567ccab203556a}{vt\+::the\+Epoch()}} &Manage TD epochs. & {\bfseries Core} \\\cline{1-4}
\hyperlink{time-trigger}{Time Triggers} &{\ttfamily \hyperlink{namespacevt_a1e1a39cdf2a3fc1adefcdfcca4716bf2}{vt\+::the\+Time\+Trigger()}} &Time-\/based progress actions. & {\bfseries Optional} \\\cline{1-4}
\hyperlink{trace}{Tracing} &{\ttfamily vt\+::the\+Trace()} &Trace distributed events. & {\bfseries Optional} \\\cline{1-4}
\hyperlink{lb-data-reader}{LB Restart Reader} &{\ttfamily \hyperlink{namespacevt_a6dc000b04e41df77184588b50280b312}{vt\+::the\+L\+B\+Data\+Reader()}} &Follow input LB distribution. & {\bfseries Optional} \\\cline{1-4}
\end{longtabu}
\hypertarget{introduction_how-to-build-intro}{}\section{How to build}\label{introduction_how-to-build-intro}
{\bfseries {\itshape vt}} can be built with cmake or inside a docker container. Learn \hyperlink{vt-build}{How to Build}\hypertarget{introduction_vt-hello-world}{}\section{Hello World Example}\label{introduction_vt-hello-world}
  
\begin{DoxyCode}
\textcolor{keywordtype}{bool} done = \textcolor{keyword}{false};

\textcolor{keyword}{struct }HelloMsg : \hyperlink{structvt_1_1messaging_1_1_active_msg}{vt::Message} \{
  HelloMsg(\hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} in\_from) : from(in\_from) \{ \}
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} from = 0;
\};

\textcolor{keywordtype}{void} hello\_world(HelloMsg* msg) \{
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  fmt::print(\textcolor{stringliteral}{"\{\}: Hello from node \{\}\(\backslash\)n"}, this\_node, msg->from);
  done = \textcolor{keyword}{true};
\}

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_a580ef23e9a224fc0907da1a6db308b5b}{vt::initialize}(argc, arv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    \textcolor{keyword}{auto} msg = vt::makeMessage<HelloMsg>(this\_node);
    \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__typesafehan_ga1a347aac6b6b8d47c9b1c8cc11b7f33e}{broadcastMsg}<HelloMsg, hello\_world>(msg);
    done = \textcolor{keyword}{true};
  \}

  \textcolor{comment}{// Run the scheduler until all nodes are done}
  vt::runSchedulerWhile([]\{ \textcolor{keywordflow}{return} !done; \});

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();
  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


Running\+:


\begin{DoxyCode}
$ mpirun -n 4 ./hello\_world
\end{DoxyCode}


Output\+: 
\begin{DoxyCode}
3: Hello from node 0
1: Hello from node 0
2: Hello from node 0
\end{DoxyCode}


\begin{DoxyNote}{Note}
An active message broadcast sends to all nodes except for the sender (root of the broadcast). 
\end{DoxyNote}
\hypertarget{introduction_License}{}\section{License}\label{introduction_License}


Copyright 2019-\/2021 National Technology \& Engineering Solutions of Sandia, L\+LC (N\+T\+E\+SS). Under the terms of Contract D\+E-\/\+N\+A0003525 with N\+T\+E\+SS, the U.\+S. Government retains certain rights in this software.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met\+:


\begin{DoxyItemize}
\item Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
\item Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
\item Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
\end{DoxyItemize}

T\+H\+IS S\+O\+F\+T\+W\+A\+RE IS P\+R\+O\+V\+I\+D\+ED BY T\+HE C\+O\+P\+Y\+R\+I\+G\+HT H\+O\+L\+D\+E\+RS A\+ND C\+O\+N\+T\+R\+I\+B\+U\+T\+O\+RS \char`\"{}\+A\+S I\+S\char`\"{} A\+ND A\+NY E\+X\+P\+R\+E\+SS OR I\+M\+P\+L\+I\+ED W\+A\+R\+R\+A\+N\+T\+I\+ES, I\+N\+C\+L\+U\+D\+I\+NG, B\+UT N\+OT L\+I\+M\+I\+T\+ED TO, T\+HE I\+M\+P\+L\+I\+ED W\+A\+R\+R\+A\+N\+T\+I\+ES OF M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY A\+ND F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE A\+RE D\+I\+S\+C\+L\+A\+I\+M\+ED. IN NO E\+V\+E\+NT S\+H\+A\+LL T\+HE C\+O\+P\+Y\+R\+I\+G\+HT O\+W\+N\+ER OR C\+O\+N\+T\+R\+I\+B\+U\+T\+O\+RS BE L\+I\+A\+B\+LE F\+OR A\+NY D\+I\+R\+E\+CT, I\+N\+D\+I\+R\+E\+CT, I\+N\+C\+I\+D\+E\+N\+T\+AL, S\+P\+E\+C\+I\+AL, E\+X\+E\+M\+P\+L\+A\+RY, OR C\+O\+N\+S\+E\+Q\+U\+E\+N\+T\+I\+AL D\+A\+M\+A\+G\+ES (I\+N\+C\+L\+U\+D\+I\+NG, B\+UT N\+OT L\+I\+M\+I\+T\+ED TO, P\+R\+O\+C\+U\+R\+E\+M\+E\+NT OF S\+U\+B\+S\+T\+I\+T\+U\+TE G\+O\+O\+DS OR S\+E\+R\+V\+I\+C\+ES; L\+O\+SS OF U\+SE, D\+A\+TA, OR P\+R\+O\+F\+I\+TS; OR B\+U\+S\+I\+N\+E\+SS I\+N\+T\+E\+R\+R\+U\+P\+T\+I\+ON) H\+O\+W\+E\+V\+ER C\+A\+U\+S\+ED A\+ND ON A\+NY T\+H\+E\+O\+RY OF L\+I\+A\+B\+I\+L\+I\+TY, W\+H\+E\+T\+H\+ER IN C\+O\+N\+T\+R\+A\+CT, S\+T\+R\+I\+CT L\+I\+A\+B\+I\+L\+I\+TY, OR T\+O\+RT (I\+N\+C\+L\+U\+D\+I\+NG N\+E\+G\+L\+I\+G\+E\+N\+CE OR O\+T\+H\+E\+R\+W\+I\+SE) A\+R\+I\+S\+I\+NG IN A\+NY W\+AY O\+UT OF T\+HE U\+SE OF T\+H\+IS S\+O\+F\+T\+W\+A\+RE, E\+V\+EN IF A\+D\+V\+I\+S\+ED OF T\+HE P\+O\+S\+S\+I\+B\+I\+L\+I\+TY OF S\+U\+CH D\+A\+M\+A\+GE. \hypertarget{context}{}\section{Context}\label{context}
Node-\/aware context

The context component {\ttfamily \hyperlink{structvt_1_1ctx_1_1_context}{vt\+::ctx\+::\+Context}}, accessed via {\ttfamily \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt\+::the\+Context()}}, provides context-\/aware querying of the current node (analogous to M\+PI\textquotesingle{}s {\ttfamily M\+P\+I\+\_\+\+Comm\+\_\+rank}), number of nodes (analogous to M\+PI\textquotesingle{}s {\ttfamily M\+P\+I\+\_\+\+Comm\+\_\+size}), and kernel threading/\+U\+LT information if worker threads are enabled. The context also provides the M\+PI communicator that an instance of {\bfseries {\itshape vt}} is currently using.

Used to obtain the current node and other context where a handler executes. Context is a core VT component that provides the ability to pass initialization arguments (through the {\ttfamily vt\+::\+Runtime}) and obtain info about the node on which a handler is executing or the number of nodes. It provides functionality analogous to {\ttfamily M\+P\+I\+\_\+\+Comm\+\_\+size} and {\ttfamily M\+P\+I\+\_\+\+Comm\+\_\+rank}.

Gets the current node (analogous to M\+PI\textquotesingle{}s rank) currently being used.

To get the current node, one may query this method\+:


\begin{DoxyCode}
\hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
\end{DoxyCode}


Get the number of nodes (analogous to M\+PI\textquotesingle{}s num ranks) being used.

To get the number of nodes or ranks that an instance of {\bfseries {\itshape vt}} is using, one may query this method\+:


\begin{DoxyCode}
\hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();
\end{DoxyCode}


\begin{DoxyNote}{Note}
The result from {\ttfamily get\+Node} or {\ttfamily get\+Num\+Nodes} will depend on the communicator that was passed to VT during initialization. 
\end{DoxyNote}
\hypertarget{active-messenger}{}\section{Active Messenger}\label{active-messenger}
Asynchronous send/receive of messages

The active messenger {\ttfamily \hyperlink{structvt_1_1messaging_1_1_active_messenger}{vt\+::messaging\+::\+Active\+Messenger}}, accessed via {\ttfamily \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt\+::the\+Msg()}}, asynchronously sends and receives messages across nodes using M\+PI internally. When sending a message, it uses the {\bfseries {\itshape vt}} registry to consistently dispatch messages and data to handlers (function pointers, functors, or methods) across nodes.

Each message contains an envelope {\ttfamily \hyperlink{namespacevt_aa9c8cc094b5361482021d63012987814}{vt\+::\+Envelope}} to store meta-\/data associated with the message, such as the destination and handler to trigger when it arrives. Sending a message entails setting up the envelope, optionally serializing the message (depending on whether the serialize overload is present), and then using {\ttfamily M\+P\+I\+\_\+\+Isend} to asynchronously transfer the bytes to the destination node. On the receive side, the active messenger is always probing for an incoming message and begins a transfer when it discovers one. The {\bfseries {\itshape vt}} \hyperlink{scheduler}{Scheduler} polls the active messenger to make progress on any incoming messages.\hypertarget{active-messenger_am-simple-example}{}\subsection{Sending a message}\label{active-messenger_am-simple-example}

\begin{DoxyCode}
\textcolor{preprocessor}{#include <\hyperlink{transport_8h}{vt/transport.h}>}

\textcolor{preprocessor}{#include <vector>}

\textcolor{comment}{// Declare a serializable message}
\textcolor{keyword}{struct }MyMsg : \hyperlink{structvt_1_1messaging_1_1_active_msg}{vt::Message} \{
  \textcolor{keyword}{using} MessageParentType = \hyperlink{namespacevt_a3a3ddfef40b4c90915fa43cdd5f129ea}{vt::Message};
  \hyperlink{message__serialize_8h_a54128d5338aaa9c918179826085e13d1}{vt\_msg\_serialize\_required}(); \textcolor{comment}{// for vector}

  MyMsg() = \textcolor{keywordflow}{default}; \textcolor{comment}{// default constructor for de-serialize}
  MyMsg(\textcolor{keywordtype}{int} in\_val, std::vector<double> \textcolor{keyword}{const}& in\_vec)
    : val(in\_val),
      my\_vec(in\_vec)
  \{ \}

  \textcolor{keyword}{template} <\textcolor{keyword}{typename} SerializerT>
  \textcolor{keywordtype}{void} \hyperlink{structvt_1_1messaging_1_1_active_msg_a758f02bef5991c48d6c9a56c30ca7ad9}{serialize}(SerializerT& s) \{
    \hyperlink{namespacecheckpoint_a075da4e7344cf037943362517e606c3a}{MessageParentType::serialize}(s);
    s | val;
    s | my\_vec;
  \}

  \textcolor{keywordtype}{int} val = 0;
  std::vector<double> my\_vec;
\};

\textcolor{comment}{// Active function pointer}
\textcolor{keywordtype}{void} myHandler(MyMsg* m) \{
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  fmt::print(\textcolor{stringliteral}{"\{\}: val=\{\}, vec size=\{\}\(\backslash\)n"}, this\_node, m->val, m->my\_vec.size());
\}

\textcolor{comment}{// Active functor}
\textcolor{keyword}{struct }MyFunctor \{
  \textcolor{keywordtype}{void} operator()(MyMsg* m) \{
    \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
    fmt::print(\textcolor{stringliteral}{"\{\}: val=\{\}, vec size=\{\}\(\backslash\)n"}, this\_node, m->val, m->my\_vec.size());
  \}
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_a580ef23e9a224fc0907da1a6db308b5b}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    \textcolor{comment}{// spins in scheduler until termination of the enclosed work}
    \hyperlink{namespacevt_a9f5cbbc484d7f14f2ad0ee46d62dfb6e}{vt::runInEpochRooted}([=]\{
      std::vector<double> vec\_to\_send;
      vec\_to\_send.push\_back(29.);
      vec\_to\_send.push\_back(54.);

      \textcolor{keyword}{auto} msg = vt::makeMessage<MyMsg>(10, vec\_to\_send);
      \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_ga0162a39473e7f9b490a79a7983d949ac}{sendMsg}<MyMsg, myHandler>(1, msg); \textcolor{comment}{// send to node 1}

      \textcolor{keyword}{auto} msg2 = vt::makeMessage<MyMsg>(11, vec\_to\_send);
      \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_ga0162a39473e7f9b490a79a7983d949ac}{sendMsg}<MyFunctor>(1, msg2);  \textcolor{comment}{// send to node 1}
    \});
  \}

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();
  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


Program output\+:


\begin{DoxyCode}
1: val=10, vec size=2
1: val=11, vec size=2
\end{DoxyCode}
 \hypertarget{collection}{}\section{Virtual Context Collection}\label{collection}
Collection of tasks

The virtual context collection component {\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_manager}{vt\+::vrt\+::collection\+::\+Collection\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a1c45ce63bfd2c327ff7d76a319a371d8}{vt\+::the\+Collection()}} is a core VT component that manages multi-\/dimensional collections of {\itshape virtual context} (or a migratable C++ object registered with {\bfseries {\itshape vt}}) elements. It manages the creation, deletion, and messaging across elements at runtime supporting dense, sparse, on-\/demand, and staged insert modes. It utilizes the \hyperlink{location}{Location Manager} to manage the location of these elements to efficiently deliver messages. It also utilizes the \hyperlink{group}{Group Manager} to build a spanning tree across the nodes that the collection is currently mapped to. This group makes broadcasts efficient and allows reductions to make progress without waiting for nodes that do not have collection elements.

The \hyperlink{node-lb-data}{Node LB Data} component stores the LB data for live collections that then passes the instrumented data to the \hyperlink{lb-manager}{LB Manager} component to apply load balancing strategies. You can use {\ttfamily -\/-\/vt\+\_\+lb\+\_\+keep\+\_\+last\+\_\+elm} flag to prohibit load balancer from migrating last element in collection.

The preferred interface for constructing a new collection is {\ttfamily \hyperlink{namespacevt_a19a89f0706559e09bbe84eec1ff9f1e7}{vt\+::make\+Collection}$<$T$>$()}. Using a fluent-\/style interface, {\ttfamily make\+Collection} returns a configuration object to set properties of the collection before actually constructing the collection. Once it is configured, the {\ttfamily .wait()} or {\ttfamily .defer\+With\+Epoch(callback)} methods allows one to either block until the collection is created or wait on the returned epoch until construction finishes (respectively). The {\ttfamily wait()} variant returns the proxy for use immediately (after blocking), whereas {\ttfamily defer\+With\+Epoch(callback)} supplies the proxy when the epoch terminates by triggering the callback passed to it.

The function {\ttfamily \hyperlink{namespacevt_a19a89f0706559e09bbe84eec1ff9f1e7}{vt\+::make\+Collection}$<$T$>$()} will create a collection in a collective fashion, meaning it must be called in tandem on all nodes. Alternatively, one may call {\ttfamily \hyperlink{namespacevt_acbbf58b2c85959c964a7ae8c536fe9bc}{vt\+::make\+Collection\+Rooted}$<$T$>$()} to construct a rooted collection, which is invoked only on a single rank. (and the proxy is returned to a single rank). After waiting for construction, elements will have been constructed on their appropriate ranks, and the provided collection proxy will be usable on any rank it\textquotesingle{}s sent to.

For collections without dynamic membership at runtime, one must call {\ttfamily .bounds(my\+\_\+range)} to specify the bounds in each dimension for the collection or specify exactly one bulk insertion range ({\ttfamily .bulk\+Insert(my\+\_\+range\+\_\+1)}), where {\ttfamily my\+\_\+range\+\_\+1} will be the assumed bounds for the collection. Bulk insertion is one such way to specify how insertions should happen during construction. The {\ttfamily .bulk\+Insert()} method (with no parameter) tells the runtime to insert all collection elements within the bounds using the mapping function to determine placement. The user can also specify specific ranges to bulk insert using {\ttfamily .bulk\+Insert(my\+\_\+range\+\_\+1)} with a parameter (this can be called multiple times).

For collective collection constructions, one may also use list insertion ({\ttfamily .list\+Insert(my\+\_\+index\+\_\+list)}) to specify non-\/contiguous lists of indices that the runtime should insert at construction time. Finally, for collective constructions, one may call {\ttfamily .list\+Insert\+Here(my\+\_\+index\+\_\+list)} to specifically instruct the runtime to construct a list of collection elements on the particular rank where it is invoked. This overrides the mapping function that the user supplies.

By default, a mapping function is applied to every collection. If the collection has bounds, the system will choose a default blocked mapping (across all dimensions) for initial placement. For collections without bounds (ones with dynamic membership), the system uses a simple xor hash function to generate a valid initial location for each index deterministically. One may specify a mapping function in two ways\+: the user can provide a stateless function as a template argument to {\ttfamily .mapper\+Func$<$my\+\_\+map$>$()}, where {\ttfamily my\+\_\+map} has the following definition (shown for a 1-\/dimensional collection)\+:


\begin{DoxyCode}
\hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} my\_map(\hyperlink{structvt_1_1index_1_1_dense_index_array}{vt::Index1D}* idx, \hyperlink{structvt_1_1index_1_1_dense_index_array}{vt::Index1D}* bounds, 
      \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes) \{
  \textcolor{keywordflow}{return} idx->\hyperlink{structvt_1_1index_1_1_dense_index_array_a0604b24914af854d09d4da97eae4ef74}{x}() % num\_nodes;
\}
\end{DoxyCode}


Or, alternatively, one may specify a object group mapper, which contains an instance across all ranks that may communicate to determine placement. The {\ttfamily .mapper\+Obj\+Group(proxy)} method configures the mapping object with an object group instance that already exists by passing the proxy to it. Otherwise, one may just give the type and constructor arguments to create a new instance\+: {\ttfamily .mapper\+Obj\+Group\+Construct$<$My\+Object\+Group$>$(args...)}. An object group mapper must inherit from {\ttfamily \hyperlink{structvt_1_1mapping_1_1_base_mapper}{vt\+::mapping\+::\+Base\+Mapper}} and implement the pure virtual method {\ttfamily Node\+Type map(\+Idx\+T$\ast$ idx, int ndim, Node\+Type num\+\_\+nodes)} to define the mapping for the runtime. As an example, the object group mapper used by default for unbounded collections is implemented as follows\+:


\begin{DoxyCode}
\textcolor{keyword}{template} <\textcolor{keyword}{typename} IdxT>
\textcolor{keyword}{struct }UnboundedDefaultMap : \hyperlink{structvt_1_1mapping_1_1_base_mapper}{vt::mapping::BaseMapper}<IdxT> \{
  \textcolor{keyword}{static} \hyperlink{namespacevt_ad7cae989df485fccca57f0792a880a8e}{ObjGroupProxyType} construct() \{
    \textcolor{keyword}{auto} proxy = \hyperlink{namespacevt_a833f0115b692f578167cbd88e30d39c5}{theObjGroup}()->\hyperlink{structvt_1_1objgroup_1_1_obj_group_manager_a50e0d8498d142a05773ed5a046803b2b}{makeCollective}<UnboundedDefaultMap<IdxT>>();
    \textcolor{keywordflow}{return} proxy.\hyperlink{structvt_1_1objgroup_1_1proxy_1_1_proxy_a76cda2351cf7801abe2ebffa1403c5b8}{getProxy}();
  \}

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{NodeType} \hyperlink{structvt_1_1mapping_1_1_base_mapper_a940a3ea301c0f60b2b88218afbce5a4f}{map}(IdxT* idx, \textcolor{keywordtype}{int} ndim, \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{NodeType} num\_nodes)\textcolor{keyword}{ override }\{
    \textcolor{keyword}{typename} IdxT::DenseIndexType val = 0;
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < ndim; i++) \{
      val ^= idx->get(i);
    \}
    \textcolor{keywordflow}{return} val % num\_nodes;
  \}
\};
\end{DoxyCode}


Note that all collection mapping functions or object groups must be deterministic across all nodes for the same inputs.

By default, the collection type {\ttfamily T} (that inherits from the runtime base type {\ttfamily \hyperlink{namespacevt_ac72e048964e4bb536faaa8bc90f58db7}{vt\+::\+Collection}$<$T, Index\+Type$>$}) must have a default constructor. However, this can be avoided by configuring the collection with a specialized element constructor using {\ttfamily .element\+Constructor(x)}, where {\ttfamily x}\textquotesingle{}s type is {\ttfamily std\+::function$<$std\+::unique\+\_\+ptr$<$ColT$>$(IndexT idx)$>$} and {\ttfamily ColT} is the collection type and {\ttfamily IndexT} is the index type for the collection. This configuration is only valid for collective constructions because the element constructor function can not be safely sent over the network. If this is provided, the collection manager will not try to default construct the collection elements, instead calling the user-\/provided constructor passed to this function.

By default, all collection elements are migratable and can be moved by the load balancer when it is invoked by the user. However, one may inform VT that collection is entirely non-\/migratable by setting the parameter {\ttfamily .migratable(false)} during construction. By doing this, work executed by its elements will be recorded as background load on the initially mapped rank and excluded from the load balancer migration decisions.

By default, collections do not have dynamic membership\+: they might be dense or sparse within the specified bounds, but the set of collection elements that are created at construction time persists (and never grows or shrinks) until the collection is completely destroyed. Dynamic membership allows the user to specify insertions and deletions as the program executes in a safe and orderly manner. To enable this, one must call {\ttfamily .dynamic\+Membership(true)}. Note that the previous requirement of specifying collection bounds becomes optional with dynamic membership.

Once a collection is constructed with dynamic membership, one must start a collective modification epoch to make changes to the collection\textquotesingle{}s membership. This is performed in the following way (note that this is a collective interface)\+:


\begin{DoxyCode}
\textcolor{keyword}{auto} proxy = vt::makeCollection<MyCollection>(\textcolor{stringliteral}{"collection\_label"})
  .dynamicMembership(\textcolor{keyword}{true})
  .collective(\textcolor{keyword}{true})
  .wait();

\textcolor{keyword}{auto} range = \hyperlink{namespacevt_a5540efc78234273e1796fb003fe4d234}{vt::Index1D}(num\_elms);
\textcolor{keyword}{auto} token = proxy.beginModification();
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < range.x() / 2; i++) \{
  \textcolor{keywordflow}{if} (i % num\_nodes == this\_node) \{
    proxy[i].insertAt(token, i % 2);
  \}
\}
proxy.finishModification(std::move(token));
\end{DoxyCode}


The calls to {\ttfamily proxy.\+begin\+Modification()} start the insertion/deletion epoch by returning a token that must be passed to the actual modification calls. To insert a new collection element, the interface provides several methods on the indexed proxy\+: {\ttfamily insert}, {\ttfamily insert\+At}, {\ttfamily insert\+Msg} or {\ttfamily insert\+At\+Msg}. The {\ttfamily insert} method performs the insertion at the location specified by the mapping function/mapping object group that is provided when the collection is constructed. The {\ttfamily insert\+At} or {\ttfamily insert\+At\+Msg} allow the user to specify exactly where the new element should reside overriding the default mapping for the element. The {\ttfamily insert\+Msg} or {\ttfamily insert\+At\+Msg} calls allow the user to pass a message to the collection element which invokes a non-\/default constructor that has the user-\/specified message as an argument.

Finally, one may call {\ttfamily destroy} on the indexed proxy to delete an element. All these modifications take place after {\ttfamily finish\+Modification} is invoked---a blocking call that enacts the changes across the system. Once {\ttfamily finish\+Modification} returns, the runtime guarantees that all changes have taken place across the system and all spanning trees are reconstructed or modified based on the changes made.

If a reduction is ongoing while insertions or deletions happen, the new elements are still expected to contribute. That is, new collection elements are part of the next sequenced reduction that has not causally terminated across the distributed system. For code readability, we generally recommend that the user wait on termination of any reductions before membership modifications are made.\hypertarget{collection_rooted-hello-world-collection}{}\subsection{Hello World 1\+D Dense Collection (\+Rooted)}\label{collection_rooted-hello-world-collection}

\begin{DoxyCodeInclude}
\textcolor{keyword}{struct }Hello : \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection}{vt::Collection}<Hello, vt::Index1D> \{
  Hello() = \textcolor{keywordflow}{default};

  \textcolor{keyword}{virtual} ~Hello() \{
    \hyperlink{config__assert_8h_aeddd4990a496e91a0ca5d6c16437359b}{vtAssert}(counter\_ == 1, \textcolor{stringliteral}{"Must be equal"});
  \}

  \textcolor{keywordtype}{void} doWork(\textcolor{keywordtype}{int} val) \{
    fmt::print(\textcolor{stringliteral}{"Hello from \{\}: val=\{\}\(\backslash\)n"}, this->\hyperlink{structvt_1_1vrt_1_1collection_1_1_indexable_a28d05f23e7a20e12e94b8235305c1e82}{getIndex}(), val);
    counter\_++;
  \}

\textcolor{keyword}{private}:
  int32\_t counter\_ = 0;
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_a580ef23e9a224fc0907da1a6db308b5b}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();

  \textcolor{keywordtype}{int} num\_elms = 64;

  \textcolor{keywordflow}{if} (argc > 1) \{
    num\_elms = atoi(argv[1]);
  \}

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    \textcolor{keyword}{auto} range = \hyperlink{namespacevt_a5540efc78234273e1796fb003fe4d234}{vt::Index1D}(num\_elms);
    \textcolor{keyword}{auto} proxy = vt::makeCollectionRooted<Hello>(\textcolor{stringliteral}{"examples\_hello\_world\_collection"})
      .bounds(range)
      .bulkInsert()
      .wait();
    proxy.\hyperlink{structvt_1_1objgroup_1_1proxy_1_1_proxy_a0b716ca776b1f06e0d7d45afbe9e5274}{broadcast}<&Hello::doWork>(10);
  \}

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
 \hypertarget{collection_collective-hello-world-collection}{}\subsection{Hello World 1\+D Dense Collection (\+Collective)}\label{collection_collective-hello-world-collection}

\begin{DoxyCodeInclude}
\textcolor{keyword}{struct }Hello : \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection}{vt::Collection}<Hello, vt::Index1D> \{
  Hello() = \textcolor{keywordflow}{default};

  \textcolor{keyword}{virtual} ~Hello() \{
    \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();
    \hyperlink{config__assert_8h_aeddd4990a496e91a0ca5d6c16437359b}{vtAssert}(counter\_ == num\_nodes, \textcolor{stringliteral}{"Should receive # nodes broadcasts"});
  \}

  \textcolor{keywordtype}{void} doWork(\textcolor{keywordtype}{int} val) \{
    counter\_++;
    fmt::print(
      \textcolor{stringliteral}{"Hello from \{\}, val=\{\}, counter\_=\{\}\(\backslash\)n"}, \hyperlink{structvt_1_1vrt_1_1collection_1_1_indexable_a28d05f23e7a20e12e94b8235305c1e82}{getIndex}(), val, counter\_
    );
  \}

\textcolor{keyword}{private}:
  \textcolor{keywordtype}{int} counter\_ = 0;
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_a580ef23e9a224fc0907da1a6db308b5b}{vt::initialize}(argc, argv);

  int32\_t num\_elms = 16;
  \textcolor{keywordflow}{if} (argc > 1) \{
    num\_elms = atoi(argv[1]);
  \}

  \textcolor{keyword}{auto} range = \hyperlink{namespacevt_a5540efc78234273e1796fb003fe4d234}{vt::Index1D}(num\_elms);
  \textcolor{keyword}{auto} proxy = vt::makeCollection<Hello>(\textcolor{stringliteral}{"examples\_hello\_world\_collection\_collective"})
    .bounds(range)
    .bulkInsert()
    .wait();

  \textcolor{comment}{// All nodes send a broadcast to all elements}
  proxy.\hyperlink{structvt_1_1objgroup_1_1proxy_1_1_proxy_a0b716ca776b1f06e0d7d45afbe9e5274}{broadcast}<&Hello::doWork>(29);

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
 \hypertarget{collection_reduce-hello-world-collection}{}\subsection{Hello World 1\+D Collection Reduce}\label{collection_reduce-hello-world-collection}

\begin{DoxyCodeInclude}
\textcolor{keyword}{struct }Hello : \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection}{vt::Collection}<Hello, vt::Index1D> \{
  \textcolor{keywordtype}{void} done(\textcolor{keywordtype}{int} val, \textcolor{keywordtype}{double} val2) \{
    fmt::print(\textcolor{stringliteral}{"Reduce complete at \{\} values \{\} \{\}\(\backslash\)n"}, \hyperlink{structvt_1_1vrt_1_1collection_1_1_indexable_a28d05f23e7a20e12e94b8235305c1e82}{getIndex}(), val, val2);
  \}

  \textcolor{keywordtype}{void} doWork() \{
    fmt::print(\textcolor{stringliteral}{"Hello from \{\}\(\backslash\)n"}, \hyperlink{structvt_1_1vrt_1_1collection_1_1_indexable_a28d05f23e7a20e12e94b8235305c1e82}{getIndex}());

    \textcolor{comment}{// Get the proxy for the collection}
    \textcolor{keyword}{auto} proxy = \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_base_ad97d9ab1a28fb535c5d7f82c15e99791}{getCollectionProxy}();

    \textcolor{keyword}{auto} val = \hyperlink{structvt_1_1vrt_1_1collection_1_1_indexable_a28d05f23e7a20e12e94b8235305c1e82}{getIndex}().x();
    \textcolor{keyword}{auto} val2 = 2.4;
    proxy.\hyperlink{structvt_1_1objgroup_1_1proxy_1_1_proxy_ab8d4b9337c19d4ff0e758d03f3941b98}{allreduce}<&Hello::done, vt::collective::PlusOp>(val, val2);
  \}
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_a580ef23e9a224fc0907da1a6db308b5b}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();

  int32\_t num\_elms = 16;
  \textcolor{keywordflow}{if} (argc > 1) \{
    num\_elms = atoi(argv[1]);
  \}

  \textcolor{keyword}{auto} range = \hyperlink{namespacevt_a5540efc78234273e1796fb003fe4d234}{vt::Index1D}(num\_elms);
  \textcolor{keyword}{auto} proxy = vt::makeCollection<Hello>(\textcolor{stringliteral}{"hello\_world\_collection\_reduce"})
    .bounds(range)
    .bulkInsert()
    .wait();

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    proxy.\hyperlink{structvt_1_1objgroup_1_1proxy_1_1_proxy_a0b716ca776b1f06e0d7d45afbe9e5274}{broadcast}<&Hello::doWork>();
  \}

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
 \hypertarget{collection_staged-insert-hello-world-collection}{}\subsection{Hello World 1\+D Collection Staged Insert}\label{collection_staged-insert-hello-world-collection}

\begin{DoxyCodeInclude}
\textcolor{keyword}{struct }Hello : \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection}{vt::Collection}<Hello, vt::Index1D> \{

  \textcolor{comment}{// Default constructor for migration}
  Hello() = \textcolor{keywordflow}{default};

  \textcolor{comment}{// Constructor used during insertion}
  \textcolor{keyword}{explicit} Hello(std::string \textcolor{keyword}{const}& input\_string)
    : in(input\_string)
  \{ \}

  \textcolor{keyword}{virtual} ~Hello() \{
    \hyperlink{config__assert_8h_aeddd4990a496e91a0ca5d6c16437359b}{vtAssert}(counter\_ == 1, \textcolor{stringliteral}{"Must be equal"});
  \}

  \textcolor{keywordtype}{void} doWork() \{
    counter\_++;

    \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
    fmt::print(\textcolor{stringliteral}{"\{\}: Hello from \{\}: \{\}\(\backslash\)n"}, this\_node, this->\hyperlink{structvt_1_1vrt_1_1collection_1_1_indexable_a28d05f23e7a20e12e94b8235305c1e82}{getIndex}(), in);
  \}

\textcolor{keyword}{private}:
  \textcolor{keywordtype}{int} counter\_ = 0;
  std::string in;
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_a580ef23e9a224fc0907da1a6db308b5b}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keywordflow}{if}(num\_nodes < 2)\{
    \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();
    \textcolor{keywordflow}{return} 0;
  \}

  \textcolor{keywordtype}{int} num\_elms = 32;
  \textcolor{keywordflow}{if} (argc > 1) \{
    num\_elms = atoi(argv[1]);
  \}

  \textcolor{keyword}{auto} range = \hyperlink{namespacevt_a5540efc78234273e1796fb003fe4d234}{vt::Index1D}(num\_elms);

  std::vector<std::tuple<vt::Index1D, std::unique\_ptr<Hello>>> elms;
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_elms; i++) \{
    \textcolor{comment}{// Insert even elements, round-robin the insertions from each node}
    \textcolor{keywordflow}{if} ((i / 2) % num\_nodes == this\_node and i % 2 == 0) \{
      \textcolor{keyword}{auto} str = fmt::format(\textcolor{stringliteral}{"inserted from \{\}"}, this\_node);
      elms.emplace\_back(
        std::make\_tuple(\hyperlink{structvt_1_1index_1_1_dense_index_array}{vt::Index1D}\{i\}, std::make\_unique<Hello>(str))
      );
    \}
  \}

  \textcolor{keyword}{auto} proxy = vt::makeCollection<Hello>(\textcolor{stringliteral}{"examples\_hello\_world\_collection\_staged\_insert"})
    .bounds(range)
    .listInsertHere(std::move(elms))
    .wait();

  \textcolor{keywordflow}{if} (this\_node == 1) \{
    proxy.\hyperlink{structvt_1_1objgroup_1_1proxy_1_1_proxy_a0b716ca776b1f06e0d7d45afbe9e5274}{broadcast}<&Hello::doWork>();
  \}

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
\hypertarget{collective}{}\section{Collectives}\label{collective}
Collective operations

The collective component {\ttfamily \hyperlink{structvt_1_1collective_1_1_collective_alg}{vt\+::collective\+::\+Collective\+Alg}}, accessed via {\ttfamily \hyperlink{namespacevt_aa8e0c0ab253e7ad1acd5d09e36fea769}{vt\+::the\+Collective()}} implements active-\/message-\/based distributed collectives over the {\bfseries {\itshape vt}} runtime. It performs asynchronous reductions, scatters, barriers, and allows one to safely use M\+PI interspersed through {\bfseries {\itshape vt}} code, while running in a handler.\hypertarget{collective_collective-reductions}{}\subsection{Reductions}\label{collective_collective-reductions}
{\bfseries {\itshape vt}} comes with several reduction operators built in that can operate over types where the operator already applies (like integers, doubles, etc.) or user-\/defined overloaded operators. These operators also have specializations for {\ttfamily std\+::vector$<$T$>$} and {\ttfamily std\+::array$<$T$>$}.

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Operator }&\textbf{ Reference  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Operator }&\textbf{ Reference  }\\\cline{1-2}
\endhead
operator\&\& &{\ttfamily \hyperlink{namespacevt_1_1collective_ae6f54eb36ce2d4203174e55167c4cd87}{vt\+::collective\+::\+And\+Op}} \\\cline{1-2}
operator$|$$|$ &{\ttfamily \hyperlink{namespacevt_1_1collective_a47e3b11aa019f643f23effceb60ee94a}{vt\+::collective\+::\+Or\+Op}} \\\cline{1-2}
operator+ &{\ttfamily \hyperlink{namespacevt_1_1collective_a7a695a8e6ed8247f643918113b7bf881}{vt\+::collective\+::\+Plus\+Op}} \\\cline{1-2}
std\+::min &{\ttfamily \hyperlink{namespacevt_1_1collective_a0d9f013f61a3e2a15a9e0491409f50f2}{vt\+::collective\+::\+Min\+Op}} \\\cline{1-2}
std\+::max &{\ttfamily \hyperlink{namespacevt_1_1collective_aee17b1e7ed3266f7407f01253ecc2807}{vt\+::collective\+::\+Max\+Op}} \\\cline{1-2}
operator\& &{\ttfamily \hyperlink{namespacevt_1_1collective_a64c800cae2fcb4ec24d2c5540cca0f9e}{vt\+::collective\+::\+Bit\+And\+Op}} \\\cline{1-2}
operator$|$ &{\ttfamily \hyperlink{namespacevt_1_1collective_a07085d466f47337de6f1d6ea30023c11}{vt\+::collective\+::\+Bit\+Or\+Op}} \\\cline{1-2}
operator$^\wedge$ &{\ttfamily \hyperlink{namespacevt_1_1collective_a834c8e21559219187ec9ef79f72cf474}{vt\+::collective\+::\+Bit\+Xor\+Op}} \\\cline{1-2}
$<$no-\/operator$>$ &{\ttfamily \hyperlink{namespacevt_1_1collective_a812e9225d75c8888457b29f971c33f75}{vt\+::collective\+::\+None\+Op}} \\\cline{1-2}
\end{longtabu}
\hypertarget{collective_collective-reduce-example}{}\subsubsection{A Simple Reduction}\label{collective_collective-reduce-example}

\begin{DoxyCode}
\textcolor{preprocessor}{#include <\hyperlink{transport_8h}{vt/transport.h}>}

\textcolor{comment}{// Reduce ints}
\textcolor{keyword}{struct }ReduceDataMsg : \hyperlink{structvt_1_1collective_1_1reduce_1_1operators_1_1_reduce_data_msg}{vt::collective::ReduceTMsg}<int> \{
  \textcolor{keyword}{explicit} \hyperlink{structvt_1_1collective_1_1reduce_1_1operators_1_1_reduce_data_msg_ab5f090157aff94fa6b1c233ccc5e0e04}{ReduceDataMsg}(\textcolor{keywordtype}{int} val)
    : \hyperlink{namespacevt}{vt}::collective::\hyperlink{namespacevt_1_1collective_1_1reduce_1_1operators_a85097552afc7e87d5d5092f068223ca0}{ReduceTMsg}<int>(val)
  \{ \}
\};

\textcolor{comment}{// Handler to target for reduction}
\textcolor{keyword}{struct }ReduceResult \{
  \textcolor{keywordtype}{void} operator()(ReduceDataMsg* msg) \{
    \textcolor{keyword}{auto} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();
    \textcolor{keyword}{auto} \hyperlink{namespacevt_ad3ca3e8710dd3c8badff897f8de3c858}{output} = msg->getConstVal();
    fmt::print(\textcolor{stringliteral}{"reduction value=\{\}\(\backslash\)n"}, \hyperlink{namespacevt_ad3ca3e8710dd3c8badff897f8de3c858}{output});
    \hyperlink{config__assert_8h_aeddd4990a496e91a0ca5d6c16437359b}{vtAssert}(num\_nodes * 50 == \hyperlink{namespacevt_ad3ca3e8710dd3c8badff897f8de3c858}{output}, \textcolor{stringliteral}{"Must be equal);}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{\};}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{int main(int argc, char** argv) \{}
\textcolor{stringliteral}{  vt::initialize(argc, argv);}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  auto reduce\_msg = vt::makeMessage<ReduceDataMsg>(50);}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  NodeType const root\_reduce\_node = 0;}
\textcolor{stringliteral}{  vt::theCollective()->global()->reduce<vt::collective::PlusOp<int>,ReduceResult>(}
\textcolor{stringliteral}{    root\_reduce\_node, reduce\_msg.get()}
\textcolor{stringliteral}{  );}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  vt::finalize(); // spins in scheduler until termination}
\textcolor{stringliteral}{  return 0;}
\textcolor{stringliteral}{\}}
\end{DoxyCode}
 \hypertarget{event}{}\section{Event Manager}\label{event}
Manage asynchronous events

The async event component {\ttfamily \hyperlink{structvt_1_1event_1_1_async_event}{vt\+::event\+::\+Async\+Event}}, accessed via {\ttfamily \hyperlink{namespacevt_aa297fcaadc8a330890eb90c5b0081ec5}{vt\+::the\+Event()}} manages local and remote events that complete asynchronously. One may create an event for a {\ttfamily M\+P\+I\+\_\+\+Request} so the scheduler tests the event as the scheduler polls. Once may also create other general events that have a unique ID that can be tested remotely. Parent events group sets of other events (parent, normal, or M\+PI events) together to test them for completion in a single operation. The event manager is mostly designed for internal {\bfseries {\itshape vt}} usage. \hypertarget{group}{}\section{Group Manager}\label{group}
Create a grouping of nodes

The group manager component {\ttfamily \hyperlink{structvt_1_1group_1_1_group_manager}{vt\+::group\+::\+Group\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt\+::the\+Group()}} manages both rooted and collective groups (or subsets) of nodes that can be broadcast to or reduced over. The group manager implements a fully distributed algorithm for constructing groups collectively with each node deciding if it should be included. The group manager builds a reasonably balanced distributed spanning tree based on these collective votes.

One major use case for the group manager is creating spanning trees for reductions over virtual collections that do not span all the nodes.

When creating a group, one may ask {\bfseries {\itshape vt}} to create a underlying M\+PI group, which can be accessed once the group has finished construction.\hypertarget{group_collective-group-example}{}\subsection{Example creating a collective group}\label{group_collective-group-example}

\begin{DoxyCodeInclude}
\textcolor{keyword}{struct }HelloGroupMsg : \hyperlink{structvt_1_1messaging_1_1_active_msg}{vt::Message} \{ \};

\textcolor{keyword}{static} \textcolor{keywordtype}{void} hello\_group\_handler(HelloGroupMsg* msg) \{
  fmt::print(\textcolor{stringliteral}{"\{\}: Hello from group handler\(\backslash\)n"}, \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->getNode());
\}

\textcolor{keyword}{using} \hyperlink{namespacevt_1_1collective_a4c5bf7769ad4396573d6bcc85ec430a4}{ReduceMsg} = \hyperlink{structvt_1_1collective_1_1reduce_1_1operators_1_1_reduce_data_msg}{vt::collective::ReduceTMsg<int>};

\textcolor{keyword}{struct }Print \{
  \textcolor{keywordtype}{void} operator()(\hyperlink{namespacevt_1_1collective_a4c5bf7769ad4396573d6bcc85ec430a4}{ReduceMsg}* msg) \{
    fmt::print(\textcolor{stringliteral}{"final value=\{\}\(\backslash\)n"}, msg->getConstVal());
  \}
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_a580ef23e9a224fc0907da1a6db308b5b}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keywordflow}{if} (num\_nodes < 2) \{
    \textcolor{keywordflow}{return} \hyperlink{namespacevt_aff96ace008dc847d4c0f44cfa5dfb3a0}{vt::rerror}(\textcolor{stringliteral}{"requires at least 2 nodes"});
  \}

  srand48(this\_node * 29);

  \textcolor{keywordtype}{bool} odd\_node\_filter = this\_node % 2 == 1;

  \hyperlink{namespacevt_a27b5e4411c9b6140c49100e050e2f743}{vt::GroupType} new\_group = \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt::theGroup}()->
      \hyperlink{structvt_1_1group_1_1_group_manager_a92b301d6cf77af7d57ed822c6f044d58}{newGroupCollective}(
    odd\_node\_filter, [=](\hyperlink{namespacevt_a27b5e4411c9b6140c49100e050e2f743}{vt::GroupType} group)\{
      \textcolor{keyword}{auto} \textcolor{keyword}{const}& root = 0;
      \textcolor{keyword}{auto} \textcolor{keyword}{const}& in\_group = \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt::theGroup}()->\hyperlink{structvt_1_1group_1_1_group_manager_a2204bcd119aaf06e0e356957faad36e6}{inGroup}(group);
      \textcolor{keyword}{auto} \textcolor{keyword}{const}& root\_node = \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt::theGroup}()->\hyperlink{structvt_1_1group_1_1_group_manager_ab5b8178a37165903c73f9159c9259cf5}{groupRoot}(group);
      \textcolor{keyword}{auto} \textcolor{keyword}{const}& is\_default\_group = \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt::theGroup}()->\hyperlink{structvt_1_1group_1_1_group_manager_ad4d55f7bcf2aadd97c858b3f11c5d365}{isGroupDefault}(group);
      fmt::print(
        \textcolor{stringliteral}{"\{\}: Group is created: group=\{:x\}, in\_group=\{\}, root=\{\}, "}
        \textcolor{stringliteral}{"is\_default\_group=\{\}\(\backslash\)n"},
        this\_node, group, in\_group, root\_node, is\_default\_group
      );
      \textcolor{keywordflow}{if} (in\_group) \{
        \textcolor{keyword}{using} Op = \hyperlink{structvt_1_1collective_1_1reduce_1_1operators_1_1_plus_op}{vt::collective::PlusOp<int>};
        \textcolor{keyword}{auto} msg = vt::makeMessage<ReduceMsg>(1);
        \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt::theGroup}()->\hyperlink{structvt_1_1group_1_1_group_manager_a3234e5be55c32ccfb56785265e26b4c6}{groupReducer}(group)->\hyperlink{structvt_1_1collective_1_1reduce_1_1_reduce_adf8bd9748a220a3ed29087c30f8adafc}{reduce}<Op, Print>(root, msg.get(
      ));
      \}
      \textcolor{keywordflow}{if} (this\_node == 1) \{
        \textcolor{keyword}{auto} msg = vt::makeMessage<HelloGroupMsg>();
        \hyperlink{namespacevt_a9f9d4ce6034c0eaaf98bdffd33d0e1c7}{vt::envelopeSetGroup}(msg->env, group);
        \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__typesafehan_ga1a347aac6b6b8d47c9b1c8cc11b7f33e}{broadcastMsg}<hello\_group\_handler>(msg);
      \}
    \}
  );

  fmt::print(\textcolor{stringliteral}{"\{\}: New group=\{\}\(\backslash\)n"}, this\_node, new\_group);

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
\hypertarget{lb-manager}{}\section{LB Manager}\label{lb-manager}
Manage load balancers

The LB manager component {\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_l_b_manager}{vt\+::vrt\+::collection\+::balance\+::\+L\+B\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a05187076eac8c66c9951b062b0955520}{vt\+::the\+L\+B\+Manager()}} manages and coordinates instances of load balancers. It will potentially start load balancing after a \char`\"{}phase\char`\"{} is completed; refer to \hyperlink{phase}{Phase Manager} for details about how to delineate phases in an application. The LB manager reads command-\/line arguments or an LB specification file to determine which load balancer to run at a given phase.

To enable load balancing, the cmake flag
\begin{DoxyCode}
-Dvt\_lb\_enabled=1
\end{DoxyCode}
 should be passed during building. This also enables automatic instrumentation of work and communication performed by collection elements.

To run a load balancer at runtime\+:


\begin{DoxyItemize}
\item Pass {\ttfamily -\/-\/vt\+\_\+lb -\/-\/vt\+\_\+lb\+\_\+name=$<$LB$>$} as a command line argument
\item Write a LB config file {\ttfamily -\/-\/vt\+\_\+lb -\/-\/vt\+\_\+lb\+\_\+file\+\_\+name=$<$F\+I\+LE$>$}
\item One can also pass {\ttfamily -\/-\/vt\+\_\+lb\+\_\+self\+\_\+migration} as a command line argument to allow load balancer to migrate objects to the same node
\end{DoxyItemize}

Note that one should use either {\ttfamily -\/-\/vt\+\_\+lb\+\_\+name} or {\ttfamily -\/-\/vt\+\_\+lb\+\_\+file\+\_\+name} option, not both.\hypertarget{lb-manager_lb-config-file}{}\subsection{L\+B Config File}\label{lb-manager_lb-config-file}
The LB config file allows users to specify which load balancer along with which L\+B-\/specific configuration parameters are passed to the load balancer instance for any given phase. The order of the LB phase specification lines in the file disambiguates lines---higher precedence for earlier lines.

The format of the LB config file is\+:


\begin{DoxyCode}
[%] <$phase> <$lbname> [$LB-specific-arg-1] ... [$LB-specific-arg-N]
\end{DoxyCode}


If a {\ttfamily \%} is present, the line matches phases where\+: {\ttfamily current phase \% \$phase == 0}. Phase-\/specific lines (ones that specify a load balancer without a {\ttfamily \%}) always always have precedence over {\ttfamily \%} lines. The next token after the optional {\ttfamily \%} and {\ttfamily \$phase} is the name of the load balancer to invoke on that phase. After the load balancer name, {\ttfamily N} arguments to the load balancer are allowed to customize how the load balancer is run with the format of {\ttfamily key=value}. These arguments are the equivalent of passing {\ttfamily -\/-\/vt\+\_\+lb\+\_\+args=\char`\"{}\+A=test B=test2\char`\"{}} on the command line.

The following is an example LB config\+:


\begin{DoxyCode}
%10 TemperedLB c=1 k=5 f=2 i=10
0 HierarchicalLB min=0.9 max=1.1 auto=false
% 5 GreedyLB min=1.0
120 GreedyLB c=0 k=2 f=3 i=3
\end{DoxyCode}


To print LB config during startup, use {\ttfamily -\/-\/vt\+\_\+lb\+\_\+show\+\_\+config} command line flag.\hypertarget{lb-manager_load-balancers}{}\subsection{Load balancers}\label{lb-manager_load-balancers}
\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Load Balancer }&\textbf{ Type }&\textbf{ Description }&\textbf{ Reference  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Load Balancer }&\textbf{ Type }&\textbf{ Description }&\textbf{ Reference  }\\\cline{1-4}
\endhead
Rotate\+LB &Testing &Rotate objects in a ring &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1lb_1_1_rotate_l_b}{vt\+::vrt\+::collection\+::lb\+::\+Rotate\+LB}} \\\cline{1-4}
Random\+LB &Testing &Randomly migrate object with seed &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1lb_1_1_random_l_b}{vt\+::vrt\+::collection\+::lb\+::\+Random\+LB}} \\\cline{1-4}
Greedy\+LB &Centralized &Gather to central node apply min/max heap &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1lb_1_1_greedy_l_b}{vt\+::vrt\+::collection\+::lb\+::\+Greedy\+LB}} \\\cline{1-4}
Tempered\+LB &Distributed &Inspired by epidemic algorithms &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1lb_1_1_tempered_l_b}{vt\+::vrt\+::collection\+::lb\+::\+Tempered\+LB}} \\\cline{1-4}
Hierarchical\+LB &Hierarchical &Build tree to move objects nodes &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1lb_1_1_hierarchical_l_b}{vt\+::vrt\+::collection\+::lb\+::\+Hierarchical\+LB}} \\\cline{1-4}
Zoltan\+LB &Hyper-\/graph Partitioner &Run Zoltan in hyper-\/graph mode to LB &{\ttfamily vt\+::vrt\+::collection\+::lb\+::\+Zoltan\+LB} \\\cline{1-4}
Offline\+LB &User-\/specified &Read file to determine mapping &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1lb_1_1_offline_l_b}{vt\+::vrt\+::collection\+::lb\+::\+Offline\+LB}} \\\cline{1-4}
Test\+Serialization\+LB &Testing &Migrate objects to the same node, for testing serialization/deserialization purpose &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1lb_1_1_test_serialization_l_b}{vt\+::vrt\+::collection\+::lb\+::\+Test\+Serialization\+LB}} \\\cline{1-4}
\end{longtabu}
\hypertarget{lb-manager_load-models}{}\subsection{Object Load Models}\label{lb-manager_load-models}
The performance-\/oriented load balancers described in the preceding section require a prediction of the loads each object will represent during the phases between one load balancing invocation and the next. These predictions are provided by load models, which are implementations of the {\ttfamily vt\+::vrt\+:collection\+:\+:balance\+::\+Load\+Model} interface. There are a number of general-\/purpose load model implementations provided by {\bfseries {\itshape vt}}.

By default, {\bfseries {\itshape vt}} uses a load model that predicts each object\textquotesingle{}s work load for all future phases will match its workload in the most recent past phase. The system also provides an interface for applications and users to arrange use of a non-\/default load model where that may be desirable for reasons such as performance experimentation, specialization to application details, or execution environment considerations. To install a custom load model, application code should call {\ttfamily \hyperlink{namespacevt_a05187076eac8c66c9951b062b0955520}{vt\+::the\+L\+B\+Manager()}-\/$>$set\+Load\+Model(user\+\_\+model)}. To simplify implementation of custom load models, and allow them to benefit from future system-\/level improvements, we recommend that custom load models be composed atop the default model, which can be obtained by calling {\ttfamily \hyperlink{namespacevt_a05187076eac8c66c9951b062b0955520}{vt\+::the\+L\+B\+Manager()}-\/$>$get\+Base\+Load\+Model()}.

Most provided load models are designed as composable filters inherited from the {\ttfamily vt\+::vrt\+:collection\+:\+:balance\+::\+Composed\+Model} class. This allows them to form a \textquotesingle{}model stack\textquotesingle{} in which each class makes a particular adjustment to the predictions generated, and relies on others above and below to refine them further. One exception is the {\ttfamily vt\+::vrt\+:collection\+:\+:balance\+::\+Raw\+Data} model, which directly returns past values recorded in the instrumented statistics structures that {\ttfamily L\+B\+Manager} provides.

To illustrate the design concept, the default model is implemented as a stack of two other components. At the base of the stack is a {\ttfamily Raw\+Data} model that will refer to the instrumented object load timings recorded by the system during preceding execution. Layered on that is a {\ttfamily vt\+::vrt\+:collection\+:\+:balance\+::\+Naive\+Persistence} model that queries the underlying {\ttfamily Raw\+Data} model for the times taken in the most recent phase, and returns those same times as its prediction of the times those objects will take in all future phases.

The full set of load model classes provided with {\bfseries {\itshape vt}} is as follows

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Load Model }&\textbf{ Description }&\textbf{ Reference  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Load Model }&\textbf{ Description }&\textbf{ Reference  }\\\cline{1-3}
\endhead
{\bfseries Utilities} &&\\\cline{1-3}
Load\+Model &Pure virtual interface class, which the following implement &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_load_model}{vt\+::vrt\+::collection\+::balance\+::\+Load\+Model}} \\\cline{1-3}
Composed\+Model &A convenience class for most implementations to inherit from, that passes unmodified calls through to an underlying model instance &{\ttfamily \hyperlink{classvt_1_1vrt_1_1collection_1_1balance_1_1_composed_model}{vt\+::vrt\+::collection\+::balance\+::\+Composed\+Model}} \\\cline{1-3}
Raw\+Data &Returns historical data only, from the measured times &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_raw_data}{vt\+::vrt\+::collection\+::balance\+::\+Raw\+Data}} \\\cline{1-3}
{\bfseries Transformers} &Transforms the values computed by the composed model(s), agnostic to whether a query refers to a past or future phase &\\\cline{1-3}
Norm &When asked for a {\ttfamily W\+H\+O\+L\+E\+\_\+\+P\+H\+A\+SE} value, computes a specified l-\/norm over all subphases &{\ttfamily \hyperlink{classvt_1_1vrt_1_1collection_1_1balance_1_1_norm}{vt\+::vrt\+::collection\+::balance\+::\+Norm}} \\\cline{1-3}
Select\+Subphases &Filters and remaps the subphases with data present in the underlying model &{\ttfamily \hyperlink{classvt_1_1vrt_1_1collection_1_1balance_1_1_select_subphases}{vt\+::vrt\+::collection\+::balance\+::\+Select\+Subphases}} \\\cline{1-3}
Comm\+Overhead &Adds a specified amount of imputed \textquotesingle{}system overhead\textquotesingle{} time to each object\textquotesingle{}s work based on the number of messages received &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_comm_overhead}{vt\+::vrt\+::collection\+::balance\+::\+Comm\+Overhead}} \\\cline{1-3}
Per\+Collection &Maintains a set of load models associated with different collection instances, and passes queries for an object through to the model corresponding to its collection &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_per_collection}{vt\+::vrt\+::collection\+::balance\+::\+Per\+Collection}} \\\cline{1-3}
{\bfseries Predictors} &Computes values for future phase queries, and passes through past phase queries &\\\cline{1-3}
Naive\+Persistence &Passes through historical queries, and maps all future queries to the most recent past phase &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_naive_persistence}{vt\+::vrt\+::collection\+::balance\+::\+Naive\+Persistence}} \\\cline{1-3}
Persistence\+Median\+LastN &Similar to Naive\+Persistence, except that it predicts based on a median over the N most recent phases &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_persistence_median_last_n}{vt\+::vrt\+::collection\+::balance\+::\+Persistence\+Median\+LastN}} \\\cline{1-3}
Linear\+Model &Computes a linear regression over on object\textquotesingle{}s loads from a number of recent phases &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_linear_model}{vt\+::vrt\+::collection\+::balance\+::\+Linear\+Model}} \\\cline{1-3}
Multiple\+Phases &Computes values for future phases based on sums of the underlying model\textquotesingle{}s predictions for N corresponding future phases &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_multiple_phases}{vt\+::vrt\+::collection\+::balance\+::\+Multiple\+Phases}} \\\cline{1-3}
\end{longtabu}
All of the provided load balancers described in the previous section require that the installed load model provide responses to future phase queries for at least {\ttfamily Phase\+Offset\+::\+N\+E\+X\+T\+\_\+\+P\+H\+A\+SE} (i.\+e. {\ttfamily 0}), as the {\bfseries Predictors} described above do. \hypertarget{location}{}\section{Location Manager}\label{location}
Virtual entity location management

The location manager component {\ttfamily \hyperlink{structvt_1_1location_1_1_location_manager}{vt\+::location\+::\+Location\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_ace1c9d64e09732e3b7414d02517ecfdb}{vt\+::the\+Loc\+Man()}} manages the location of arbitrary virtual entities in the system. It holds a set of live {\ttfamily \hyperlink{structvt_1_1location_1_1_entity_location_coord}{vt\+::location\+::\+Entity\+Location\+Coord}} across the distributed system which allow users to register/unregister entities and inform the system when migrations occur. With the entities registered, the location coordinator can route messages to them even in the presence of migrations that may occur at any time. The location coordinator maintains a cache of locations for entities registered off-\/node and forwards messages using a communication protocol that depends on the size of the message.

Every entity in the system has a \char`\"{}home node\char`\"{}, which is the node that is ultimately responsible for knowing the location of the entity. When an entity migrates, it informs the home node of its new location in the system. Nodes that try to route messages to that entity will inquire the home node unless the location is already in cache.\hypertarget{location_comm-protocol}{}\subsection{Eager vs. Rendezvous Routing Protocol}\label{location_comm-protocol}
The variable {\ttfamily vt\+::location\+::small\+\_\+msg\+\_\+max\+\_\+size} controls whether a message is routed with an eager or rendezvous protocol. If the message is under that size limit, the message is routed eagerly---forwarded to the \char`\"{}home node\char`\"{} for resolution if the location is not in the cache.

If the size of the message is greater than {\ttfamily vt\+::location\+::small\+\_\+msg\+\_\+max\+\_\+size}, the location coordinator will inquire with a control message to resolve the location before the large message is actually sent. This reduces the number of hops required to send large messages.\hypertarget{location_location-migrations}{}\subsection{Entity Migrations}\label{location_location-migrations}
When migrations occur at any time, it\textquotesingle{}s always possible for the message to arrive on a node where the entity {\itshape used to be}. In this case, the location coordinator knows to follow the breadcrumb to get the message delivered properly where the entity exists now. If the entity continues to move, the message will \char`\"{}chase\char`\"{} it until it catches up. \hypertarget{mem-usage}{}\section{Memory Usage Tracker}\label{mem-usage}
Track memory usage

The memory usage component {\ttfamily \hyperlink{structvt_1_1util_1_1memory_1_1_memory_usage}{vt\+::util\+::memory\+::\+Memory\+Usage}}, accessed via {\ttfamily \hyperlink{namespacevt_a38d485d3cf840b9a623e47e7754ef72e}{vt\+::the\+Mem\+Usage()}} is an optional VT component that tracks memory usage over time. It can be used with the \hyperlink{trace}{Tracing} component to write memory usage to Projections log files to track usage after each registered function executes. It can be configured to report usage after each LB phase is reached. This component is backed by a wide range of different reporters---everything from trapping memory allocation calls to counting allocated pages. \hypertarget{objgroup}{}\section{Object Group Manager}\label{objgroup}
Create object instances across nodes

The object group manager component {\ttfamily \hyperlink{structvt_1_1objgroup_1_1_obj_group_manager}{vt\+::objgroup\+::\+Obj\+Group\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a833f0115b692f578167cbd88e30d39c5}{vt\+::the\+Obj\+Group()}} allows the creation and management of instances of a group of objects (one per node) that have a collective proxy for performing operations like sends, broadcasts, or reductions across the object group.\hypertarget{objgroup_objgroup-example}{}\subsection{Example creating an object group}\label{objgroup_objgroup-example}

\begin{DoxyCodeInclude}
\textcolor{keyword}{struct }MyObjGroup \{
  \textcolor{keywordtype}{void} \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{handler}(\textcolor{keywordtype}{int} a, \textcolor{keywordtype}{int} b) \{
    \textcolor{keyword}{auto} \hyperlink{namespacevt_1_1config_a46e57c33bee1b9f1fa95455af86d80e0a576033c81e2ddd03d721ecef3b1b3f81}{node} = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
    fmt::print(\textcolor{stringliteral}{"\{\}: MyObjGroup::handler on a=\{\}, b=\{\}\(\backslash\)n"}, \hyperlink{namespacevt_1_1config_a46e57c33bee1b9f1fa95455af86d80e0a576033c81e2ddd03d721ecef3b1b3f81}{node}, a, b);
  \}
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_a580ef23e9a224fc0907da1a6db308b5b}{vt::initialize}(argc, argv);

  \textcolor{keyword}{const} \textcolor{keyword}{auto} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \textcolor{keyword}{const} \textcolor{keyword}{auto} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keyword}{auto} proxy =
    \hyperlink{namespacevt_a833f0115b692f578167cbd88e30d39c5}{vt::theObjGroup}()->\hyperlink{structvt_1_1objgroup_1_1_obj_group_manager_a50e0d8498d142a05773ed5a046803b2b}{makeCollective}<MyObjGroup>(\textcolor{stringliteral}{"examples\_hello\_world"});

  \textcolor{comment}{// Create group of odd nodes and multicast to them (from root node)}
  \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt::theGroup}()->\hyperlink{structvt_1_1group_1_1_group_manager_a92b301d6cf77af7d57ed822c6f044d58}{newGroupCollective}(
    this\_node % 2, [proxy, this\_node](::\hyperlink{namespacevt_a27b5e4411c9b6140c49100e050e2f743}{vt::GroupType} type) \{
      \textcolor{keywordflow}{if} (this\_node == 0) \{
        proxy.\hyperlink{structvt_1_1objgroup_1_1proxy_1_1_proxy_a48262367d5347f555bb028d97fa3b594}{multicast}<&\hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{MyObjGroup::handler}>(type, 122, 244);
      \}
    \});

  \hyperlink{namespacevt_aa8e0c0ab253e7ad1acd5d09e36fea769}{vt::theCollective}()->\hyperlink{structvt_1_1collective_1_1barrier_1_1_barrier_a05124050c7d353a4f3475ee1875dd46a}{barrier}();

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    \textcolor{comment}{// Send to object 0}
    proxy[0].send<&\hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{MyObjGroup::handler}>(5, 10);
    \textcolor{keywordflow}{if} (num\_nodes > 1) \{
      \textcolor{comment}{// Send to object 1}
      proxy[1].send<&\hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{MyObjGroup::handler}>(10, 20);
    \}

    \textcolor{comment}{// Broadcast to all nodes}
    proxy.\hyperlink{structvt_1_1objgroup_1_1proxy_1_1_proxy_a0b716ca776b1f06e0d7d45afbe9e5274}{broadcast}<&\hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{MyObjGroup::handler}>(400, 500);

    \textcolor{keyword}{using namespace }::\hyperlink{namespacevt_1_1group_1_1region}{vt::group::region};

    \textcolor{comment}{// Create list of nodes and multicast to them}
    List::ListType range;
    \textcolor{keywordflow}{for} (\hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} \hyperlink{namespacevt_1_1config_a46e57c33bee1b9f1fa95455af86d80e0a576033c81e2ddd03d721ecef3b1b3f81}{node} = 0; \hyperlink{namespacevt_1_1config_a46e57c33bee1b9f1fa95455af86d80e0a576033c81e2ddd03d721ecef3b1b3f81}{node} < num\_nodes; ++\hyperlink{namespacevt_1_1config_a46e57c33bee1b9f1fa95455af86d80e0a576033c81e2ddd03d721ecef3b1b3f81}{node}) \{
      \textcolor{keywordflow}{if} (\hyperlink{namespacevt_1_1config_a46e57c33bee1b9f1fa95455af86d80e0a576033c81e2ddd03d721ecef3b1b3f81}{node} % 2 == 0) \{
        range.push\_back(\hyperlink{namespacevt_1_1config_a46e57c33bee1b9f1fa95455af86d80e0a576033c81e2ddd03d721ecef3b1b3f81}{node});
      \}
    \}

    proxy.\hyperlink{structvt_1_1objgroup_1_1proxy_1_1_proxy_a48262367d5347f555bb028d97fa3b594}{multicast}<&\hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{MyObjGroup::handler}>(
      std::make\_unique<List>(range), 20, 40
    );
  \}
  \hyperlink{namespacevt_aa8e0c0ab253e7ad1acd5d09e36fea769}{vt::theCollective}()->\hyperlink{structvt_1_1collective_1_1barrier_1_1_barrier_a05124050c7d353a4f3475ee1875dd46a}{barrier}();

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
\hypertarget{pipe}{}\section{Pipe Manager}\label{pipe}
Create opaque callback endpoints

The pipe manager component {\ttfamily \hyperlink{structvt_1_1pipe_1_1_pipe_manager}{vt\+::pipe\+::\+Pipe\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt\+::the\+C\+B()}} allows the creation of general pipes and callbacks between opaque endpoints that are not revealed through the type. Callbacks allow one to supply a general endpoint that accepts a type of data without revealing the actual endpoint instance. For example, one may create a callback that triggers a handler invocation on a certain node, broadcasts to a handler, sends to a collection or objgroup, or broadcasts to a collection or objgroup, etc.

The pipe manager supports more complex use cases of multi-\/listener endpoints if one wants to trigger multiple endpoints on potentially different nodes. The lifetime of a pipe can also be configured---how many invocations are allowed before the callback is invalid. The pipe manager has a reference count for each pipe which gets decremented with each signal arrival. By default, callbacks are infinitely callable and do not expire.

The pipe manager also supports \char`\"{}typed\char`\"{} callbacks where the callee type is revealed to the caller. Typed callbacks are slightly more efficient because the type is exposed and registered type-\/erasure is not required (using lambdas).\hypertarget{pipe_callback-example}{}\subsection{Example callbacks}\label{pipe_callback-example}

\begin{DoxyCodeInclude}
\textcolor{comment}{// Message sent from the callback to the callback endpoint}
\textcolor{keyword}{struct }TestMsg : \hyperlink{structvt_1_1messaging_1_1_active_msg}{vt::Message} \{
  \textcolor{keyword}{using} MessageParentType = \hyperlink{namespacevt_a3a3ddfef40b4c90915fa43cdd5f129ea}{::vt::Message};
  \hyperlink{message__serialize_8h_a54128d5338aaa9c918179826085e13d1}{vt\_msg\_serialize\_required}(); \textcolor{comment}{// for string}

  TestMsg() = \textcolor{keywordflow}{default};

  \textcolor{keyword}{explicit} TestMsg(\textcolor{keywordtype}{int} in\_val, std::string \textcolor{keyword}{const}& in\_s = \textcolor{stringliteral}{"hello"})
    : val\_(in\_val),
      s\_(in\_s)
  \{ \}

  \textcolor{keyword}{template} <\textcolor{keyword}{typename} SerializerT>
  \textcolor{keywordtype}{void} \hyperlink{structvt_1_1messaging_1_1_active_msg_a758f02bef5991c48d6c9a56c30ca7ad9}{serialize}(SerializerT& s) \{
    \hyperlink{namespacecheckpoint_a075da4e7344cf037943362517e606c3a}{MessageParentType::serialize}(s);
    s | val\_;
    s | s\_;
  \}

  \textcolor{keywordtype}{int} val\_ = 0;
  std::string s\_;
\};

\textcolor{comment}{// Message containing the callback to invoke}
\textcolor{keyword}{struct }HelloMsg : \hyperlink{structvt_1_1messaging_1_1_active_msg}{vt::Message} \{
  \textcolor{keyword}{explicit} HelloMsg(\hyperlink{structvt_1_1pipe_1_1callback_1_1cbunion_1_1_callback_typed}{vt::Callback<TestMsg>} in\_cb)
    : cb\_(in\_cb)
  \{ \}

  \hyperlink{structvt_1_1pipe_1_1callback_1_1cbunion_1_1_callback_typed}{vt::Callback<TestMsg>} cb\_;
\};

\textcolor{comment}{// Handler function to invoke the callback from}
\textcolor{keywordtype}{void} hello\_world(HelloMsg* msg) \{
  \textcolor{keyword}{static} \textcolor{keywordtype}{int} val = 1;
  fmt::print(\textcolor{stringliteral}{"\{\}: Sending callback\(\backslash\)n"}, \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->getNode());
  msg->cb\_.send(292 + val++, \textcolor{stringliteral}{"test string"});
\}

\textcolor{keywordtype}{void} printOutput(TestMsg* msg, std::string type) \{
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  fmt::print(\textcolor{stringliteral}{"\{\}: cb \{\}: val=\{\}, str=\{\}\(\backslash\)n"}, this\_node, type, msg->val\_, msg->s\_);
\}

\textcolor{comment}{// Functor callback endpoint}
\textcolor{keyword}{struct }CallbackFunctor \{
  \textcolor{keywordtype}{void} operator()(TestMsg* msg) \{
    printOutput(msg, \textcolor{stringliteral}{"CallbackFunctor"});
  \}
\};

\textcolor{comment}{// Function callback endpoint}
\textcolor{keyword}{static} \textcolor{keywordtype}{void} callbackFunc(TestMsg* msg) \{
  printOutput(msg, \textcolor{stringliteral}{"callbackFunc"});
\}

\textcolor{keyword}{struct }MyObj \{
  \textcolor{comment}{// Objgroup callback endpoint}
  \textcolor{keywordtype}{void} \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{handler}(TestMsg* msg) \{
    printOutput(msg, \textcolor{stringliteral}{"MyObj::handler"});
  \}
\};

\textcolor{keyword}{struct }MyCol : \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection}{vt::Collection}<MyCol, vt::Index1D> \{ \};

\textcolor{comment}{// Collection handler callback endpoint}
\textcolor{keywordtype}{void} colHan(MyCol* col, TestMsg* msg) \{
  printOutput(msg, \textcolor{stringliteral}{"MyCol colHan (non-intrusive)"});
\}

\textcolor{keywordtype}{void} bounceCallback(\hyperlink{structvt_1_1pipe_1_1callback_1_1cbunion_1_1_callback_typed}{vt::Callback<TestMsg>} cb) \{
  \textcolor{keyword}{auto} msg = vt::makeMessage<HelloMsg>(cb);
  \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_ga0162a39473e7f9b490a79a7983d949ac}{sendMsg}<hello\_world>(1, msg);
\}

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_a580ef23e9a224fc0907da1a6db308b5b}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keywordflow}{if} (num\_nodes == 1) \{
    \textcolor{keywordflow}{return} \hyperlink{namespacevt_aff96ace008dc847d4c0f44cfa5dfb3a0}{vt::rerror}(\textcolor{stringliteral}{"requires at least 2 nodes"});
  \}

  \textcolor{keyword}{auto} obj = \hyperlink{namespacevt_a833f0115b692f578167cbd88e30d39c5}{vt::theObjGroup}()->\hyperlink{structvt_1_1objgroup_1_1_obj_group_manager_a50e0d8498d142a05773ed5a046803b2b}{makeCollective}<MyObj>(\textcolor{stringliteral}{"examples\_callback"});
  \textcolor{keyword}{auto} col = vt::makeCollection<MyCol>(\textcolor{stringliteral}{"examples\_callback"})
    .bounds(\hyperlink{structvt_1_1index_1_1_dense_index_array}{vt::Index1D}(8))
    .bulkInsert()
    .wait();

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} dest = num\_nodes > 2 ? 2 : 0;

    \textcolor{keyword}{auto} cb\_functor = \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt::theCB}()->\hyperlink{structvt_1_1pipe_1_1_pipe_manager_a3c6313a04c8ba283f4c32986ff8c7c30}{makeSend}<CallbackFunctor>(dest);
    bounceCallback(cb\_functor);

    \textcolor{keyword}{auto} cb\_func = \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt::theCB}()->\hyperlink{structvt_1_1pipe_1_1_pipe_manager_a3c6313a04c8ba283f4c32986ff8c7c30}{makeSend}<callbackFunc>(dest);
    bounceCallback(cb\_func);

    \textcolor{keyword}{auto} cb\_obj = \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt::theCB}()->\hyperlink{structvt_1_1pipe_1_1_pipe_manager_a3c6313a04c8ba283f4c32986ff8c7c30}{makeSend}<&\hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{MyObj::handler}>(obj[dest]);
    bounceCallback(cb\_obj);

    \textcolor{keyword}{auto} cb\_obj\_bcast = \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt::theCB}()->\hyperlink{structvt_1_1pipe_1_1_pipe_manager_a5b124c9c765e8b3bb9aca1b367e45db2}{makeBcast}<&\hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{MyObj::handler}>(obj);
    bounceCallback(cb\_obj\_bcast);

    \textcolor{keyword}{auto} cb\_col = \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt::theCB}()->\hyperlink{structvt_1_1pipe_1_1_pipe_manager_a3c6313a04c8ba283f4c32986ff8c7c30}{makeSend}<colHan>(col[5]);
    bounceCallback(cb\_col);

    \textcolor{keyword}{auto} cb\_col\_bcast = \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt::theCB}()->\hyperlink{structvt_1_1pipe_1_1_pipe_manager_a5b124c9c765e8b3bb9aca1b367e45db2}{makeBcast}<colHan>(col);
    bounceCallback(cb\_col\_bcast);
  \}

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
\hypertarget{node-lb-data}{}\section{Node LB Data}\label{node-lb-data}
Manager object profiling data

The node LB data manager component {\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_node_l_b_data}{vt\+::vrt\+::collection\+::balance\+::\+Node\+L\+B\+Data}}, accessed via {\ttfamily \hyperlink{namespacevt_af2ddfbdc455e98a0d46732522d8cf589}{vt\+::the\+Node\+L\+B\+Data()}} manages instrumentation data from objects in a collection. It holds data per node on the timing of these objects and communication between them demarcated by phase and subphase.

When LB is invoked in {\bfseries {\itshape vt}}, the \hyperlink{lb-manager}{LB Manager} passes the node LB data to the various LB strategies to run the load balancer. The node LB data component can also dump the LB data it holds to files, which can be read externally. The L\+B\+AF (Load Balancing Analysis Framework) can also then read this data to analyze the quality of the load distribution at any phase in the file.\hypertarget{node-lb-data_export-lb-data-file}{}\subsection{Exporting L\+B Data Files (\+V\+O\+M)}\label{node-lb-data_export-lb-data-file}
The {\ttfamily Node\+L\+B\+Data} component, after collecting LB data from the running program, can dump these to files in a V\+OM file (Virtual Object Map). As indicated by the name, the V\+OM file specifies the mapping of object to node for each phase along with LB data for each object (computation time and communication load).

To output V\+OM files, pass {\ttfamily -\/-\/vt\+\_\+lb\+\_\+data} to enable output along with {\ttfamily -\/-\/vt\+\_\+lb\+\_\+data\+\_\+dir=$<$my-\/directory$>$} and {\ttfamily -\/-\/vt\+\_\+lb\+\_\+data\+\_\+file=$<$my-\/base-\/name$>$} to control the directory the files are generated along with the base file name. With this enabled, {\bfseries {\itshape vt}} will generate a file for each node that contains the LB data and mapping.\hypertarget{node-lb-data_lb-data-file-format}{}\subsubsection{File Format}\label{node-lb-data_lb-data-file-format}
The V\+OM files are output in J\+S\+ON format, either compressed with brotli compression (default on) or pure J\+S\+ON if the argument {\ttfamily -\/-\/vt\+\_\+lb\+\_\+data\+\_\+compress} is set to {\ttfamily false}.

The J\+S\+ON files contain an array of {\ttfamily phases} that have been captured by {\bfseries {\itshape vt}} and output to the file. Each phase has an {\ttfamily id} indicating which phase it was while the application was running. Each phase also has an array of {\ttfamily tasks} that represent work that was done during that phase. Each task has a {\ttfamily time}, {\ttfamily resource}, {\ttfamily node}, {\ttfamily entity}, and optionally a list of {\ttfamily subphases}. The {\ttfamily entity} contains information about the task that performed this work. If that {\ttfamily entity} is a virtual collection object, it will specify the unique {\ttfamily id} for the object, and optionally the {\ttfamily index}, {\ttfamily home}, and {\ttfamily collection\+\_\+id} for that object.


\begin{DoxyCode}
\{
    "phases": [
        \{
            "id": 0,
            "tasks": [
                \{
                    "entity": \{
                        "collection\_id": 7,
                        "home": 0,
                        "id": 12884901888,
                        "index": [
                            3
                        ],
                        "type": "object"
                    \},
                    "node": 0,
                    "resource": "cpu",
                    "subphases": [
                        \{
                            "id": 0,
                            "time": 0.014743804931640625
                        \}
                    ],
                    "time": 0.014743804931640625
                \},
                \{
                    "entity": \{
                        "collection\_id": 7,
                        "home": 0,
                        "id": 4294967296,
                        "index": [
                            1
                        ],
                        "type": "object"
                    \},
                    "node": 0,
                    "resource": "cpu",
                    "subphases": [
                        \{
                            "id": 0,
                            "time": 0.013672113418579102
                        \}
                    ],
                    "time": 0.013672113418579102
                \}
            ]
        \},
        \{
            "id": 1,
            "tasks": [
                \{
                    "entity": \{
                        "collection\_id": 7,
                        "home": 0,
                        "id": 12884901888,
                        "index": [
                            3
                        ],
                        "type": "object"
                    \},
                    "node": 0,
                    "resource": "cpu",
                    "subphases": [
                        \{
                            "id": 0,
                            "time": 0.014104127883911133
                        \}
                    ],
                    "time": 0.014104127883911133
                \}
            ]
        \}
    ]
\}
\end{DoxyCode}


Each phase in the file may also have a {\ttfamily communications} array that specify any communication between tasks that occurred during the phase. Each communication has {\ttfamily type}, which is described below in the following table. Additionally, it specifies the {\ttfamily bytes}, number of {\ttfamily messages}, and the two entities that were involved in the operator as {\ttfamily to} and {\ttfamily from}. The entities may be of different types, like an {\ttfamily object} or {\ttfamily node} depending on the type of communication.


\begin{DoxyCode}
\{
    "phases": [
        \{
            "communications": [
                \{
                    "bytes": 262.0,
                    "from": \{
                        "home": 1,
                        "id": 1,
                        "type": "object"
                    \},
                    "messages": 1,
                    "to": \{
                        "home": 0,
                        "id": 4294967296,
                        "type": "object"
                    \},
                    "type": "SendRecv"
                \},
                \{
                    "bytes": 96.0,
                    "from": \{
                        "home": 0,
                        "id": 4294967296,
                        "type": "object"
                    \},
                    "messages": 1,
                    "to": \{
                        "id": 1,
                        "type": "node"
                    \},
                    "type": "CollectionToNode"
                \},
                \{
                    "bytes": 259.0,
                    "from": \{
                        "id": 0,
                        "type": "node"
                    \},
                    "messages": 1,
                    "to": \{
                        "home": 0,
                        "id": 0,
                        "type": "object"
                    \},
                    "type": "NodeToCollection"
                \}
            ],
            "id": 0
        \}
    ]
\}
\end{DoxyCode}


The type of communication lines up with the enum {\ttfamily vt\+::vrt\+::collection\+::balance\+::\+Comm\+Category} in the code.

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Value }&\textbf{ Enum entry }&\textbf{ Description  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Value }&\textbf{ Enum entry }&\textbf{ Description  }\\\cline{1-3}
\endhead
1 &{\ttfamily Comm\+Category\+::\+Send\+Recv} &A send-\/receive edge between two collection elements \\\cline{1-3}
2 &{\ttfamily Comm\+Category\+::\+Collection\+To\+Node} &A send from a collection element to a node \\\cline{1-3}
3 &{\ttfamily Comm\+Category\+::\+Node\+To\+Collection} &A send from a node to a collection element \\\cline{1-3}
4 &{\ttfamily Comm\+Category\+::\+Broadcast} &A broadcast from a collection element to a whole collection (receive-\/side) \\\cline{1-3}
5 &{\ttfamily Comm\+Category\+::\+Collection\+To\+Node\+Bcast} &A broadcast from a collection element to all nodes (receive-\/side) \\\cline{1-3}
6 &{\ttfamily Comm\+Category\+::\+Node\+To\+Collection\+Bcast} &A broadcast from a node to a whole collection (receive-\/side) \\\cline{1-3}
7 &{\ttfamily Comm\+Category\+::\+Collective\+To\+Collection\+Bcast} &Collective \textquotesingle{}broadcast\textquotesingle{} from every node to the local collection elements (receive-\/side) \\\cline{1-3}
\end{longtabu}
For all the broadcast-\/like edges, the communication logging will occur on the receive of the broadcast side (one entry per broadcast recipient).\hypertarget{node-lb-data_lb-spec-file}{}\subsection{L\+B Specification File}\label{node-lb-data_lb-spec-file}
In order to customize when LB output is enabled and disabled, a LB specification file can be passed to {\bfseries {\itshape vt}} via a command-\/line flag\+: {\ttfamily -\/-\/vt\+\_\+lb\+\_\+spec -\/-\/vt\+\_\+lb\+\_\+spec\+\_\+file=filename.\+spec}.

For details about vt\textquotesingle{}s Specification File see \hyperlink{spec-file}{Spec File} \hypertarget{phase}{}\section{Phase Manager}\label{phase}
Manage phases of time

The phase manager component {\ttfamily \hyperlink{structvt_1_1phase_1_1_phase_manager}{vt\+::phase\+::\+Phase\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a3799d6b51fb71d7b6505760aad457e61}{vt\+::the\+Phase()}} allows the delineation of collective intervals of time across all nodes. Load balancing, as well as other components, use phases as a boundary to perform many operations over an application\textquotesingle{}s execution such as work redistribution, outputting of statistical data, or flushing trace data.

The main user interface is a call to {\ttfamily \hyperlink{namespacevt_a3799d6b51fb71d7b6505760aad457e61}{the\+Phase()}-\/$>$next\+Phase\+Collective()} which starts the next phase after performing a reduction. Thus, any work that belongs in the preceding phase should be synchronized by the user before this is called (e.\+g., by calling {\ttfamily \hyperlink{namespacevt_a2fc4ef34f30b49a1781d765804bfadbb}{vt\+::run\+In\+Epoch\+Collective}}).

System components along with applications can register hooks with the phase manager to determine when a new phase is starting, ending, and after migrations have occurred. \hypertarget{pool}{}\section{Memory Pool}\label{pool}
Memory pool for efficient allocation

The memory pool component {\ttfamily \hyperlink{structvt_1_1pool_1_1_pool}{vt\+::pool\+::\+Pool}}, accessed via {\ttfamily \hyperlink{namespacevt_aab3530d89a64e5ea903b0ccf303ecbb7}{vt\+::the\+Pool()}} provides a highly efficient memory pool for fixed sized allocations in three sizes\+: small ({\ttfamily vt\+::pool\+::memory\+\_\+size\+\_\+small}), medium ({\ttfamily vt\+::pool\+::memory\+\_\+size\+\_\+medium}), and large (currently unimplemented).

All message allocation (on the send and receive side) is overloaded with new/delete overloads to allocate message memory through the {\bfseries {\itshape vt}} memory pool. The pool implementation uses a non-\/thread-\/safe allocation policy (must be allocated/deallocated on the same thread) with fixed sized buckets. If the size exceeds the largest bucket, the memory pool will fall back on the standard allocator. \hypertarget{rdma}{}\section{R\+D\+MA Manager}\label{rdma}
Node-\/level R\+D\+MA

 {\bfseries Experimental}

The R\+D\+MA manager component {\ttfamily \hyperlink{structvt_1_1rdma_1_1_r_d_m_a_manager}{vt\+::rdma\+::\+R\+D\+M\+A\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a68b8410bc2b86d3b5228d7dbb6b40bac}{vt\+::the\+R\+D\+M\+A()}} is an experimental component that sends pure data to registered R\+D\+MA handlers or directly to memory locations.

Registered R\+D\+MA handlers trigger a function when the data arrives (G\+ET) or is sent (P\+UT). If registered memory locations are used directly, one may create a R\+D\+MA channel which backs the G\+E\+T/\+P\+UT by {\ttfamily M\+P\+I\+\_\+\+Get}/{\ttfamily M\+P\+I\+\_\+\+Put}. \hypertarget{rdmahandle}{}\section{R\+D\+MA Handle Manager}\label{rdmahandle}
R\+D\+MA handles backed by M\+PI

The R\+D\+MA handle manager component {\ttfamily \hyperlink{structvt_1_1rdma_1_1_manager}{vt\+::rdma\+::\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_aecb87ec2c40b5b7fc57ba4cf8ea838b0}{vt\+::the\+Handle\+R\+D\+M\+A()}} is a component that allows data to be transferred between R\+D\+MA handles, which are persistent objects with underlying memory registered with M\+PI.

R\+D\+MA handles can either be node-\/ or index-\/level, depending on whether they belong to an objgroup or collection. A handle provides an interface to calling get/put/accum to access the backing M\+PI implementation. \hypertarget{registry}{}\section{Registry}\label{registry}
Registered handlers


\begin{DoxyItemize}
\item The \hyperlink{active-messenger}{Active Messenger} uses the registry to store/dispatch active function and active functor handlers.
\item The \hyperlink{objgroup}{Object Group Manager} uses the registry to store/dispatch active member functions
\item The \hyperlink{collection}{Virtual Context Collection} uses the registry to store/dispatch active functions with the object pointer and active members. 
\end{DoxyItemize}\hypertarget{scheduler}{}\section{Scheduler}\label{scheduler}
General scheduling of work

The scheduler component {\ttfamily \hyperlink{structvt_1_1sched_1_1_scheduler}{vt\+::sched\+::\+Scheduler}}, accessed via {\ttfamily \hyperlink{namespacevt_a4508b38e6ab664b64f1415aecbb83571}{vt\+::the\+Sched()}}, holds pieces of work to execute later that may be prioritized. The scheduler polls the {\bfseries {\itshape vt}} components to make progress and collect new pieces of work. The scheduler allows registration of callbacks when the system is idle.\hypertarget{scheduler_calls-to-the-scheduler}{}\subsection{Calls to the scheduler}\label{scheduler_calls-to-the-scheduler}
To advance the scheduler, one should use\+:


\begin{DoxyCode}
\hyperlink{namespacevt_a4508b38e6ab664b64f1415aecbb83571}{vt::theSched}()->\hyperlink{structvt_1_1sched_1_1_scheduler_a9c130fc0ccbf237633420a7aa35069a4}{runSchedulerWhile}(\textcolor{comment}{/*std::function<bool()> cond*/});
\end{DoxyCode}


This function polls (while {\ttfamily cond} is true) every component that might generate or complete work, and potentially runs one piece of available work, while also ensuring proper event unwinding and idle time tracking.\hypertarget{scheduler_higher-level-calls}{}\subsection{Higher-\/level Calls to Wait for Completion}\label{scheduler_higher-level-calls}
If work is enclosed in an \char`\"{}epoch\char`\"{}, the \hyperlink{term}{Termination Detector} can be used to track its distributed completion. In this case, instead of calling the scheduler directly, built-\/in higher-\/level functions can be used to advance the scheduler until this work is complete/terminated.

To run the scheduler until an epoch terminates, call the following function\+:


\begin{DoxyCode}
\hyperlink{namespacevt_aa550774c1c9c668176ce535fd7d58fb0}{vt::runSchedulerThrough}(my\_epoch);
\end{DoxyCode}


Or, to combine the actual enclosed work with the call to wait for its termination, use the following function\+:


\begin{DoxyCode}
\hyperlink{namespacevt_a9f5cbbc484d7f14f2ad0ee46d62dfb6e}{vt::runInEpochRooted}([]\{
  \textcolor{comment}{// work to do on a single node}
\});
\end{DoxyCode}


If the work should be executed by all nodes, use a collective epoch\+:


\begin{DoxyCode}
\hyperlink{namespacevt_a2fc4ef34f30b49a1781d765804bfadbb}{vt::runInEpochCollective}([]\{
  \textcolor{comment}{// work to do on all nodes}
\});
\end{DoxyCode}
 \hypertarget{term}{}\section{Termination Detector}\label{term}
Detect termination of work

The termination component {\ttfamily \hyperlink{structvt_1_1term_1_1_termination_detector}{vt\+::term\+::\+Termination\+Detector}}, accessed via {\ttfamily \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt\+::the\+Term()}} detects the completion of the transitive closure of work by following the causal chain of messages/events across multiple nodes. It provides global termination to determine when all work is complete and the schedulers can stop running. Additionally, it enables the creation of epochs (which stamp message envelopes) to mark messages as part of a work grouping to detect termination of all events causally related to a subset of messages in the system.

The termination detector comes with two different detection algorithms\+: (1) 4-\/counter wave-\/based termination for large collective or large rooted epochs across the whole system; and, (2) Dijkstra-\/\+Scholten parental responsibility termination for rooted epochs. Epochs are allowed to have other epochs nested within them, thus forming a graph. The detector tracks the relation between epochs, only making progress on epochs that do not have a dependency on another epoch terminating first.

The termination detector also comes with hang detection to detect causes where no progress can be made due to bugs in an application\textquotesingle{}s code or the runtime implementation. When a hang is detected, if configured as such by the user, the detector will dump a D\+OT graph of the live epochs and their dependencies.\hypertarget{term_term-collective-example}{}\subsection{Example of creating a collective epoch}\label{term_term-collective-example}

\begin{DoxyCodeInclude}
\textcolor{keyword}{using} TestMsg = \hyperlink{namespacevt_a3a3ddfef40b4c90915fa43cdd5f129ea}{vt::Message};

\hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} nextNode() \{
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();
  \textcolor{keywordflow}{return} (this\_node + 1) % num\_nodes;
\}

\textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_handler(TestMsg* msg) \{
  \textcolor{keyword}{static} \textcolor{keywordtype}{int} num = 3;

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();

  \textcolor{keyword}{auto} \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch} = \hyperlink{namespacevt_ad5495e7900227550b44837e899c5bb13}{vt::envelopeGetEpoch}(msg->env);
  fmt::print(\textcolor{stringliteral}{"\{\}: test\_handler: num=\{\}, epoch=\{:x\}\(\backslash\)n"}, this\_node, num, \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch});

  num--;
  \textcolor{keywordflow}{if} (num > 0) \{
    \textcolor{keyword}{auto} msg\_send = vt::makeMessage<TestMsg>();
    \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_ga0162a39473e7f9b490a79a7983d949ac}{sendMsg}<test\_handler>(nextNode(), msg\_send);
  \}
\}

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_a580ef23e9a224fc0907da1a6db308b5b}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keywordflow}{if} (num\_nodes == 1) \{
    \textcolor{keywordflow}{return} \hyperlink{namespacevt_aff96ace008dc847d4c0f44cfa5dfb3a0}{vt::rerror}(\textcolor{stringliteral}{"requires at least 2 nodes"});
  \}

  \textcolor{keyword}{auto} \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch} = \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt::theTerm}()->\hyperlink{structvt_1_1term_1_1_termination_detector_aeba62165ec8dfbc445e3631ff295f159}{makeEpochCollective}();

  \textcolor{comment}{// This action will not run until all messages originating from the}
  \textcolor{comment}{// sends are completed}
  \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt::theTerm}()->\hyperlink{structvt_1_1term_1_1_term_action_a1227042cb4eb38937fb8ed34bcbdf998}{addAction}(\hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch}, [=]\{
    fmt::print(\textcolor{stringliteral}{"\{\}: finished epoch=\{:x\}\(\backslash\)n"}, this\_node, \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch});
  \});

  \textcolor{comment}{// Message must go out of scope before finalize}
  \{
    \textcolor{keyword}{auto} msg = vt::makeMessage<TestMsg>();
    \hyperlink{namespacevt_a4a0a9928690206b588dbcac2afb71088}{vt::envelopeSetEpoch}(msg->env, \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch});
    \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_ga0162a39473e7f9b490a79a7983d949ac}{sendMsg}<test\_handler>(nextNode(), msg);
  \}

  \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt::theTerm}()->\hyperlink{structvt_1_1term_1_1_termination_detector_ad54d75c50bd3f34f30247817737bc303}{finishedEpoch}(\hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch});

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
 \hypertarget{term_term-rooted-example}{}\subsection{Example of creating a rooted epoch}\label{term_term-rooted-example}

\begin{DoxyCodeInclude}
\textcolor{keyword}{using} TestMsg = \hyperlink{namespacevt_a3a3ddfef40b4c90915fa43cdd5f129ea}{vt::Message};

\hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} nextNode() \{
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();
  \textcolor{keywordflow}{return} (this\_node + 1) % num\_nodes;
\}

\textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_handler(TestMsg* msg) \{
  \textcolor{keyword}{static} \textcolor{keywordtype}{int} num = 3;

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();

  \textcolor{keyword}{auto} \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch} = \hyperlink{namespacevt_ad5495e7900227550b44837e899c5bb13}{vt::envelopeGetEpoch}(msg->env);
  fmt::print(\textcolor{stringliteral}{"\{\}: test\_handler: num=\{\}, epoch=\{:x\}\(\backslash\)n"}, this\_node, num, \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch});

  num--;
  \textcolor{keywordflow}{if} (num > 0) \{
    \textcolor{keyword}{auto} msg\_send = vt::makeMessage<TestMsg>();
    \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_ga0162a39473e7f9b490a79a7983d949ac}{sendMsg}<test\_handler>(nextNode(), msg\_send);
  \}
\}

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_a580ef23e9a224fc0907da1a6db308b5b}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keywordflow}{if} (num\_nodes == 1) \{
    \textcolor{keywordflow}{return} \hyperlink{namespacevt_aff96ace008dc847d4c0f44cfa5dfb3a0}{vt::rerror}(\textcolor{stringliteral}{"requires at least 2 nodes"});
  \}

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    \textcolor{keyword}{auto} \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch} = \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt::theTerm}()->\hyperlink{structvt_1_1term_1_1_termination_detector_a232f305124ecd8f4f62e9c8224a74f49}{makeEpochRooted}(
      \hyperlink{structvt_1_1term_1_1_use_d_s}{vt::term::UseDS}\{\textcolor{keyword}{true}\});

    \textcolor{comment}{// This action will not run until all messages originating from the}
    \textcolor{comment}{// following send are completed}
    \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt::theTerm}()->\hyperlink{structvt_1_1term_1_1_term_action_a1227042cb4eb38937fb8ed34bcbdf998}{addAction}(\hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch}, [=]\{
      fmt::print(\textcolor{stringliteral}{"\{\}: finished epoch=\{:x\}\(\backslash\)n"}, this\_node, \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch});
    \});

    \textcolor{keyword}{auto} msg = vt::makeMessage<TestMsg>();
    \hyperlink{namespacevt_a4a0a9928690206b588dbcac2afb71088}{vt::envelopeSetEpoch}(msg->env, \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch});
    \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_ga0162a39473e7f9b490a79a7983d949ac}{sendMsg}<test\_handler>(nextNode(), msg);
    \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt::theTerm}()->\hyperlink{structvt_1_1term_1_1_termination_detector_ad54d75c50bd3f34f30247817737bc303}{finishedEpoch}(\hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a05bdb92281360bcbfdf239ad3ccbde19}{epoch});
  \}

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
\hypertarget{epoch}{}\section{Epoch Manager}\label{epoch}
Manage TD epochs

The epoch manager component {\ttfamily \hyperlink{structvt_1_1epoch_1_1_epoch_manip}{vt\+::epoch\+::\+Epoch\+Manip}}, accessed via {\ttfamily \hyperlink{namespacevt_ad246530e523687095c567ccab203556a}{vt\+::the\+Epoch()}}, manages termination epochs that are allocated and deallocated as a program executes to encapsulate and order distributed work. The epoch manager controls the bits allocated for these along with scopes (distinct, collective strands of epoch bit allocation) for generating the bits. The epoch manager also allows inspection of information embedded in the epoch bit field {\ttfamily \hyperlink{namespacevt_a81d11b28122d43bf9834577e4a06440f}{vt\+::\+Epoch\+Type}} that encodes the epoch type, category, scope, rank, etc. \hypertarget{time-trigger}{}\section{Time Triggers}\label{time-trigger}
Time-\/based progress actions

The timed trigger component {\ttfamily \hyperlink{structvt_1_1timetrigger_1_1_time_trigger_manager}{vt\+::timetrigger\+::\+Time\+Trigger\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a1e1a39cdf2a3fc1adefcdfcca4716bf2}{vt\+::the\+Time\+Trigger()}} manages and coordinates time-\/based actions that can be registered by the system and users.

A timed trigger, when registered using the manager, will fire approximately along that period. For instance, if a trigger is registered with a 100ms period, it will be called approximately every 100ms while the {\bfseries {\itshape vt}} progress function is being invoked. If the progress function (or {\bfseries {\itshape vt}} scheduler) is called infrequently, the triggers may be delayed depending on the period. Also, if large work units are enqueued in the {\bfseries {\itshape vt}} scheduler that take longer than the time period, the trigger will fire as often as it can in between these pieces of work (the component does not use interrupts to trigger actions).

To register a trigger, call {\ttfamily \hyperlink{namespacevt_a1e1a39cdf2a3fc1adefcdfcca4716bf2}{vt\+::the\+Time\+Trigger()}-\/$>$add\+Trigger(100ms, \mbox{[}\mbox{]}\{ /$\ast$ my action $\ast$/\});}. The {\ttfamily add\+Trigger} method returns a handle to the registered trigger that can be passed to {\ttfamily \hyperlink{namespacevt_a1e1a39cdf2a3fc1adefcdfcca4716bf2}{vt\+::the\+Time\+Trigger()}-\/$>$remove\+Trigger(id);} to stop it from firing at a certain point. \hypertarget{trace}{}\section{Tracing}\label{trace}
Trace distributed events

The optional trace component {\ttfamily \hyperlink{structvt_1_1trace_1_1_trace}{vt\+::trace\+::\+Trace}}, accessed via {\ttfamily vt\+::the\+Trace()} builds a distributed trace of events, including VT handlers, user events, and M\+PI invocations via the P\+M\+PI interface. It outputs \href{http://charm.cs.uiuc.edu/software}{\tt Projections} log and sts files to enable performance analysis after execution.

To enable tracing at runtime, the trace component must be enabled at compile time with cmake. To enable tracing pass the cmake flag\+: 
\begin{DoxyCode}
-Dvt\_trace\_enabled=1
\end{DoxyCode}
\hypertarget{trace_tracing-spec-file}{}\subsection{Tracing Specification File}\label{trace_tracing-spec-file}
In order to customize when tracing is enabled and disabled, a trace specification file can be passed to {\bfseries {\itshape vt}} via a command-\/line flag\+: {\ttfamily -\/-\/vt\+\_\+trace\+\_\+spec -\/-\/vt\+\_\+trace\+\_\+spec\+\_\+file=filename.\+spec}.

For details about vt\textquotesingle{}s Specification File see \hyperlink{spec-file}{Spec File} \hypertarget{lb-data-reader}{}\section{LB Restart Reader}\label{lb-data-reader}
Follow input LB distribution

The LB data restart reader component {\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_l_b_data_restart_reader}{vt\+::vrt\+::collection\+::balance\+::\+L\+B\+Data\+Restart\+Reader}}, accessed via {\ttfamily \hyperlink{namespacevt_a6dc000b04e41df77184588b50280b312}{vt\+::the\+L\+B\+Data\+Reader()}} reads in an input object distribution for a given program and follows the distribution as specified in the file.

A common flow is the following\+:
\begin{DoxyItemize}
\item Run the program to output LB data files (with the flag {\ttfamily -\/-\/vt\+\_\+lb\+\_\+data})
\item Input those files to the L\+B\+AF (Load Balancing Analysis Framework) to generate a new load distribution offline (e.\+g., to test a new LB strategy).
\begin{DoxyItemize}
\item Tell L\+B\+AF to generate a new set of LB data files that contains a new mapping of object to processor
\end{DoxyItemize}
\item Run the program with the {\ttfamily L\+B\+Data\+Restart\+Reader} to test this new mapping on the actual application
\begin{DoxyItemize}
\item Using the options {\ttfamily -\/-\/vt\+\_\+lb\+\_\+data\+\_\+dir\+\_\+in=inputdir -\/-\/vt\+\_\+lb\+\_\+data\+\_\+file\+\_\+in=filename} 
\end{DoxyItemize}
\end{DoxyItemize}