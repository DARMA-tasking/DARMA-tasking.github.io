Overview of functionality in {\bfseries {\itshape vt}}\hypertarget{introduction_what-is}{}\section{What is vt?}\label{introduction_what-is}
{\bfseries {\itshape vt}} is an active messaging layer that utilizes C++ object virtualization to manage virtual endpoints with automatic location management. {\bfseries {\itshape vt}} is directly built on top of M\+PI to provide efficient portability across different machine architectures. Empowered with virtualization, {\bfseries {\itshape vt}} can automatically perform dynamic load balancing to schedule scientific applications across diverse platforms with minimal user input.

{\bfseries {\itshape vt}} abstracts the concept of a {\ttfamily node}/{\ttfamily rank}/{\ttfamily worker}/{\ttfamily thread} so a program can be written in terms of virtual entities that are location independent. Thus, they can be automatically migrated and thereby executed on varying hardware resources without explicit programmer mapping, location, and communication management.\hypertarget{introduction_vt-features}{}\section{Features in vt}\label{introduction_vt-features}

\begin{DoxyItemize}
\item Active messaging to type-\/safe handlers across nodes
\item Groups for scalable construction of node subsets
\item Optional serialization of messages
\item Termination detection across all work or subsets of work with {\itshape epochs} 
\item Opaque callbacks/pipes to generalized endpoints
\item Efficient memory pooling for message allocation
\item R\+D\+MA using M\+PI one-\/sided for data transfer
\item Asynchronous Collectives across nodes/groups (scatter, async barrier, reduce, ...)
\item General scheduler with prioritization
\item Built-\/in interoperability with M\+PI and threading libraries (Kokkos, Open\+MP, ...)
\item Object groups for node-\/level encapsulation
\item Virtual contexts for migratable virtualization and dispatch
\item Abstractions for multi-\/dimensional indices, mapping, and linearization
\item Virtual collections (dense, sparse, dynamic insertable) for decomposing domains
\item Fully distributed load balancer for virtual entities
\end{DoxyItemize}\hypertarget{introduction_vt-components}{}\section{Components in vt}\label{introduction_vt-components}
\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Component }&\textbf{ Singleton }&\textbf{ Details }&\textbf{ Type  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Component }&\textbf{ Singleton }&\textbf{ Details }&\textbf{ Type  }\\\cline{1-4}
\endhead
\hyperlink{context}{Context} &{\ttfamily \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt\+::the\+Context()}} &Node-\/aware context. & {\bfseries Core} \\\cline{1-4}
\hyperlink{active-messenger}{Active Messenger} &{\ttfamily \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt\+::the\+Msg()}} &Asynchronous send/receive of messages. & {\bfseries Core} \\\cline{1-4}
\hyperlink{collection}{Virtual Context Collection} &{\ttfamily \hyperlink{namespacevt_a1c45ce63bfd2c327ff7d76a319a371d8}{vt\+::the\+Collection()}} &Collection of tasks. & {\bfseries Core} \\\cline{1-4}
\hyperlink{collective}{Collectives} &{\ttfamily \hyperlink{namespacevt_aa8e0c0ab253e7ad1acd5d09e36fea769}{vt\+::the\+Collective()}} &Collective operations. & {\bfseries Core} \\\cline{1-4}
\hyperlink{event}{Event Manager} &{\ttfamily \hyperlink{namespacevt_aa297fcaadc8a330890eb90c5b0081ec5}{vt\+::the\+Event()}} &Manage asynchronous events. & {\bfseries Core} \\\cline{1-4}
\hyperlink{group}{Group Manager} &{\ttfamily \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt\+::the\+Group()}} &Create a grouping of nodes. & {\bfseries Core} \\\cline{1-4}
\hyperlink{lb-manager}{LB Manager} &{\ttfamily \hyperlink{namespacevt_a05187076eac8c66c9951b062b0955520}{vt\+::the\+L\+B\+Manager()}} &Manage load balancers. & {\bfseries Optional} \\\cline{1-4}
\hyperlink{location}{Location Manager} &{\ttfamily \hyperlink{namespacevt_ace1c9d64e09732e3b7414d02517ecfdb}{vt\+::the\+Loc\+Man()}} &Virtual entity location management. & {\bfseries Core} \\\cline{1-4}
\hyperlink{mem-usage}{Memory Usage Tracker} &{\ttfamily \hyperlink{namespacevt_a38d485d3cf840b9a623e47e7754ef72e}{vt\+::the\+Mem\+Usage()}} &Track memory usage. & {\bfseries Optional} \\\cline{1-4}
\hyperlink{objgroup}{Object Group Manager} &{\ttfamily \hyperlink{namespacevt_a833f0115b692f578167cbd88e30d39c5}{vt\+::the\+Obj\+Group()}} &Create object instances across nodes. & {\bfseries Core} \\\cline{1-4}
\hyperlink{param}{Parameterization} &{\ttfamily \hyperlink{namespacevt_a268431014c9031c0f7c33d32c1b8645c}{vt\+::the\+Param()}} &Handler parameterization. & {\bfseries Experimental} \\\cline{1-4}
\hyperlink{pipe}{Pipe Manager} &{\ttfamily \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt\+::the\+C\+B()}} &Create opaque callback endpoints. & {\bfseries Core} \\\cline{1-4}
\hyperlink{node-stats}{Node Statistics} &{\ttfamily \hyperlink{namespacevt_ae1526efa346612ad330d9a628e596c54}{vt\+::the\+Node\+Stats()}} &Manager object profiling data. & {\bfseries Optional} \\\cline{1-4}
\hyperlink{pool}{Memory Pool} &{\ttfamily \hyperlink{namespacevt_aab3530d89a64e5ea903b0ccf303ecbb7}{vt\+::the\+Pool()}} &Memory pool for efficient allocation. & {\bfseries Core} \\\cline{1-4}
\hyperlink{rdma}{R\+D\+MA Manager} &{\ttfamily \hyperlink{namespacevt_a68b8410bc2b86d3b5228d7dbb6b40bac}{vt\+::the\+R\+D\+M\+A()}} &Node-\/level R\+D\+MA. & {\bfseries Experimental} \\\cline{1-4}
\hyperlink{rdmahandle}{R\+D\+MA Handle Manager} &{\ttfamily \hyperlink{namespacevt_aecb87ec2c40b5b7fc57ba4cf8ea838b0}{vt\+::the\+Handle\+R\+D\+M\+A()}} &R\+D\+MA handles backed by M\+PI. & {\bfseries Optional} \\\cline{1-4}
\hyperlink{registry}{Registry} &{\ttfamily \hyperlink{namespacevt_a8b5994a5aedabc64006ce820db2e938c}{vt\+::the\+Registry()}} &Registered handlers. & {\bfseries Core} \\\cline{1-4}
\hyperlink{scheduler}{Scheduler} &{\ttfamily \hyperlink{namespacevt_a4508b38e6ab664b64f1415aecbb83571}{vt\+::the\+Sched()}} &General scheduling of work. & {\bfseries Core} \\\cline{1-4}
\hyperlink{seq}{Sequencer} &{\ttfamily \hyperlink{namespacevt_a4a7d07c845b311da59286de486d623c7}{vt\+::the\+Seq()}} &Sequence node actions. & {\bfseries Experimental} \\\cline{1-4}
\hyperlink{vrtseq}{Virtual Sequencer} &{\ttfamily \hyperlink{namespacevt_abdbb9ddb0d79b35c89e9d742d3fc9d42}{vt\+::the\+Virtual\+Seq()}} &Sequence task actions. & {\bfseries Experimental} \\\cline{1-4}
\hyperlink{term}{Termination Detector} &{\ttfamily \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt\+::the\+Term()}} &Detect termination of work. & {\bfseries Core} \\\cline{1-4}
\hyperlink{time-trigger}{Time Triggers} &{\ttfamily \hyperlink{namespacevt_a1e1a39cdf2a3fc1adefcdfcca4716bf2}{vt\+::the\+Time\+Trigger()}} &Time-\/based progress actions. & {\bfseries Optional} \\\cline{1-4}
\hyperlink{trace}{Tracing} &{\ttfamily vt\+::the\+Trace()} &Trace distributed events. & {\bfseries Optional} \\\cline{1-4}
\hyperlink{stats-reader}{LB Restart Reader} &{\ttfamily \hyperlink{namespacevt_ad73860100c7d2ca1d833eab74942ee73}{vt\+::the\+Stats\+Reader()}} &Follow input LB distribution. & {\bfseries Optional} \\\cline{1-4}
\end{longtabu}
\hypertarget{introduction_how-to-build-intro}{}\section{How to build}\label{introduction_how-to-build-intro}
{\bfseries {\itshape vt}} can be built with cmake or inside a docker container. Learn \hyperlink{vt-build}{How to Build}\hypertarget{introduction_vt-hello-world}{}\section{Hello World Example}\label{introduction_vt-hello-world}
  
\begin{DoxyCode}
\textcolor{keywordtype}{bool} done = \textcolor{keyword}{false};

\textcolor{keyword}{struct }HelloMsg : \hyperlink{structvt_1_1messaging_1_1_active_msg}{vt::Message} \{
  HelloMsg(\hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} in\_from) : from(in\_from) \{ \}
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} from = 0;
\};

\textcolor{keywordtype}{void} hello\_world(HelloMsg* msg) \{
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  fmt::print(\textcolor{stringliteral}{"\{\}: Hello from node \{\}\(\backslash\)n"}, this\_node, msg->from);
  done = \textcolor{keyword}{true};
\}

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_aaa266774ea8339c58be0202b00fafa62}{vt::initialize}(argc, arv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    \textcolor{keyword}{auto} msg = vt::makeMessage<HelloMsg>(this\_node);
    \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__typesafehan_ga4a7106231ba8a26a1214a6f133e381eb}{broadcastMsg}<HelloMsg, hello\_world>(msg.get());
    done = \textcolor{keyword}{true};
  \}

  \textcolor{comment}{// Run the scheduler until all nodes are done}
  vt::runSchedulerWhile([]\{ \textcolor{keywordflow}{return} !done; \});

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();
  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


Running\+:


\begin{DoxyCode}
$ mpirun -n 4 ./hello\_world
\end{DoxyCode}


Output\+: 
\begin{DoxyCode}
3: Hello from node 0
1: Hello from node 0
2: Hello from node 0
\end{DoxyCode}


\begin{DoxyNote}{Note}
An active message broadcast sends to all nodes except for the sender (root of the broadcast). 
\end{DoxyNote}
\hypertarget{introduction_License}{}\section{License}\label{introduction_License}


Copyright 2019 National Technology \& Engineering Solutions of Sandia, L\+LC (N\+T\+E\+SS). Under the terms of Contract D\+E-\/\+N\+A0003525 with N\+T\+E\+SS, the U.\+S. Government retains certain rights in this software.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met\+:


\begin{DoxyItemize}
\item Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
\item Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
\item Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
\end{DoxyItemize}

T\+H\+IS S\+O\+F\+T\+W\+A\+RE IS P\+R\+O\+V\+I\+D\+ED BY T\+HE C\+O\+P\+Y\+R\+I\+G\+HT H\+O\+L\+D\+E\+RS A\+ND C\+O\+N\+T\+R\+I\+B\+U\+T\+O\+RS \char`\"{}\+A\+S I\+S\char`\"{} A\+ND A\+NY E\+X\+P\+R\+E\+SS OR I\+M\+P\+L\+I\+ED W\+A\+R\+R\+A\+N\+T\+I\+ES, I\+N\+C\+L\+U\+D\+I\+NG, B\+UT N\+OT L\+I\+M\+I\+T\+ED TO, T\+HE I\+M\+P\+L\+I\+ED W\+A\+R\+R\+A\+N\+T\+I\+ES OF M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY A\+ND F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE A\+RE D\+I\+S\+C\+L\+A\+I\+M\+ED. IN NO E\+V\+E\+NT S\+H\+A\+LL T\+HE C\+O\+P\+Y\+R\+I\+G\+HT O\+W\+N\+ER OR C\+O\+N\+T\+R\+I\+B\+U\+T\+O\+RS BE L\+I\+A\+B\+LE F\+OR A\+NY D\+I\+R\+E\+CT, I\+N\+D\+I\+R\+E\+CT, I\+N\+C\+I\+D\+E\+N\+T\+AL, S\+P\+E\+C\+I\+AL, E\+X\+E\+M\+P\+L\+A\+RY, OR C\+O\+N\+S\+E\+Q\+U\+E\+N\+T\+I\+AL D\+A\+M\+A\+G\+ES (I\+N\+C\+L\+U\+D\+I\+NG, B\+UT N\+OT L\+I\+M\+I\+T\+ED TO, P\+R\+O\+C\+U\+R\+E\+M\+E\+NT OF S\+U\+B\+S\+T\+I\+T\+U\+TE G\+O\+O\+DS OR S\+E\+R\+V\+I\+C\+ES; L\+O\+SS OF U\+SE, D\+A\+TA, OR P\+R\+O\+F\+I\+TS; OR B\+U\+S\+I\+N\+E\+SS I\+N\+T\+E\+R\+R\+U\+P\+T\+I\+ON) H\+O\+W\+E\+V\+ER C\+A\+U\+S\+ED A\+ND ON A\+NY T\+H\+E\+O\+RY OF L\+I\+A\+B\+I\+L\+I\+TY, W\+H\+E\+T\+H\+ER IN C\+O\+N\+T\+R\+A\+CT, S\+T\+R\+I\+CT L\+I\+A\+B\+I\+L\+I\+TY, OR T\+O\+RT (I\+N\+C\+L\+U\+D\+I\+NG N\+E\+G\+L\+I\+G\+E\+N\+CE OR O\+T\+H\+E\+R\+W\+I\+SE) A\+R\+I\+S\+I\+NG IN A\+NY W\+AY O\+UT OF T\+HE U\+SE OF T\+H\+IS S\+O\+F\+T\+W\+A\+RE, E\+V\+EN IF A\+D\+V\+I\+S\+ED OF T\+HE P\+O\+S\+S\+I\+B\+I\+L\+I\+TY OF S\+U\+CH D\+A\+M\+A\+GE. \hypertarget{context}{}\section{Context}\label{context}
Node-\/aware context

The context component {\ttfamily \hyperlink{structvt_1_1ctx_1_1_context}{vt\+::ctx\+::\+Context}}, accessed via {\ttfamily \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt\+::the\+Context()}}, provides context-\/aware querying of the current node (analogous to M\+PI\textquotesingle{}s {\ttfamily M\+P\+I\+\_\+\+Comm\+\_\+rank}), number of nodes (analogous to M\+PI\textquotesingle{}s {\ttfamily M\+P\+I\+\_\+\+Comm\+\_\+size}), and kernel threading/\+U\+LT information if worker threads are enabled. The context also provides the M\+PI communicator that an instance of {\bfseries {\itshape vt}} is currently using.

Used to obtain the current node and other context where a handler executes. Context is a core VT component that provides the ability to pass initialization arguments (through the {\ttfamily vt\+::\+Runtime}) and obtain info about the node on which a handler is executing or the number of nodes. It provides functionality analogous to {\ttfamily M\+P\+I\+\_\+\+Comm\+\_\+size} and {\ttfamily M\+P\+I\+\_\+\+Comm\+\_\+rank}.

Gets the current node (analagous to M\+PI\textquotesingle{}s rank) currently being used.

To get the current node, one may query this method\+:


\begin{DoxyCode}
\hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
\end{DoxyCode}


Get the number of nodes (analagous to M\+PI\textquotesingle{}s num ranks) being used.

To get the number of nodes or ranks that an instance of {\bfseries {\itshape vt}} is using, one may query this method\+:


\begin{DoxyCode}
\hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();
\end{DoxyCode}


\begin{DoxyNote}{Note}
The result from {\ttfamily get\+Node} or {\ttfamily get\+Num\+Nodes} will depend on the communicator that was passed to VT during initialization. 
\end{DoxyNote}
\hypertarget{active-messenger}{}\section{Active Messenger}\label{active-messenger}
Asynchronous send/receive of messages

The active messenger {\ttfamily \hyperlink{structvt_1_1messaging_1_1_active_messenger}{vt\+::messaging\+::\+Active\+Messenger}}, accessed via {\ttfamily \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt\+::the\+Msg()}}, asynchronously sends and receives messages across nodes using M\+PI internally. When sending a message, it uses the {\bfseries {\itshape vt}} registry to consistently dispatch messages and data to handlers (function pointers, functors, or methods) across nodes.

Each message contains an envelope {\ttfamily \hyperlink{namespacevt_aa9c8cc094b5361482021d63012987814}{vt\+::\+Envelope}} to store meta-\/data associated with the message, such as the destination and handler to trigger when it arrives. Sending a message entails setting up the envelope, optionally serializing the message (depending on whether the serialize overload is present), and then using {\ttfamily M\+P\+I\+\_\+\+Isend} to asynchronously transfer the bytes to the destination node. On the receive side, the active messenger is always probing for an incoming message and begins a transfer when it discovers one. The {\bfseries {\itshape vt}} \hyperlink{scheduler}{Scheduler} polls the active messenger to make progress on any incoming messages.\hypertarget{active-messenger_am-simple-example}{}\subsection{Sending a message}\label{active-messenger_am-simple-example}

\begin{DoxyCode}
\textcolor{preprocessor}{#include <\hyperlink{transport_8h}{vt/transport.h}>}

\textcolor{preprocessor}{#include <vector>}

\textcolor{comment}{// Declare a serializable message}
\textcolor{keyword}{struct }MyMsg : \hyperlink{structvt_1_1messaging_1_1_active_msg}{vt::Message} \{
  \textcolor{keyword}{using} MessageParentType = \hyperlink{namespacevt_a3a3ddfef40b4c90915fa43cdd5f129ea}{vt::Message};
  \hyperlink{message__serialize_8h_a54128d5338aaa9c918179826085e13d1}{vt\_msg\_serialize\_required}(); \textcolor{comment}{// for vector}

  MyMsg() = \textcolor{keywordflow}{default}; \textcolor{comment}{// default constructor for de-serialize}
  MyMsg(\textcolor{keywordtype}{int} in\_val, std::vector<double> \textcolor{keyword}{const}& in\_vec)
    : val(in\_val),
      my\_vec(in\_vec)
  \{ \}

  \textcolor{keyword}{template} <\textcolor{keyword}{typename} SerializerT>
  \textcolor{keywordtype}{void} \hyperlink{structvt_1_1messaging_1_1_active_msg_a758f02bef5991c48d6c9a56c30ca7ad9}{serialize}(SerializerT& s) \{
    \hyperlink{namespacevt_1_1vrt_1_1collection_1_1balance_a783d95de203cabd0f599440e9869c313}{MessageParentType::serialize}(s);
    s | val;
    s | my\_vec;
  \}

  \textcolor{keywordtype}{int} val = 0;
  std::vector<double> my\_vec;
\};

\textcolor{comment}{// Active function pointer}
\textcolor{keywordtype}{void} myHandler(MyMsg* m) \{
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  fmt::print(\textcolor{stringliteral}{"\{\}: val=\{\}, vec size=\{\}\(\backslash\)n"}, this\_node, m->val, m->my\_vec.size());
\}

\textcolor{comment}{// Active functor}
\textcolor{keyword}{struct }MyFunctor \{
  \textcolor{keywordtype}{void} operator()(MyMsg* m) \{
    \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
    fmt::print(\textcolor{stringliteral}{"\{\}: val=\{\}, vec size=\{\}\(\backslash\)n"}, this\_node, m->val, m->my\_vec.size());
  \}
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_aaa266774ea8339c58be0202b00fafa62}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    \textcolor{comment}{// spins in scheduler until termination of the enclosed work}
    \hyperlink{namespacevt_ad419c00d2e4ac8601ea3b1dec633f3f7}{vt::runInEpochRooted}([=]\{
      std::vector<double> vec\_to\_send;
      vec\_to\_send.push\_back(29.);
      vec\_to\_send.push\_back(54.);

      \textcolor{keyword}{auto} msg = vt::makeMessage<MyMsg>(10, vec\_to\_send);
      \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_gaebfcd932babb3be0ea8d481f655a2835}{sendMsg}<MyMsg, myHandler>(1, msg.get()); \textcolor{comment}{// send to node 1}

      \textcolor{keyword}{auto} msg2 = vt::makeMessage<MyMsg>(11, vec\_to\_send);
      \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_gaebfcd932babb3be0ea8d481f655a2835}{sendMsg}<MyFunctor>(1, msg2.get());  \textcolor{comment}{// send to node 1}
    \});
  \}

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();
  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


Program output\+:


\begin{DoxyCode}
1: val=10, vec size=2
1: val=11, vec size=2
\end{DoxyCode}
 \hypertarget{collection}{}\section{Virtual Context Collection}\label{collection}
Collection of tasks

The virtual context collection component {\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_manager}{vt\+::vrt\+::collection\+::\+Collection\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a1c45ce63bfd2c327ff7d76a319a371d8}{vt\+::the\+Collection()}} is a core VT component that manages multi-\/dimensional collections of {\itshape virtual context} (or a migratable C++ object registered with {\bfseries {\itshape vt}}) elements. It manages the creation, deletion, and messaging across elements at runtime supporting dense, sparse, on-\/demand, and staged insert modes. It utilizes the \hyperlink{location}{Location Manager} to manage the location of these elements to efficiently deliver messages. It also utilizes the \hyperlink{group}{Group Manager} to build a spanning tree across the nodes that the collection is currently mapped to. This group makes broadcasts efficient and allows reductions to make progress without waiting for nodes that do not have collection elements. The proc-\/stats component stores the statistics for live collections that then passes the instrumented data to the \hyperlink{lb-manager}{LB Manager} component to apply load balancing strategies.\hypertarget{collection_rooted-hello-world-collection}{}\subsection{Hello World 1\+D Dense Collection (\+Rooted)}\label{collection_rooted-hello-world-collection}

\begin{DoxyCodeInclude}
\textcolor{keyword}{struct }Hello : \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection}{vt::Collection}<Hello, vt::Index1D> \{
  Hello() = \textcolor{keywordflow}{default};

  \textcolor{keyword}{virtual} ~Hello() \{
    \hyperlink{config__assert_8h_aeddd4990a496e91a0ca5d6c16437359b}{vtAssert}(counter\_ == 1, \textcolor{stringliteral}{"Must be equal"});
  \}

  \textcolor{keyword}{using} TestMsg = \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_message}{vt::CollectionMessage<Hello>};

  \textcolor{keywordtype}{void} doWork(TestMsg* msg) \{
    fmt::print(\textcolor{stringliteral}{"Hello from \{\}\(\backslash\)n"}, this->\hyperlink{structvt_1_1vrt_1_1collection_1_1_indexable_a28d05f23e7a20e12e94b8235305c1e82}{getIndex}());
    counter\_++;
  \}

\textcolor{keyword}{private}:
  int32\_t counter\_ = 0;
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_aaa266774ea8339c58be0202b00fafa62}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();

  \textcolor{keywordtype}{int} num\_elms = 64;

  \textcolor{keywordflow}{if} (argc > 1) \{
    num\_elms = atoi(argv[1]);
  \}

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    \textcolor{keyword}{auto} range = \hyperlink{namespacevt_a5540efc78234273e1796fb003fe4d234}{vt::Index1D}(num\_elms);
    \textcolor{keyword}{auto} proxy = \hyperlink{namespacevt_a1c45ce63bfd2c327ff7d76a319a371d8}{vt::theCollection}()->\hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_manager_a4de84e9efd7a3948e3c20be549441cfd}{construct}<Hello>(range);
    proxy.broadcast<Hello::TestMsg,&Hello::doWork>();
  \}

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
 \hypertarget{collection_collective-hello-world-collection}{}\subsection{Hello World 1\+D Dense Collection (\+Collective)}\label{collection_collective-hello-world-collection}

\begin{DoxyCodeInclude}
\textcolor{keyword}{struct }Hello : \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection}{vt::Collection}<Hello, vt::Index1D> \{
  Hello() = \textcolor{keywordflow}{default};

  \textcolor{keyword}{virtual} ~Hello() \{
    \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();
    \hyperlink{config__assert_8h_aeddd4990a496e91a0ca5d6c16437359b}{vtAssert}(counter\_ == num\_nodes, \textcolor{stringliteral}{"Should receive # nodes broadcasts"});
  \}

  \textcolor{keyword}{using} TestMsg = \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_message}{vt::CollectionMessage<Hello>};

  \textcolor{keywordtype}{void} doWork(TestMsg* msg) \{
    counter\_++;
    fmt::print(\textcolor{stringliteral}{"Hello from \{\}, counter\_=\{\}\(\backslash\)n"}, this->\hyperlink{structvt_1_1vrt_1_1collection_1_1_indexable_a28d05f23e7a20e12e94b8235305c1e82}{getIndex}().x(), counter\_);
  \}

\textcolor{keyword}{private}:
  \textcolor{keywordtype}{int} counter\_ = 0;
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_aaa266774ea8339c58be0202b00fafa62}{vt::initialize}(argc, argv);

  int32\_t num\_elms = 16;
  \textcolor{keywordflow}{if} (argc > 1) \{
    num\_elms = atoi(argv[1]);
  \}

  \textcolor{keyword}{auto} range = \hyperlink{namespacevt_a5540efc78234273e1796fb003fe4d234}{vt::Index1D}(num\_elms);
  \textcolor{keyword}{auto} proxy = \hyperlink{namespacevt_a1c45ce63bfd2c327ff7d76a319a371d8}{vt::theCollection}()->\hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_manager_a619d6e576f0d108e442b16ca4f68f1f3}{constructCollective}<Hello>(
    range, [](\hyperlink{namespacevt_a5540efc78234273e1796fb003fe4d234}{vt::Index1D})\{ \textcolor{keywordflow}{return} std::make\_unique<Hello>(); \}
  );

  \textcolor{comment}{// All nodes send a broadcast to all elements}
  proxy.broadcast<Hello::TestMsg,&Hello::doWork>();

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
 \hypertarget{collection_reduce-hello-world-collection}{}\subsection{Hello World 1\+D Collection Reduce}\label{collection_reduce-hello-world-collection}

\begin{DoxyCodeInclude}
\textcolor{keyword}{struct }Hello : \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection}{vt::Collection}<Hello, vt::Index1D> \{
  \textcolor{keyword}{using} ReduceMsg = \hyperlink{structvt_1_1collective_1_1reduce_1_1operators_1_1_reduce_t_msg}{vt::collective::ReduceTMsg<int>};

  \textcolor{keywordtype}{void} done(ReduceMsg* msg) \{
    fmt::print(\textcolor{stringliteral}{"Reduce complete at \{\} value \{\}\(\backslash\)n"}, this->\hyperlink{structvt_1_1vrt_1_1collection_1_1_indexable_a28d05f23e7a20e12e94b8235305c1e82}{getIndex}(), msg->getVal());
  \}

  \textcolor{keyword}{using} TestMsg = \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_message}{vt::CollectionMessage<Hello>};

  \textcolor{keywordtype}{void} doWork(TestMsg* msg) \{
    fmt::print(\textcolor{stringliteral}{"Hello from \{\}\(\backslash\)n"}, this->\hyperlink{structvt_1_1vrt_1_1collection_1_1_indexable_a28d05f23e7a20e12e94b8235305c1e82}{getIndex}());

    \textcolor{comment}{// Get the proxy for the collection}
    \textcolor{keyword}{auto} proxy = this->\hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_base_ad97d9ab1a28fb535c5d7f82c15e99791}{getCollectionProxy}();

    \textcolor{comment}{// Create a callback for when the reduction finishes}
    \textcolor{keyword}{auto} cb = \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt::theCB}()->\hyperlink{structvt_1_1pipe_1_1_pipe_manager_a73583be6260418b13ee66e56cdade2da}{makeSend}<Hello,\hyperlink{namespacevt_1_1collective_a4c5bf7769ad4396573d6bcc85ec430a4}{ReduceMsg},&Hello::done>(proxy(2));

    \textcolor{comment}{// Create and send the reduction message holding an int}
    \textcolor{keyword}{auto} red\_msg = vt::makeMessage<ReduceMsg>(this->\hyperlink{structvt_1_1vrt_1_1collection_1_1_indexable_a28d05f23e7a20e12e94b8235305c1e82}{getIndex}().x());
    proxy.reduce<\hyperlink{structvt_1_1collective_1_1reduce_1_1operators_1_1_plus_op}{vt::collective::PlusOp<int>}>(red\_msg.get(),cb);
  \}
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_aaa266774ea8339c58be0202b00fafa62}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();

  int32\_t num\_elms = 16;
  \textcolor{keywordflow}{if} (argc > 1) \{
    num\_elms = atoi(argv[1]);
  \}

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    \textcolor{keyword}{auto} range = \hyperlink{namespacevt_a5540efc78234273e1796fb003fe4d234}{vt::Index1D}(num\_elms);
    \textcolor{keyword}{auto} proxy = \hyperlink{namespacevt_a1c45ce63bfd2c327ff7d76a319a371d8}{vt::theCollection}()->\hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_manager_a4de84e9efd7a3948e3c20be549441cfd}{construct}<Hello>(range);
    proxy.broadcast<Hello::TestMsg,&Hello::doWork>();
  \}

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
 \hypertarget{collection_staged-insert-hello-world-collection}{}\subsection{Hello World 1\+D Collection Staged Insert}\label{collection_staged-insert-hello-world-collection}

\begin{DoxyCodeInclude}
\textcolor{keyword}{struct }Hello : \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection}{vt::Collection}<Hello, vt::Index1D> \{

  \textcolor{comment}{// Default constructor for migration}
  Hello() = \textcolor{keywordflow}{default};

  \textcolor{comment}{// Constructor used during insertion}
  \textcolor{keyword}{explicit} Hello(std::string \textcolor{keyword}{const}& input\_string)
    : in(input\_string)
  \{ \}

  \textcolor{keyword}{virtual} ~Hello() \{
    \hyperlink{config__assert_8h_aeddd4990a496e91a0ca5d6c16437359b}{vtAssert}(counter\_ == 1, \textcolor{stringliteral}{"Must be equal"});
  \}

  \textcolor{keyword}{using} TestMsg = \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_message}{vt::CollectionMessage<Hello>};

  \textcolor{keywordtype}{void} doWork(TestMsg* msg) \{
    counter\_++;

    \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
    fmt::print(\textcolor{stringliteral}{"\{\}: Hello from \{\}: \{\}\(\backslash\)n"}, this\_node, this->\hyperlink{structvt_1_1vrt_1_1collection_1_1_indexable_a28d05f23e7a20e12e94b8235305c1e82}{getIndex}(), in);
  \}

\textcolor{keyword}{private}:
  \textcolor{keywordtype}{int} counter\_ = 0;
  std::string in;
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_aaa266774ea8339c58be0202b00fafa62}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keywordtype}{int} num\_elms = 32;
  \textcolor{keywordflow}{if} (argc > 1) \{
    num\_elms = atoi(argv[1]);
  \}

  \textcolor{keyword}{auto} range = \hyperlink{namespacevt_a5540efc78234273e1796fb003fe4d234}{vt::Index1D}(num\_elms);
  \textcolor{keyword}{auto} token = \hyperlink{namespacevt_a1c45ce63bfd2c327ff7d76a319a371d8}{vt::theCollection}()->\hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_manager_a0e15cc861c0d979d8977b226efd7c271}{constructInsert}<Hello>(range);

  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_elms; i++) \{
    \textcolor{comment}{// Insert even elements, round-robin the insertions from each node}
    \textcolor{keywordflow}{if} ((i / 2) % num\_nodes == this\_node and i % 2 == 0) \{
      \textcolor{keyword}{auto} str = fmt::format(\textcolor{stringliteral}{"inserted from \{\}"}, this\_node);

      \textcolor{comment}{// Construct the i'th element on this node, passing str to the constructor}
      token[i].insert(str);
    \}
  \}

  \textcolor{comment}{// Finish all inserts on this node by invalidating the insert token}
  \textcolor{keyword}{auto} proxy = \hyperlink{namespacevt_a1c45ce63bfd2c327ff7d76a319a371d8}{vt::theCollection}()->\hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_manager_a9275a4f6a7c33389813ba7fe4cc75d7e}{finishedInsert}(std::move(token));

  \textcolor{keywordflow}{if} (this\_node == 1) \{
    proxy.broadcast<Hello::TestMsg,&Hello::doWork>();
  \}

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
\hypertarget{collective}{}\section{Collectives}\label{collective}
Collective operations

The collective component {\ttfamily \hyperlink{structvt_1_1collective_1_1_collective_alg}{vt\+::collective\+::\+Collective\+Alg}}, accessed via {\ttfamily \hyperlink{namespacevt_aa8e0c0ab253e7ad1acd5d09e36fea769}{vt\+::the\+Collective()}} implements active-\/message-\/based distributed collectives over the {\bfseries {\itshape vt}} runtime. It performs asynchronous reductions, scatters, barriers, and allows one to safely use M\+PI interspersed through {\bfseries {\itshape vt}} code, while running in a handler.\hypertarget{collective_collective-reductions}{}\subsection{Reductions}\label{collective_collective-reductions}
{\bfseries {\itshape vt}} comes with several reduction operators built in that can operate over types where the operator already applies (like integers, doubles, etc.) or user-\/defined overloaded operators. These operators also have specializations for {\ttfamily std\+::vector$<$T$>$} and {\ttfamily std\+::array$<$T$>$}.

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Operator }&\textbf{ Reference  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Operator }&\textbf{ Reference  }\\\cline{1-2}
\endhead
operator\&\& &{\ttfamily \hyperlink{namespacevt_1_1collective_ae6f54eb36ce2d4203174e55167c4cd87}{vt\+::collective\+::\+And\+Op}} \\\cline{1-2}
operator$|$$|$ &{\ttfamily \hyperlink{namespacevt_1_1collective_a47e3b11aa019f643f23effceb60ee94a}{vt\+::collective\+::\+Or\+Op}} \\\cline{1-2}
operator+ &{\ttfamily \hyperlink{namespacevt_1_1collective_a7a695a8e6ed8247f643918113b7bf881}{vt\+::collective\+::\+Plus\+Op}} \\\cline{1-2}
std\+::min &{\ttfamily \hyperlink{namespacevt_1_1collective_a0d9f013f61a3e2a15a9e0491409f50f2}{vt\+::collective\+::\+Min\+Op}} \\\cline{1-2}
std\+::max &{\ttfamily \hyperlink{namespacevt_1_1collective_aee17b1e7ed3266f7407f01253ecc2807}{vt\+::collective\+::\+Max\+Op}} \\\cline{1-2}
operator\& &{\ttfamily \hyperlink{namespacevt_1_1collective_a64c800cae2fcb4ec24d2c5540cca0f9e}{vt\+::collective\+::\+Bit\+And\+Op}} \\\cline{1-2}
operator$|$ &{\ttfamily \hyperlink{namespacevt_1_1collective_a07085d466f47337de6f1d6ea30023c11}{vt\+::collective\+::\+Bit\+Or\+Op}} \\\cline{1-2}
operator$^\wedge$ &{\ttfamily \hyperlink{namespacevt_1_1collective_a834c8e21559219187ec9ef79f72cf474}{vt\+::collective\+::\+Bit\+Xor\+Op}} \\\cline{1-2}
$<$no-\/operator$>$ &{\ttfamily \hyperlink{namespacevt_1_1collective_a812e9225d75c8888457b29f971c33f75}{vt\+::collective\+::\+None\+Op}} \\\cline{1-2}
\end{longtabu}
\hypertarget{collective_collective-reduce-example}{}\subsubsection{A Simple Reduction}\label{collective_collective-reduce-example}

\begin{DoxyCode}
\textcolor{preprocessor}{#include <\hyperlink{transport_8h}{vt/transport.h}>}

\textcolor{comment}{// Reduce ints}
\textcolor{keyword}{struct }ReduceDataMsg : \hyperlink{structvt_1_1collective_1_1reduce_1_1operators_1_1_reduce_t_msg}{vt::collective::ReduceTMsg}<int> \{
  \textcolor{keyword}{explicit} ReduceDataMsg(\textcolor{keywordtype}{int} val)
    : \hyperlink{namespacevt}{vt}::collective::\hyperlink{namespacevt_1_1collective_a28b82d5d48c9bc6e4fd738fcbf9e0f62}{ReduceTMsg}<int>(val)
  \{ \}
\};

\textcolor{comment}{// Handler to target for reduction}
\textcolor{keyword}{struct }ReduceResult \{
  \textcolor{keywordtype}{void} operator()(ReduceDataMsg* msg) \{
    \textcolor{keyword}{auto} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();
    \textcolor{keyword}{auto} \hyperlink{namespacevt_ad3ca3e8710dd3c8badff897f8de3c858}{output} = msg->getConstVal();
    fmt::print(\textcolor{stringliteral}{"reduction value=\{\}\(\backslash\)n"}, \hyperlink{namespacevt_ad3ca3e8710dd3c8badff897f8de3c858}{output});
    \hyperlink{config__assert_8h_aeddd4990a496e91a0ca5d6c16437359b}{vtAssert}(num\_nodes * 50 == \hyperlink{namespacevt_ad3ca3e8710dd3c8badff897f8de3c858}{output}, \textcolor{stringliteral}{"Must be equal);}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{\};}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{int main(int argc, char** argv) \{}
\textcolor{stringliteral}{  vt::initialize(argc, argv);}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  auto reduce\_msg = vt::makeMessage<ReduceDataMsg>(50);}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  NodeType const root\_reduce\_node = 0;}
\textcolor{stringliteral}{  vt::theCollective()->global()->reduce<vt::collective::PlusOp<int>,ReduceResult>(}
\textcolor{stringliteral}{    root\_reduce\_node, reduce\_msg.get()}
\textcolor{stringliteral}{  );}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  vt::finalize(); // spins in scheduler until termination}
\textcolor{stringliteral}{  return 0;}
\textcolor{stringliteral}{\}}
\end{DoxyCode}
 \hypertarget{event}{}\section{Event Manager}\label{event}
Manage asynchronous events

The async event component {\ttfamily \hyperlink{structvt_1_1event_1_1_async_event}{vt\+::event\+::\+Async\+Event}}, accessed via {\ttfamily \hyperlink{namespacevt_aa297fcaadc8a330890eb90c5b0081ec5}{vt\+::the\+Event()}} manages local and remote events that complete asynchronously. One may create an event for a {\ttfamily M\+P\+I\+\_\+\+Request} so the scheduler tests the event as the scheduler polls. Once may also create other general events that have a unique ID that can be tested remotely. Parent events group sets of other events (parent, normal, or M\+PI events) together to test them for completion in a single operation. The event manager is mostly designed for internal {\bfseries {\itshape vt}} usage. \hypertarget{group}{}\section{Group Manager}\label{group}
Create a grouping of nodes

The group manager component {\ttfamily \hyperlink{structvt_1_1group_1_1_group_manager}{vt\+::group\+::\+Group\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt\+::the\+Group()}} manages both rooted and collective groups (or subsets) of nodes that can be broadcast to or reduced over. The group manager implements a fully distributed algorithm for constructing groups collectively with each node deciding if it should be included. The group manager builds a reasonably balanced distributed spanning tree based on these collective votes.

One major use case for the group manager is creating spanning trees for reductions over virtual collections that do not span all the nodes.

When creating a group, one may ask {\bfseries {\itshape vt}} to create a underlying M\+PI group, which can be accessed once the group has finished construction.\hypertarget{group_collective-group-example}{}\subsection{Example creating a collective group}\label{group_collective-group-example}

\begin{DoxyCodeInclude}
\textcolor{keyword}{struct }HelloGroupMsg : \hyperlink{structvt_1_1messaging_1_1_active_msg}{vt::Message} \{ \};

\textcolor{keyword}{static} \textcolor{keywordtype}{void} hello\_group\_handler(HelloGroupMsg* msg) \{
  fmt::print(\textcolor{stringliteral}{"\{\}: Hello from group handler\(\backslash\)n"}, \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->getNode());
\}

\textcolor{keyword}{using} ReduceMsg = \hyperlink{structvt_1_1collective_1_1reduce_1_1operators_1_1_reduce_t_msg}{vt::collective::ReduceTMsg<int>};

\textcolor{keyword}{struct }Print \{
  \textcolor{keywordtype}{void} operator()(ReduceMsg* msg) \{
    fmt::print(\textcolor{stringliteral}{"final value=\{\}\(\backslash\)n"}, msg->getConstVal());
  \}
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_aaa266774ea8339c58be0202b00fafa62}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keywordflow}{if} (num\_nodes < 2) \{
    \textcolor{keywordflow}{return} \hyperlink{namespacevt_aff96ace008dc847d4c0f44cfa5dfb3a0}{vt::rerror}(\textcolor{stringliteral}{"requires at least 2 nodes"});
  \}

  srand48(this\_node * 29);

  \textcolor{keywordtype}{bool} odd\_node\_filter = this\_node % 2 == 1;

  \hyperlink{namespacevt_a27b5e4411c9b6140c49100e050e2f743}{vt::GroupType} new\_group = \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt::theGroup}()->
      \hyperlink{structvt_1_1group_1_1_group_manager_a92b301d6cf77af7d57ed822c6f044d58}{newGroupCollective}(
    odd\_node\_filter, [=](\hyperlink{namespacevt_a27b5e4411c9b6140c49100e050e2f743}{vt::GroupType} group)\{
      \textcolor{keyword}{auto} \textcolor{keyword}{const}& root = 0;
      \textcolor{keyword}{auto} \textcolor{keyword}{const}& in\_group = \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt::theGroup}()->\hyperlink{structvt_1_1group_1_1_group_manager_a2204bcd119aaf06e0e356957faad36e6}{inGroup}(group);
      \textcolor{keyword}{auto} \textcolor{keyword}{const}& root\_node = \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt::theGroup}()->\hyperlink{structvt_1_1group_1_1_group_manager_ab5b8178a37165903c73f9159c9259cf5}{groupRoot}(group);
      \textcolor{keyword}{auto} \textcolor{keyword}{const}& is\_default\_group = \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt::theGroup}()->\hyperlink{structvt_1_1group_1_1_group_manager_ad4d55f7bcf2aadd97c858b3f11c5d365}{isGroupDefault}(group);
      fmt::print(
        \textcolor{stringliteral}{"\{\}: Group is created: group=\{:x\}, in\_group=\{\}, root=\{\}, "}
        \textcolor{stringliteral}{"is\_default\_group=\{\}\(\backslash\)n"},
        this\_node, group, in\_group, root\_node, is\_default\_group
      );
      \textcolor{keywordflow}{if} (in\_group) \{
        \textcolor{keyword}{using} Op = \hyperlink{structvt_1_1collective_1_1reduce_1_1operators_1_1_plus_op}{vt::collective::PlusOp<int>};
        \textcolor{keyword}{auto} msg = vt::makeMessage<ReduceMsg>(1);
        \hyperlink{namespacevt_a4548473dce44fb654400009e2b2fe64e}{vt::theGroup}()->\hyperlink{structvt_1_1group_1_1_group_manager_a3234e5be55c32ccfb56785265e26b4c6}{groupReducer}(group)->\hyperlink{structvt_1_1collective_1_1reduce_1_1_reduce_adf8bd9748a220a3ed29087c30f8adafc}{reduce}<Op, Print>(root, msg.get(
      ));
      \}
      \textcolor{keywordflow}{if} (this\_node == 1) \{
        \textcolor{keyword}{auto} msg = vt::makeMessage<HelloGroupMsg>();
        \hyperlink{namespacevt_a9f9d4ce6034c0eaaf98bdffd33d0e1c7}{vt::envelopeSetGroup}(msg->env, group);
        \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__typesafehan_ga4a7106231ba8a26a1214a6f133e381eb}{broadcastMsg}<HelloGroupMsg, hello\_group\_handler>(msg.get());
      \}
    \}
  );

  fmt::print(\textcolor{stringliteral}{"\{\}: New group=\{\}\(\backslash\)n"}, this\_node, new\_group);

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
\hypertarget{lb-manager}{}\section{LB Manager}\label{lb-manager}
Manage load balancers

The LB manager component {\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_l_b_manager}{vt\+::vrt\+::collection\+::balance\+::\+L\+B\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a05187076eac8c66c9951b062b0955520}{vt\+::the\+L\+B\+Manager()}} manages and coordinates instances of load balancers. It counts collections as they call {\ttfamily next\+Phase} to ensure they are all ready before load balancing begins. It reads the command-\/line arguments or LB specification file to determine which load balancer to run.

To enable load balancing, the cmake flag
\begin{DoxyCode}
-Dvt\_lb\_enabled=1
\end{DoxyCode}
 should be passed during building. This also enables automatic instrumentation of work and communication performed by collection elements.

To run a load balancer at runtime\+:
\begin{DoxyItemize}
\item Pass {\ttfamily -\/-\/vt\+\_\+lb -\/-\/vt\+\_\+lb\+\_\+name=$<$LB$>$} as a command line argument
\item Write a LB specification file {\ttfamily -\/-\/vt\+\_\+lb -\/-\/vt\+\_\+lb\+\_\+file\+\_\+name=$<$F\+I\+LE$>$}
\end{DoxyItemize}\hypertarget{lb-manager_lb-specification-file}{}\subsection{L\+B Specification File}\label{lb-manager_lb-specification-file}
The LB specification file allows users to specify which load balancer along with which L\+B-\/specific configuration parameters are passed to the load balancer instance for any given phase. The order of the LB phase specification lines in the file disambiguates lines---higher precedence for earlier lines.

The format of the LB specification file is\+:


\begin{DoxyCode}
[%] <$phase> <$lbname> [$LB-specific-arg-1] ... [$LB-specific-arg-N]
\end{DoxyCode}


If a {\ttfamily \%} is present, the line matches phases where\+: {\ttfamily current phase \% \$phase == 0}. Phase-\/specific lines (ones that specify a load balancer without a {\ttfamily \%}) always always have precedence over {\ttfamily \%} lines. The next token after the optional {\ttfamily \%} and {\ttfamily \$phase} is the name of the load balancer to invoke on that phase. After the load balancer name, {\ttfamily N} arguments to the load balancer are allowed to customize how the load balancer is run with the format of {\ttfamily key=value}. These arguments are the equivalent of passing {\ttfamily -\/-\/vt\+\_\+lb\+\_\+args=\char`\"{}\+A=test B=test2\char`\"{}} on the command line.

The following is an example LB specification\+:


\begin{DoxyCode}
%10 GossipLB c=1 k=5 f=2 i=10
0 HierarchicalLB min=0.9 max=1.1 auto=false
% 5 GreedyLB min=1.0
120 GreedyLB c=0 k=2 f=3 i=3
\end{DoxyCode}


To print LB specification during startup, use {\ttfamily -\/-\/vt\+\_\+lb\+\_\+show\+\_\+spec} command line flag.\hypertarget{lb-manager_load-balancers}{}\subsection{Load balancers}\label{lb-manager_load-balancers}
\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Load Balancer }&\textbf{ Type }&\textbf{ Description }&\textbf{ Reference  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Load Balancer }&\textbf{ Type }&\textbf{ Description }&\textbf{ Reference  }\\\cline{1-4}
\endhead
Rotate\+LB &Testing &Rotate objects in a ring &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1lb_1_1_rotate_l_b}{vt\+::vrt\+::collection\+::lb\+::\+Rotate\+LB}} \\\cline{1-4}
Random\+LB &Testing &Randomly migrate object with seed &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1lb_1_1_random_l_b}{vt\+::vrt\+::collection\+::lb\+::\+Random\+LB}} \\\cline{1-4}
Greedy\+LB &Centralized &Gather to central node apply min/max heap &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1lb_1_1_greedy_l_b}{vt\+::vrt\+::collection\+::lb\+::\+Greedy\+LB}} \\\cline{1-4}
Gossip\+LB &Distributed &Gossip-\/based protocol for fully distributed LB &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1lb_1_1_gossip_l_b}{vt\+::vrt\+::collection\+::lb\+::\+Gossip\+LB}} \\\cline{1-4}
Hierarchical\+LB &Hierarchical &Build tree to move objects nodes &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1lb_1_1_hierarchical_l_b}{vt\+::vrt\+::collection\+::lb\+::\+Hierarchical\+LB}} \\\cline{1-4}
Zotltan\+LB &Hyper-\/graph Partitioner &Run Zoltan in hyper-\/graph mode to LB &{\ttfamily vt\+::vrt\+::collection\+::lb\+::\+Zoltan\+LB} \\\cline{1-4}
Stats\+Map\+LB &User-\/specified &Read file to determine mapping &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1lb_1_1_stats_map_l_b}{vt\+::vrt\+::collection\+::lb\+::\+Stats\+Map\+LB}} \\\cline{1-4}
\end{longtabu}
\hypertarget{lb-manager_load-models}{}\subsection{Object Load Models}\label{lb-manager_load-models}
The performance-\/oriented load balancers described in the preceding section require a prediction of the loads each object will represent during the phases between one load balancing invocation and the next. These predictions are provided by load models, which are implementations of the {\ttfamily vt\+::vrt\+:collection\+:\+:balance\+::\+Load\+Model} interface. There are a number of general-\/purpose load model implementations provided by {\bfseries {\itshape vt}}.

By default, {\bfseries {\itshape vt}} uses a load model that predicts each object\textquotesingle{}s work load for all future phases will match its workload in the most recent past phase. The system also provides an interface for applications and users to arrange use of a non-\/default load model where that may be desirable for reasons such as performance experimentation, specialization to application details, or execution environment considerations. To install a custom load model, application code should call {\ttfamily \hyperlink{namespacevt_a05187076eac8c66c9951b062b0955520}{vt\+::the\+L\+B\+Manager()}-\/$>$set\+Load\+Model(user\+\_\+model)}. To simplify implementation of custom load models, and allow them to benefit from future system-\/level improvements, we recommend that custom load models be composed atop the default model, which can be obtained by calling {\ttfamily \hyperlink{namespacevt_a05187076eac8c66c9951b062b0955520}{vt\+::the\+L\+B\+Manager()}-\/$>$get\+Base\+Load\+Model()}.

Most provided load models are designed as composable filters inherited from the {\ttfamily vt\+::vrt\+:collection\+:\+:balance\+::\+Composed\+Model} class. This allows them to form a \textquotesingle{}model stack\textquotesingle{} in which each class makes a particular adjustment to the predictions generated, and relies on others above and below to refine them further. One exception is the {\ttfamily vt\+::vrt\+:collection\+:\+:balance\+::\+Raw\+Data} model, which directly returns past values recorded in the instrumented statistics structures that {\ttfamily L\+B\+Manager} provides.

To illustrate the design concept, the default model is implemented as a stack of two other components. At the base of the stack is a {\ttfamily Raw\+Data} model that will refer to the instrumented object load timings recorded by the system during preceding execution. Layered on that is a {\ttfamily vt\+::vrt\+:collection\+:\+:balance\+::\+Naive\+Persistence} model that queries the underlying {\ttfamily Raw\+Data} model for the times taken in the most recent phase, and returns those same times as its prediction of the times those objects will take in all future phases.

The full set of load model classes provided with {\bfseries {\itshape vt}} is as follows

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Load Model }&\textbf{ Description }&\textbf{ Reference  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Load Model }&\textbf{ Description }&\textbf{ Reference  }\\\cline{1-3}
\endhead
{\bfseries Utilities} &&\\\cline{1-3}
Load\+Model &Pure virtual interface class, which the following implement &{\ttfamily \hyperlink{classvt_1_1vrt_1_1collection_1_1balance_1_1_load_model}{vt\+::vrt\+::collection\+::balance\+::\+Load\+Model}} \\\cline{1-3}
Composed\+Model &A convenience class for most implementations to inherit from, that passes unmodified calls through to an underlying model instance &{\ttfamily \hyperlink{classvt_1_1vrt_1_1collection_1_1balance_1_1_composed_model}{vt\+::vrt\+::collection\+::balance\+::\+Composed\+Model}} \\\cline{1-3}
Raw\+Data &Returns historical data only, from the measured times &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_raw_data}{vt\+::vrt\+::collection\+::balance\+::\+Raw\+Data}} \\\cline{1-3}
{\bfseries Transformers} &Transforms the values computed by the composed model(s), agnostic to whether a query refers to a past or future phase &\\\cline{1-3}
Norm &When asked for a {\ttfamily W\+H\+O\+L\+E\+\_\+\+P\+H\+A\+SE} value, computes a specified l-\/norm over all subphases &{\ttfamily \hyperlink{classvt_1_1vrt_1_1collection_1_1balance_1_1_norm}{vt\+::vrt\+::collection\+::balance\+::\+Norm}} \\\cline{1-3}
Select\+Subphases &Filters and remaps the subphases with data present in the underlying model &{\ttfamily \hyperlink{classvt_1_1vrt_1_1collection_1_1balance_1_1_select_subphases}{vt\+::vrt\+::collection\+::balance\+::\+Select\+Subphases}} \\\cline{1-3}
Comm\+Overhead &Adds a specified amount of imputed \textquotesingle{}system overhead\textquotesingle{} time to each object\textquotesingle{}s work based on the number of messages received &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_comm_overhead}{vt\+::vrt\+::collection\+::balance\+::\+Comm\+Overhead}} \\\cline{1-3}
Per\+Collection &Maintains a set of load models associated with different collection instances, and passes queries for an object through to the model corresponding to its collection &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_per_collection}{vt\+::vrt\+::collection\+::balance\+::\+Per\+Collection}} \\\cline{1-3}
{\bfseries Predictors} &Computes values for future phase queries, and passes through past phase queries &\\\cline{1-3}
Naive\+Persistence &Passes through historical queries, and maps all future queries to the most recent past phase &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_naive_persistence}{vt\+::vrt\+::collection\+::balance\+::\+Naive\+Persistence}} \\\cline{1-3}
Persistence\+Median\+LastN &Similar to Naive\+Persistence, except that it predicts based on a median over the N most recent phases &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_persistence_median_last_n}{vt\+::vrt\+::collection\+::balance\+::\+Persistence\+Median\+LastN}} \\\cline{1-3}
Linear\+Model &Computes a linear regression over on object\textquotesingle{}s loads from a number of recent phases &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_linear_model}{vt\+::vrt\+::collection\+::balance\+::\+Linear\+Model}} \\\cline{1-3}
Multiple\+Phases &Computes values for future phases based on sums of the underlying model\textquotesingle{}s predictions for N corresponding future phases &{\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_multiple_phases}{vt\+::vrt\+::collection\+::balance\+::\+Multiple\+Phases}} \\\cline{1-3}
\end{longtabu}
All of the provided load balancers described in the previous section require that the installed load model provide responses to future phase queries for at least {\ttfamily Phase\+Offset\+::\+N\+E\+X\+T\+\_\+\+P\+H\+A\+SE} (i.\+e. {\ttfamily 0}), as the {\bfseries Predictors} described above do. \hypertarget{location}{}\section{Location Manager}\label{location}
Virtual entity location management

The location manager component {\ttfamily \hyperlink{structvt_1_1location_1_1_location_manager}{vt\+::location\+::\+Location\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_ace1c9d64e09732e3b7414d02517ecfdb}{vt\+::the\+Loc\+Man()}} manages the location of arbitrary virtual entities in the system. It holds a set of live {\ttfamily \hyperlink{structvt_1_1location_1_1_entity_location_coord}{vt\+::location\+::\+Entity\+Location\+Coord}} across the distributed system which allow users to register/unregister entities and inform the system when migrations occur. With the entities registered, the location coordinator can route messages to them even in the presence of migrations that may occur at any time. The location coordinator maintains a cache of locations for entities registered off-\/node and forwards messages using a communication protocol that depends on the size of the message.

Every entity in the system has a \char`\"{}home node\char`\"{}, which is the node that is ultimately responsible for knowing the location of the entity. When an entity migrates, it informs the home node of its new location in the system. Nodes that try to route messages to that entity will inquire the home node unless the location is already in cache.\hypertarget{location_comm-protocol}{}\subsection{Eager vs. Rendezvous Routing Protocol}\label{location_comm-protocol}
The variable {\ttfamily vt\+::location\+::small\+\_\+msg\+\_\+max\+\_\+size} controls whether a message is routed with an eager or rendezvous protocol. If the message is under that size limit, the message is routed eagerly---forwarded to the \char`\"{}home node\char`\"{} for resolution if the location is not in the cache.

If the size of the message is greater than {\ttfamily vt\+::location\+::small\+\_\+msg\+\_\+max\+\_\+size}, the location coordinator will inquire with a control message to resolve the location before the large message is actually sent. This reduces the number of hops required to send large messages.\hypertarget{location_location-migrations}{}\subsection{Entity Migrations}\label{location_location-migrations}
When migrations occur at any time, it\textquotesingle{}s always possible for the message to arrive on a node where the entity {\itshape used to be}. In this case, the location coordinator knows to follow the breadcrumb to get the message delivered properly where the entity exists now. If the entity continues to move, the message will \char`\"{}chase\char`\"{} it until it catches up. \hypertarget{mem-usage}{}\section{Memory Usage Tracker}\label{mem-usage}
Track memory usage

The memory usage component {\ttfamily \hyperlink{structvt_1_1util_1_1memory_1_1_memory_usage}{vt\+::util\+::memory\+::\+Memory\+Usage}}, accessed via {\ttfamily \hyperlink{namespacevt_a38d485d3cf840b9a623e47e7754ef72e}{vt\+::the\+Mem\+Usage()}} is an optional VT component that tracks memory usage over time. It can be used with the \hyperlink{trace}{Tracing} component to write memory usage to Projections log files to track usage after each registered function executes. It can be configured to report usage after each LB phase is reached. This component is backed by a wide range of different reporters---everything from trapping memory allocation calls to counting allocated pages. \hypertarget{objgroup}{}\section{Object Group Manager}\label{objgroup}
Create object instances across nodes

The object group manager component {\ttfamily \hyperlink{structvt_1_1objgroup_1_1_obj_group_manager}{vt\+::objgroup\+::\+Obj\+Group\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a833f0115b692f578167cbd88e30d39c5}{vt\+::the\+Obj\+Group()}} allows the creation and management of instances of a group of objects (one per node) that have a collective proxy for performing operations like sends, broadcasts, or reductions across the object group.\hypertarget{objgroup_objgroup-example}{}\subsection{Example creating an object group}\label{objgroup_objgroup-example}

\begin{DoxyCodeInclude}
\textcolor{keyword}{struct }MyMsg : \hyperlink{structvt_1_1messaging_1_1_active_msg}{vt::Message} \{
  MyMsg(\textcolor{keywordtype}{int} in\_a, \textcolor{keywordtype}{int} in\_b) : a(in\_a), b(in\_b) \{ \}
  \textcolor{keywordtype}{int} a = 0, b = 0;
\};

\textcolor{keyword}{struct }MyObjGroup \{
  \textcolor{keywordtype}{void} \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{handler}(MyMsg* msg) \{
    \textcolor{keyword}{auto} \hyperlink{namespacevt_1_1config_a46e57c33bee1b9f1fa95455af86d80e0a576033c81e2ddd03d721ecef3b1b3f81}{node} = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
    fmt::print(\textcolor{stringliteral}{"\{\}: MyObjGroup::handler on a=\{\}, b=\{\}\(\backslash\)n"}, \hyperlink{namespacevt_1_1config_a46e57c33bee1b9f1fa95455af86d80e0a576033c81e2ddd03d721ecef3b1b3f81}{node}, msg->a, msg->b);
  \}
\};

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_aaa266774ea8339c58be0202b00fafa62}{vt::initialize}(argc, argv, \textcolor{keyword}{nullptr});

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keyword}{auto} proxy = \hyperlink{namespacevt_a833f0115b692f578167cbd88e30d39c5}{vt::theObjGroup}()->\hyperlink{structvt_1_1objgroup_1_1_obj_group_manager_a651c44a47c6bcdc9f1b6c9e857fa03f2}{makeCollective}<MyObjGroup>();

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    proxy[0].send<MyMsg,&\hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{MyObjGroup::handler}>(5,10);
    \textcolor{keywordflow}{if} (num\_nodes > 1) \{
      proxy[1].send<MyMsg,&MyObjGroup::handler>(10,20);
    \}
    proxy.broadcast<MyMsg,&MyObjGroup::handler>(400,500);
  \}

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
\hypertarget{param}{}\section{Parameterization}\label{param}
Handler parameterization

 {\bfseries Experimental}

The parameterization component {\ttfamily \hyperlink{structvt_1_1param_1_1_param}{vt\+::param\+::\+Param}}, accessed via {\ttfamily \hyperlink{namespacevt_a268431014c9031c0f7c33d32c1b8645c}{vt\+::the\+Param()}} is an experimental component for parameterizing arguments into active function handlers as an alternative to messages. \hypertarget{pipe}{}\section{Pipe Manager}\label{pipe}
Create opaque callback endpoints

The pipe manager component {\ttfamily \hyperlink{structvt_1_1pipe_1_1_pipe_manager}{vt\+::pipe\+::\+Pipe\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt\+::the\+C\+B()}} allows the creation of general pipes and callbacks between opaque endpoints that are not revealed through the type. Callbacks allow one to supply a general endpoint that accepts a type of data without revealing the actual endpoint instance. For example, one may create a callback that triggers a handler invocation on a certain node, broadcasts to a handler, sends to a collection or objgroup, or broadcasts to a collection or objgroup, etc.

The pipe manager supports more complex use cases of multi-\/listener endpoints if one wants to trigger multiple endpoints on potentially different nodes. The lifetime of a pipe can also be configured---how many invocations are allowed before the callback is invalid. The pipe manager has a reference count for each pipe which gets decremented with each signal arrival. By default, callbacks are infinitely callable and do not expire.

The pipe manager also supports \char`\"{}typed\char`\"{} callbacks where the callee type is revealed to the caller. Typed callbacks are slightly more efficient because the type is exposed and registered type-\/erasure is not required (using lambdas).\hypertarget{pipe_callback-example}{}\subsection{Example callbacks}\label{pipe_callback-example}

\begin{DoxyCodeInclude}
\textcolor{comment}{// Message sent from the callback to the callback endpoint}
\textcolor{keyword}{struct }TestMsg : \hyperlink{structvt_1_1messaging_1_1_active_msg}{vt::Message} \{
  \textcolor{keyword}{using} MessageParentType = \hyperlink{namespacevt_a3a3ddfef40b4c90915fa43cdd5f129ea}{::vt::Message};
  \hyperlink{message__serialize_8h_a54128d5338aaa9c918179826085e13d1}{vt\_msg\_serialize\_required}(); \textcolor{comment}{// for string}

  TestMsg() = \textcolor{keywordflow}{default};

  \textcolor{keyword}{explicit} TestMsg(\textcolor{keywordtype}{int} in\_val, std::string \textcolor{keyword}{const}& in\_s = \textcolor{stringliteral}{"hello"})
    : val\_(in\_val),
      s\_(in\_s)
  \{ \}

  \textcolor{keyword}{template} <\textcolor{keyword}{typename} SerializerT>
  \textcolor{keywordtype}{void} \hyperlink{structvt_1_1messaging_1_1_active_msg_a758f02bef5991c48d6c9a56c30ca7ad9}{serialize}(SerializerT& s) \{
    \hyperlink{namespacevt_1_1vrt_1_1collection_1_1balance_a783d95de203cabd0f599440e9869c313}{MessageParentType::serialize}(s);
    s | val\_;
    s | s\_;
  \}

  \textcolor{keywordtype}{int} val\_ = 0;
  std::string s\_;
\};

\textcolor{comment}{// Message containing the callback to invoke}
\textcolor{keyword}{struct }HelloMsg : \hyperlink{structvt_1_1messaging_1_1_active_msg}{vt::Message} \{
  \textcolor{keyword}{explicit} HelloMsg(\hyperlink{structvt_1_1pipe_1_1callback_1_1cbunion_1_1_callback_typed}{vt::Callback<TestMsg>} in\_cb)
    : cb\_(in\_cb)
  \{ \}

  \hyperlink{structvt_1_1pipe_1_1callback_1_1cbunion_1_1_callback_typed}{vt::Callback<TestMsg>} cb\_;
\};

\textcolor{comment}{// Handler function to invoke the callback from}
\textcolor{keywordtype}{void} hello\_world(HelloMsg* msg) \{
  \textcolor{keyword}{static} \textcolor{keywordtype}{int} val = 1;
  fmt::print(\textcolor{stringliteral}{"\{\}: Sending callback\(\backslash\)n"}, \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->getNode());
  \textcolor{keyword}{auto} to\_send = vt::makeMessage<TestMsg>(292 + val++, \textcolor{stringliteral}{"test string"});
  msg->cb\_.send(to\_send.get());
\}

\textcolor{keywordtype}{void} printOutput(TestMsg* msg, std::string type) \{
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  fmt::print(\textcolor{stringliteral}{"\{\}: cb \{\}: val=\{\}, str=\{\}\(\backslash\)n"}, this\_node, type, msg->val\_, msg->s\_);
\}

\textcolor{comment}{// Functor callback endpoint}
\textcolor{keyword}{struct }CallbackFunctor \{
  \textcolor{keywordtype}{void} operator()(TestMsg* msg) \{
    printOutput(msg, \textcolor{stringliteral}{"CallbackFunctor"});
  \}
\};

\textcolor{comment}{// Function callback endpoint}
\textcolor{keyword}{static} \textcolor{keywordtype}{void} callbackFunc(TestMsg* msg) \{
  printOutput(msg, \textcolor{stringliteral}{"callbackFunc"});
\}

\textcolor{keyword}{struct }MyObj \{
  \textcolor{comment}{// Objgroup callback endpoint}
  \textcolor{keywordtype}{void} \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{handler}(TestMsg* msg) \{
    printOutput(msg, \textcolor{stringliteral}{"MyObj::handler"});
  \}
\};

\textcolor{keyword}{struct }MyCol : \hyperlink{structvt_1_1vrt_1_1collection_1_1_collection}{vt::Collection}<MyCol, vt::Index1D> \{ \};

\textcolor{comment}{// Collection handler callback endpoint}
\textcolor{keywordtype}{void} colHan(TestMsg* msg, MyCol* col) \{
  printOutput(msg, \textcolor{stringliteral}{"MyCol colHan (non-intrusive)"});
\}

\textcolor{keywordtype}{void} bounceCallback(\hyperlink{structvt_1_1pipe_1_1callback_1_1cbunion_1_1_callback_typed}{vt::Callback<TestMsg>} cb) \{
  \textcolor{keyword}{auto} msg = vt::makeMessage<HelloMsg>(cb);
  \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_gaebfcd932babb3be0ea8d481f655a2835}{sendMsg}<HelloMsg, hello\_world>(1, msg.get());
\}

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_aaa266774ea8339c58be0202b00fafa62}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keywordflow}{if} (num\_nodes == 1) \{
    \textcolor{keywordflow}{return} \hyperlink{namespacevt_aff96ace008dc847d4c0f44cfa5dfb3a0}{vt::rerror}(\textcolor{stringliteral}{"requires at least 2 nodes"});
  \}

  \textcolor{keyword}{auto} obj = \hyperlink{namespacevt_a833f0115b692f578167cbd88e30d39c5}{vt::theObjGroup}()->\hyperlink{structvt_1_1objgroup_1_1_obj_group_manager_a651c44a47c6bcdc9f1b6c9e857fa03f2}{makeCollective}<MyObj>();
  \textcolor{keyword}{auto} col = \hyperlink{namespacevt_a1c45ce63bfd2c327ff7d76a319a371d8}{vt::theCollection}()->\hyperlink{structvt_1_1vrt_1_1collection_1_1_collection_manager_a619d6e576f0d108e442b16ca4f68f1f3}{constructCollective}<MyCol>(
    \hyperlink{namespacevt_a5540efc78234273e1796fb003fe4d234}{vt::Index1D}(8), [](\hyperlink{namespacevt_a5540efc78234273e1796fb003fe4d234}{vt::Index1D})\{ \textcolor{keywordflow}{return} std::make\_unique<MyCol>(); \}
  );

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} dest = num\_nodes > 2 ? 2 : 0;

    \textcolor{keyword}{auto} cb\_functor = \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt::theCB}()->\hyperlink{structvt_1_1pipe_1_1_pipe_manager_a73583be6260418b13ee66e56cdade2da}{makeSend}<CallbackFunctor>(dest);
    bounceCallback(cb\_functor);

    \textcolor{keyword}{auto} cb\_func = \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt::theCB}()->\hyperlink{structvt_1_1pipe_1_1_pipe_manager_a73583be6260418b13ee66e56cdade2da}{makeSend}<TestMsg,callbackFunc>(dest);
    bounceCallback(cb\_func);

    \textcolor{keyword}{auto} cb\_obj = \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt::theCB}()->\hyperlink{structvt_1_1pipe_1_1_pipe_manager_a73583be6260418b13ee66e56cdade2da}{makeSend}<MyObj,TestMsg,&
      \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{MyObj::handler}>(obj[dest]);
    bounceCallback(cb\_obj);

    \textcolor{keyword}{auto} cb\_obj\_bcast = \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt::theCB}()->\hyperlink{structvt_1_1pipe_1_1_pipe_manager_a2ea6bd5ea3e001662681b1e5a1971e9d}{makeBcast}<MyObj,TestMsg,&
      \hyperlink{namespacevt_1_1config_a6bd1d6215bda0d8ca02811798399f689a82a0081a94d5c5dfd18b0b3f7eca64b7}{MyObj::handler}>(obj);
    bounceCallback(cb\_obj\_bcast);

    \textcolor{keyword}{auto} cb\_col = \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt::theCB}()->\hyperlink{structvt_1_1pipe_1_1_pipe_manager_a73583be6260418b13ee66e56cdade2da}{makeSend}<MyCol,TestMsg,colHan>(col[5]);
    bounceCallback(cb\_col);

    \textcolor{keyword}{auto} cb\_col\_bcast = \hyperlink{namespacevt_a673b109e94c7bca58313504c83e1da94}{vt::theCB}()->\hyperlink{structvt_1_1pipe_1_1_pipe_manager_a2ea6bd5ea3e001662681b1e5a1971e9d}{makeBcast}<MyCol,TestMsg,colHan>(col);
    bounceCallback(cb\_col\_bcast);
  \}

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
\hypertarget{node-stats}{}\section{Node Statistics}\label{node-stats}
Manager object profiling data

The node statistics manager component {\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_node_stats}{vt\+::vrt\+::collection\+::balance\+::\+Node\+Stats}}, accessed via {\ttfamily \hyperlink{namespacevt_ae1526efa346612ad330d9a628e596c54}{vt\+::the\+Node\+Stats()}} manages instrumentation data from objects in a collection. It holds data per node on the timing of these objects and communication between them demarcated by phase and subphase.

When LB is invoked in {\bfseries {\itshape vt}}, the \hyperlink{lb-manager}{LB Manager} passes the node statistics to the various LB strategies to run the load balancer. The node statistics component can also dump the statistic data it holds to files, which can be read externally. The L\+B\+AF (Load Balancing Analysis Framework) can also then read this data to analyze the quality of the load distribution at any phase in the file.\hypertarget{node-stats_export-lb-stats-file}{}\subsection{Exporting L\+B Statistic Files (\+V\+O\+M)}\label{node-stats_export-lb-stats-file}
The {\ttfamily Node\+Stats} component, after collecting statistics from the running program, can dump these to files in a V\+OM file (Virtual Object Map). As indicated by the name, the V\+OM file specifies the mapping of object to node for each phase along with statistics for each object (computation time and communication load).

To output V\+OM files, pass {\ttfamily -\/-\/vt\+\_\+lb\+\_\+stats} to enable output along with {\ttfamily -\/-\/vt\+\_\+lb\+\_\+stats\+\_\+dir=$<$my-\/directory$>$} and {\ttfamily -\/-\/vt\+\_\+lb\+\_\+stats\+\_\+file=$<$my-\/base-\/name$>$} to control the directory the files are generated along with the base file name. With this enabled, {\bfseries {\itshape vt}} will generate a file for each node that contains the statistics and mapping.\hypertarget{node-stats_stats-file-format}{}\subsubsection{File Format}\label{node-stats_stats-file-format}
Each line in the file will one of two formats. The first line is a computation time line for each phase, that breaks time down into subphases\+:


\begin{DoxyCode}
<phase>, <object-id>, <time-in-seconds> <#-of-subphases> '[' [<subphase-time-1>] ... [<subphase-time-N>]
       ']'
\end{DoxyCode}


The second line format is a communication line\+:


\begin{DoxyCode}
<phase>, <object-id1-to/recv>, <object-id2-from/send>, <num-bytes>, <comm-type=\{1..6\}>
\end{DoxyCode}


Where {\ttfamily $<$comm-\/type$>$} is the type of communication occurred. The type of communication lines up the enum {\ttfamily \hyperlink{namespacevt_1_1vrt_1_1collection_1_1balance_a9cc6c6884ca0416dae824e9204093c57}{vt\+::vrt\+::collection\+::balance\+::\+Comm\+Category}} in the code.

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Value }&\textbf{ Enum entry }&\textbf{ Description  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Value }&\textbf{ Enum entry }&\textbf{ Description  }\\\cline{1-3}
\endhead
1 &{\ttfamily Comm\+Category\+::\+Send\+Recv} &A send-\/receive edge between two collection elements \\\cline{1-3}
2 &{\ttfamily Comm\+Category\+::\+Collection\+To\+Node} &A send from a collection element to a node \\\cline{1-3}
3 &{\ttfamily Comm\+Category\+::\+Node\+To\+Collection} &A send from a node to a collection element \\\cline{1-3}
4 &{\ttfamily Comm\+Category\+::\+Broadcast} &A broadcast from a collection element to a whole collection (receive-\/side) \\\cline{1-3}
5 &{\ttfamily Comm\+Category\+::\+Collection\+To\+Node\+Bcast} &A broadcast from a collection element to all nodes (receive-\/side) \\\cline{1-3}
6 &{\ttfamily Comm\+Category\+::\+Node\+To\+Collection\+Bcast} &A broadcast from a node to a whole collection (receive-\/side) \\\cline{1-3}
\end{longtabu}
For all the broadcast-\/like edges, the communication logging will occur on the receive of the broadcast side (one entry per broadcast recipient). \hypertarget{pool}{}\section{Memory Pool}\label{pool}
Memory pool for efficient allocation

The memory pool component {\ttfamily \hyperlink{structvt_1_1pool_1_1_pool}{vt\+::pool\+::\+Pool}}, accessed via {\ttfamily \hyperlink{namespacevt_aab3530d89a64e5ea903b0ccf303ecbb7}{vt\+::the\+Pool()}} provides a highly efficient memory pool for fixed sized allocations in three sizes\+: small ({\ttfamily vt\+::pool\+::memory\+\_\+size\+\_\+small}), medium ({\ttfamily vt\+::pool\+::memory\+\_\+size\+\_\+medium}), and large (currently unimplemented).

All message allocation (on the send and receive side) is overloaded with new/delete overloads to allocate message memory through the {\bfseries {\itshape vt}} memory pool. The pool implementation uses a non-\/thread-\/safe allocation policy (must be allocated/deallocated on the same thread) with fixed sized buckets. If the size exceeds the largest bucket, the memory pool will fall back on the standard allocator. \hypertarget{rdma}{}\section{R\+D\+MA Manager}\label{rdma}
Node-\/level R\+D\+MA

 {\bfseries Experimental}

The R\+D\+MA manager component {\ttfamily \hyperlink{structvt_1_1rdma_1_1_r_d_m_a_manager}{vt\+::rdma\+::\+R\+D\+M\+A\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a68b8410bc2b86d3b5228d7dbb6b40bac}{vt\+::the\+R\+D\+M\+A()}} is an experimental component that sends pure data to registered R\+D\+MA handlers or directly to memory locations.

Registered R\+D\+MA handlers trigger a function when the data arrives (G\+ET) or is sent (P\+UT). If registered memory locations are used directly, one may create a R\+D\+MA channel which backs the G\+E\+T/\+P\+UT by {\ttfamily M\+P\+I\+\_\+\+Get}/{\ttfamily M\+P\+I\+\_\+\+Put}. \hypertarget{rdmahandle}{}\section{R\+D\+MA Handle Manager}\label{rdmahandle}
R\+D\+MA handles backed by M\+PI

The R\+D\+MA handle manager component {\ttfamily \hyperlink{structvt_1_1rdma_1_1_manager}{vt\+::rdma\+::\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_aecb87ec2c40b5b7fc57ba4cf8ea838b0}{vt\+::the\+Handle\+R\+D\+M\+A()}} is a component that allows data to be transferred between R\+D\+MA handles, which are persistent objects with underlying memory registered with M\+PI.

R\+D\+MA handles can either be node-\/ or index-\/level, depending on whether they belong to an objgroup or collection. A handle provides an interface to calling get/put/accum to access the backing M\+PI implementation. \hypertarget{registry}{}\section{Registry}\label{registry}
Registered handlers

The registry component {\ttfamily \hyperlink{structvt_1_1registry_1_1_registry}{vt\+::registry\+::\+Registry}}, accessed via {\ttfamily \hyperlink{namespacevt_a8b5994a5aedabc64006ce820db2e938c}{vt\+::the\+Registry()}} holds type-\/safe active handlers for execution across a distributed machine.


\begin{DoxyItemize}
\item The \hyperlink{active-messenger}{Active Messenger} uses the registry to store/dispatch active function and active functor handlers.
\item The \hyperlink{objgroup}{Object Group Manager} uses the registry to store/dispatch active member functions
\item The \hyperlink{collection}{Virtual Context Collection} uses the registry to store/dispatch active functions with the object pointer and active members. 
\end{DoxyItemize}\hypertarget{scheduler}{}\section{Scheduler}\label{scheduler}
General scheduling of work

The scheduler component {\ttfamily \hyperlink{structvt_1_1sched_1_1_scheduler}{vt\+::sched\+::\+Scheduler}}, accessed via {\ttfamily \hyperlink{namespacevt_a4508b38e6ab664b64f1415aecbb83571}{vt\+::the\+Sched()}}, holds pieces of work to execute later that may be prioritized. The scheduler polls the {\bfseries {\itshape vt}} components to make progress and collect new pieces of work. The scheduler allows registration of callbacks when the system is idle.\hypertarget{scheduler_calls-to-the-scheduler}{}\subsection{Calls to the scheduler}\label{scheduler_calls-to-the-scheduler}
To advance the scheduler, one can call it as follows\+:


\begin{DoxyCode}
\hyperlink{namespacevt_a4508b38e6ab664b64f1415aecbb83571}{vt::theSched}()->\hyperlink{structvt_1_1sched_1_1_scheduler_ad2653b260780c89a20e9253608ef1282}{scheduler}();
\end{DoxyCode}


This polls every component that might generate or complete work, and potentially runs one piece of available work.

However, if the scheduler needs to be run until a condition (or set of conditions) is met, it is recommended that {\ttfamily run\+Scheduler\+While} be invoked\+:


\begin{DoxyCode}
\hyperlink{namespacevt_a4508b38e6ab664b64f1415aecbb83571}{vt::theSched}()->\hyperlink{structvt_1_1sched_1_1_scheduler_a9c130fc0ccbf237633420a7aa35069a4}{runSchedulerWhile}(\textcolor{comment}{/*std::function<bool()> cond*/});
\end{DoxyCode}


Runs the scheduler until a condition is met. This form S\+H\+O\+U\+LD be used instead of \char`\"{}while (..) \{ run\+Scheduler(..) \}\char`\"{} in all cases of nested scheduler loops, such as during a barrier, in order to ensure proper event unwinding and idle time tracking.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cond} & condition to turn scheduler until met\\
\hline
\end{DoxyParams}
\hypertarget{scheduler_higher-level-calls}{}\subsection{Higher-\/level Calls to Wait for Completion}\label{scheduler_higher-level-calls}
If work is enclosed in an \char`\"{}epoch\char`\"{}, the \hyperlink{term}{Termination Detector} can be used to track its distributed completion. In this case, instead of calling the scheduler directly, built-\/in higher-\/level functions can be used to advance the scheduler until this work is complete/terminated.

To run the scheduler until an epoch terminates, call the following function\+:


\begin{DoxyCode}
\hyperlink{namespacevt_aa550774c1c9c668176ce535fd7d58fb0}{vt::runSchedulerThrough}(my\_epoch);
\end{DoxyCode}


Or, to combine the actual enclosed work with the call to wait for its termination, use the following function\+:


\begin{DoxyCode}
\hyperlink{namespacevt_ad419c00d2e4ac8601ea3b1dec633f3f7}{vt::runInEpochRooted}([]\{
  \textcolor{comment}{// work to do on a single node}
\});
\end{DoxyCode}


If the work should be executed by all nodes, use a collective epoch\+:\+:


\begin{DoxyCode}
\hyperlink{namespacevt_a291cca514e6f66292df339cd92a54502}{vt::runInEpochCollective}([]\{
  \textcolor{comment}{// work to do on all nodes}
\});
\end{DoxyCode}
 \hypertarget{seq}{}\section{Sequencer}\label{seq}
Sequence node actions

 {\bfseries Experimental}

The sequencer component {\ttfamily \hyperlink{structvt_1_1seq_1_1_tagged_sequencer}{vt\+::seq\+::\+Tagged\+Sequencer}}, accessed via {\ttfamily \hyperlink{namespacevt_a4a7d07c845b311da59286de486d623c7}{vt\+::the\+Seq()}} orders operations on a node. If multiple handlers arrive, one can specify if they are allowed to run in parallel and in what correct orders that may execute. \hypertarget{vrtseq}{}\section{Virtual Sequencer}\label{vrtseq}
Sequence task actions

 {\bfseries Experimental}

The sequencer component {\ttfamily \hyperlink{structvt_1_1seq_1_1_tagged_sequencer_vrt}{vt\+::seq\+::\+Tagged\+Sequencer\+Vrt}}, accessed via {\ttfamily \hyperlink{namespacevt_abdbb9ddb0d79b35c89e9d742d3fc9d42}{vt\+::the\+Virtual\+Seq()}} orders operations on a virtual context. If multiple handlers arrive, one can specify if they are allowed to run in parallel and in what correct orders that may execute. \hypertarget{term}{}\section{Termination Detector}\label{term}
Detect termination of work

The termination component {\ttfamily \hyperlink{structvt_1_1term_1_1_termination_detector}{vt\+::term\+::\+Termination\+Detector}}, accessed via {\ttfamily \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt\+::the\+Term()}} detects the completion of the transitive closure of work by following the causal chain of messages/events across multiple nodes. It provides global termination to determine when all work is complete and the schedulers can stop running. Additionally, it enables the creation of epochs (which stamp message envelopes) to mark messages as part of a work grouping to detect termination of all events causally related to a subset of messages in the system.

The termination detector comes with two different detection algorithms\+: (1) 4-\/counter wave-\/based termination for large collective or large rooted epochs across the whole system; and, (2) Dijkstra-\/\+Scholten parental responsibility termination for rooted epochs. Epochs are allowed to have other epochs nested within them, thus forming a graph. The detector tracks the relation between epochs, only making progress on epochs that do not have a dependency on another epoch terminating first.

The termination detector also comes with hang detection to detect causes where no progress can be made due to bugs in an application\textquotesingle{}s code or the runtime implementation. When a hang is detected, if configured as such by the user, the detector will dump a D\+OT graph of the live epochs and their dependencies.\hypertarget{term_term-collective-example}{}\subsection{Example of creating a collective epoch}\label{term_term-collective-example}

\begin{DoxyCodeInclude}
\textcolor{keyword}{using} TestMsg = \hyperlink{namespacevt_a3a3ddfef40b4c90915fa43cdd5f129ea}{vt::Message};

\hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} nextNode() \{
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();
  \textcolor{keywordflow}{return} (this\_node + 1) % num\_nodes;
\}

\textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_handler(TestMsg* msg) \{
  \textcolor{keyword}{static} \textcolor{keywordtype}{int} num = 3;

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();

  \textcolor{keyword}{auto} epoch = \hyperlink{namespacevt_ad5495e7900227550b44837e899c5bb13}{vt::envelopeGetEpoch}(msg->env);
  fmt::print(\textcolor{stringliteral}{"\{\}: test\_handler: num=\{\}, epoch=\{:x\}\(\backslash\)n"}, this\_node, num, epoch);

  num--;
  \textcolor{keywordflow}{if} (num > 0) \{
    \textcolor{keyword}{auto} msg\_send = vt::makeMessage<TestMsg>();
    \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_gaebfcd932babb3be0ea8d481f655a2835}{sendMsg}<TestMsg, test\_handler>(nextNode(), msg\_send.get());
  \}
\}

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_aaa266774ea8339c58be0202b00fafa62}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keywordflow}{if} (num\_nodes == 1) \{
    \textcolor{keywordflow}{return} \hyperlink{namespacevt_aff96ace008dc847d4c0f44cfa5dfb3a0}{vt::rerror}(\textcolor{stringliteral}{"requires at least 2 nodes"});
  \}

  \textcolor{keyword}{auto} epoch = \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt::theTerm}()->\hyperlink{structvt_1_1term_1_1_termination_detector_a748dfa37925107b37bde702e6c5f4aa4}{makeEpochCollective}();

  \textcolor{comment}{// This action will not run until all messages originating from the}
  \textcolor{comment}{// sends are completed}
  \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt::theTerm}()->\hyperlink{structvt_1_1term_1_1_term_action_a1227042cb4eb38937fb8ed34bcbdf998}{addAction}(epoch, [=]\{
    fmt::print(\textcolor{stringliteral}{"\{\}: finished epoch=\{:x\}\(\backslash\)n"}, this\_node, epoch);
  \});

  \textcolor{comment}{// Message must go out of scope before finalize}
  \{
    \textcolor{keyword}{auto} msg = vt::makeMessage<TestMsg>();
    \hyperlink{namespacevt_a4a0a9928690206b588dbcac2afb71088}{vt::envelopeSetEpoch}(msg->env, epoch);
    \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_gaebfcd932babb3be0ea8d481f655a2835}{sendMsg}<TestMsg, test\_handler>(nextNode(), msg.get());
  \}

  \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt::theTerm}()->\hyperlink{structvt_1_1term_1_1_termination_detector_ad54d75c50bd3f34f30247817737bc303}{finishedEpoch}(epoch);

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
 \hypertarget{term_term-rooted-example}{}\subsection{Example of creating a rooted epoch}\label{term_term-rooted-example}

\begin{DoxyCodeInclude}
\textcolor{keyword}{using} TestMsg = \hyperlink{namespacevt_a3a3ddfef40b4c90915fa43cdd5f129ea}{vt::Message};

\hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} nextNode() \{
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();
  \textcolor{keywordflow}{return} (this\_node + 1) % num\_nodes;
\}

\textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_handler(TestMsg* msg) \{
  \textcolor{keyword}{static} \textcolor{keywordtype}{int} num = 3;

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();

  \textcolor{keyword}{auto} epoch = \hyperlink{namespacevt_ad5495e7900227550b44837e899c5bb13}{vt::envelopeGetEpoch}(msg->env);
  fmt::print(\textcolor{stringliteral}{"\{\}: test\_handler: num=\{\}, epoch=\{:x\}\(\backslash\)n"}, this\_node, num, epoch);

  num--;
  \textcolor{keywordflow}{if} (num > 0) \{
    \textcolor{keyword}{auto} msg\_send = vt::makeMessage<TestMsg>();
    \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_gaebfcd932babb3be0ea8d481f655a2835}{sendMsg}<TestMsg, test\_handler>(nextNode(), msg\_send.get());
  \}
\}

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
  \hyperlink{namespacevt_aaa266774ea8339c58be0202b00fafa62}{vt::initialize}(argc, argv);

  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} this\_node = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->\hyperlink{structvt_1_1ctx_1_1_context_a0d52c263ce8516546a67443d9a86fa5f}{getNode}();
  \hyperlink{namespacevt_a866da9d0efc19c0a1ce79e9e492f47e2}{vt::NodeType} num\_nodes = \hyperlink{namespacevt_a26551fe0e6e6a1371111df5b12c7e92c}{vt::theContext}()->
      \hyperlink{structvt_1_1ctx_1_1_context_a7f41071aadf6d5fa9e1b6c703c5ff19d}{getNumNodes}();

  \textcolor{keywordflow}{if} (num\_nodes == 1) \{
    \textcolor{keywordflow}{return} \hyperlink{namespacevt_aff96ace008dc847d4c0f44cfa5dfb3a0}{vt::rerror}(\textcolor{stringliteral}{"requires at least 2 nodes"});
  \}

  \textcolor{keywordflow}{if} (this\_node == 0) \{
    \textcolor{keyword}{auto} epoch = \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt::theTerm}()->\hyperlink{structvt_1_1term_1_1_termination_detector_ab0724773b4856bfe8225bc5bc0ca6ec0}{makeEpochRooted}(
      \hyperlink{structvt_1_1term_1_1_use_d_s}{vt::term::UseDS}\{\textcolor{keyword}{true}\});

    \textcolor{comment}{// This action will not run until all messages originating from the}
    \textcolor{comment}{// following send are completed}
    \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt::theTerm}()->\hyperlink{structvt_1_1term_1_1_term_action_a1227042cb4eb38937fb8ed34bcbdf998}{addAction}(epoch, [=]\{
      fmt::print(\textcolor{stringliteral}{"\{\}: finished epoch=\{:x\}\(\backslash\)n"}, this\_node, epoch);
    \});

    \textcolor{keyword}{auto} msg = vt::makeMessage<TestMsg>();
    \hyperlink{namespacevt_a4a0a9928690206b588dbcac2afb71088}{vt::envelopeSetEpoch}(msg->env, epoch);
    \hyperlink{namespacevt_aeafd31f866aeb4dc6fc2f6ee97136350}{vt::theMsg}()->\hyperlink{group__preregister_gaebfcd932babb3be0ea8d481f655a2835}{sendMsg}<TestMsg, test\_handler>(nextNode(), msg.get());
    \hyperlink{namespacevt_a127580fdfcaba0b4171e5c48c5676733}{vt::theTerm}()->\hyperlink{structvt_1_1term_1_1_termination_detector_ad54d75c50bd3f34f30247817737bc303}{finishedEpoch}(epoch);
  \}

  \hyperlink{namespacevt_a540d90dbd6e97b69f1dcbc9ee9314cff}{vt::finalize}();

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
\hypertarget{time-trigger}{}\section{Time Triggers}\label{time-trigger}
Time-\/based progress actions

The timed trigger component {\ttfamily \hyperlink{structvt_1_1timetrigger_1_1_time_trigger_manager}{vt\+::timetrigger\+::\+Time\+Trigger\+Manager}}, accessed via {\ttfamily \hyperlink{namespacevt_a1e1a39cdf2a3fc1adefcdfcca4716bf2}{vt\+::the\+Time\+Trigger()}} manages and coordinates time-\/based actions that can be registered by the system and users.

A timed trigger, when registered using the manager, will fire approximately along that period. For instance, if a trigger is registered with a 100ms period, it will be called approximately every 100ms while the {\bfseries {\itshape vt}} progress function is being invoked. If the progress function (or {\bfseries {\itshape vt}} scheduler) is called infrequently, the triggers may be delayed depending on the period. Also, if large work units are enqueued in the {\bfseries {\itshape vt}} scheduler that take longer than the time period, the trigger will fire as often as it can in between these pieces of work (the component does not use interrupts to trigger actions).

To register a trigger, call {\ttfamily \hyperlink{namespacevt_a1e1a39cdf2a3fc1adefcdfcca4716bf2}{vt\+::the\+Time\+Trigger()}-\/$>$add\+Trigger(100ms, \mbox{[}\mbox{]}\{ /$\ast$ my action $\ast$/\});}. The {\ttfamily add\+Trigger} method returns a handle to the registered trigger that can be passed to {\ttfamily \hyperlink{namespacevt_a1e1a39cdf2a3fc1adefcdfcca4716bf2}{vt\+::the\+Time\+Trigger()}-\/$>$remove\+Trigger(id);} to stop it from firing at a certain point. \hypertarget{trace}{}\section{Tracing}\label{trace}
Trace distributed events

The optional trace component {\ttfamily \hyperlink{structvt_1_1trace_1_1_trace}{vt\+::trace\+::\+Trace}}, accessed via {\ttfamily vt\+::the\+Trace()} builds a distributed trace of events, including VT handlers, user events, and M\+PI invocations via the P\+M\+PI interface. It outputs \href{http://charm.cs.uiuc.edu/software}{\tt Projections} log and sts files to enable performance analysis after execution.

To enable tracing at runtime, the trace component must be enabled at compile time with cmake. To enable tracing pass the cmake flag\+: 
\begin{DoxyCode}
-Dvt\_trace\_enabled=1
\end{DoxyCode}
\hypertarget{trace_tracing-spec-file}{}\subsection{Tracing Specification File}\label{trace_tracing-spec-file}
In order to customize when tracing is enabled and disabled, a trace specification file can be passed to {\bfseries {\itshape vt}} via a command-\/line flag\+: {\ttfamily -\/-\/vt\+\_\+trace\+\_\+spec -\/-\/vt\+\_\+trace\+\_\+spec\+\_\+file=filename.\+spec}.

The parser will read the following format\+:


\begin{DoxyCode}
[%] <phase> <range negative> <range positive>
\end{DoxyCode}


The following is an example of a trace specification\+:


\begin{DoxyCode}
0 0 10
%100 -3 3
200 -5 5
\end{DoxyCode}


This specifies that tracing will be enabled on the following phases\+:


\begin{DoxyCode}
\{
  [0,10], # phase 0 with offsets 0,+10 (subsumes [0,3] from %100 -3 3)
  [97,103] # any phase % 100 with offset -3,+3
  [195,205] # phase 200 with offsets -5,+5 (subsumes [197,203] from %100 -3 3)
  [297,303] # any phase % 100 with offset -3,+3
  [n%100-3,n%100+3] ... # any phase % 100 with offset -3,+3
\}
\end{DoxyCode}


The sets of mod-\/phase and phase-\/specific entries must be unique. There may be overlap across the two sets, but not within them. Having two entries that start with {\ttfamily \%100} or two entries that start with {\ttfamily 100} would be invalid and trigger a parsing error. But having a {\ttfamily \%100} and {\ttfamily 100} entry is valid. Whether tracing is enabled is calculated as an OR across all specification entries. Thus, if a given phase is contained in any spec line, it is enabled. Note that {\ttfamily 0 \% 100 = 0}. Therefore, if the above example did not contain the first line, tracing would be enabled as\+:


\begin{DoxyCode}
\{
  [0,3], # any phase mod 100 from -3,+3
  [97,103],
  [195,205],
  [297,303], ...
\}
\end{DoxyCode}
 \hypertarget{stats-reader}{}\section{LB Restart Reader}\label{stats-reader}
Follow input LB distribution

The LB stats restart reader component {\ttfamily \hyperlink{structvt_1_1vrt_1_1collection_1_1balance_1_1_stats_restart_reader}{vt\+::vrt\+::collection\+::balance\+::\+Stats\+Restart\+Reader}}, accessed via {\ttfamily \hyperlink{namespacevt_ad73860100c7d2ca1d833eab74942ee73}{vt\+::the\+Stats\+Reader()}} reads in an input object distribution for a given program and follows the distribution as specified in the file.

A common flow is the following\+:
\begin{DoxyItemize}
\item Run the program to output stats files (with the flag {\ttfamily -\/-\/vt\+\_\+lb\+\_\+stats})
\item Input those files to the L\+B\+AF (Load Balancing Analysis Framework) to generate a new load distribution offline (e.\+g., to test a new LB strategy).
\begin{DoxyItemize}
\item Tell L\+B\+AF to generate a new set of stats files that contains a new mapping of object to processor
\end{DoxyItemize}
\item Run the program with the {\ttfamily Stats\+Restart\+Reader} to test this new mapping on the actual application
\begin{DoxyItemize}
\item Using the options {\ttfamily -\/-\/vt\+\_\+lb\+\_\+stats\+\_\+dir\+\_\+in=inputdir -\/-\/vt\+\_\+lb\+\_\+stats\+\_\+file\+\_\+in=filename} 
\end{DoxyItemize}
\end{DoxyItemize}