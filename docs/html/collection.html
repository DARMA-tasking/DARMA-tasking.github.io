<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DARMA &raquo; Introduction &raquo; Virtual Context Collection | vt (Virtual Transport)</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon-dark.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">vt <span class="m-thin">(Virtual Transport)</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li>
              <a href="introduction.html">Introduction</a>
              <ol>
                <li><a href="context.html">Context</a></li>
                <li><a href="active-messenger.html">Active Messenger</a></li>
                <li><a href="collection.html" id="m-navbar-current">Virtual Context Collection</a></li>
                <li><a href="collective.html">Collectives</a></li>
                <li><a href="group.html">Group Manager</a></li>
                <li><a href="location.html">Location Manager</a></li>
                <li><a href="objgroup.html">Object Group Manager</a></li>
                <li><a href="pipe.html">Pipe Manager</a></li>
                <li><a href="pool.html">Memory Pool</a></li>
                <li><a href="rdmahandle.html">RDMA Handle Manager</a></li>
                <li><a href="registry.html">Registry</a></li>
                <li><a href="scheduler.html">Scheduler</a></li>
                <li><a href="term.html">Termination Detector</a></li>
                <li><a href="trace.html">Tracing</a></li>
                <li><a href="trace-only.html">Trace-only</a></li>
              </ol>
            </li>
            <li>
              <a href="learn.html">Learn</a>
              <ol>
                <li><a href="vt-build.html">How to Build</a></li>
                <li><a href="tutorial.html">Tutorial</a></li>
                <li><a href="examples.html">Examples</a></li>
                <li><a href="ckpt_learn_serialize.html">How to Serialize Data</a></li>
              </ol>
            </li>
            <li><a href="pages.html">Pages</a></li>
            <li>
              <a href="namespaces.html">Namespaces</a>
              <ol>
                <li><a href="namespacevt.html">vt</a></li>
                <li><a href="namespacevt_1_1collective.html">vt::collective</a></li>
                <li><a href="namespacevt_1_1debug.html">vt::debug</a></li>
                <li><a href="namespacevt_1_1group.html">vt::group</a></li>
                <li><a href="namespacevt_1_1location.html">vt::location</a></li>
                <li><a href="namespacevt_1_1messaging.html">vt::messaging</a></li>
                <li><a href="namespacevt_1_1objgroup.html">vt::objgroup</a></li>
                <li><a href="namespacevt_1_1pipe.html">vt::pipe</a></li>
                <li><a href="namespacevt_1_1rdma.html">vt::rdma</a></li>
                <li><a href="namespacevt_1_1runtime.html">vt::runtime</a></li>
                <li><a href="namespacevt_1_1term.html">vt::term</a></li>
                <li><a href="namespacevt_1_1vrt.html">vt::vrt</a></li>
              </ol>
            </li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="5">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li>
              <a href="https://github.com/DARMA-tasking/vt">GitHub</a>
              <ol>
                <li><a href="https://github.com/DARMA-tasking/checkpoint">Checkpoint</a></li>
                <li><a href="https://github.com/DARMA-tasking/detector">Detector</a></li>
                <li><a href="https://github.com/DARMA-tasking/LB-analysis-framework">LBAF</a></li>
                <li><a href="https://github.com/DARMA-tasking/checkpoint-member-analyzer">Checkpoint Analyzer</a></li>
                <li><a href="https://github.com/DARMA-tasking/DARMA-tasking.github.io">Documentation</a></li>
              </ol>
            </li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="index.html">DARMA</a> &raquo;</span>
          <span class="m-breadcrumb"><a href="introduction.html">Introduction</a> &raquo;</span>
          Virtual Context Collection
        </h1>
<p>Collection of tasks</p><p>The virtual context collection component <code><a href="structvt_1_1vrt_1_1collection_1_1_collection_manager.html" class="m-doc">vt::<wbr />vrt::<wbr />collection::<wbr />CollectionManager</a></code>, accessed via <code><a href="namespacevt.html#a1c45ce63bfd2c327ff7d76a319a371d8" class="m-doc">vt::<wbr />theCollection()</a></code> is a core VT component that manages multi-dimensional collections of <em>virtual context</em> (or a migratable C++ object registered with <strong><em>vt</em></strong>) elements. It manages the creation, deletion, and messaging across elements at runtime supporting dense, sparse, on-demand, and staged insert modes. It utilizes the <a href="location.html" class="m-doc">Location Manager</a> to manage the location of these elements to efficiently deliver messages. It also utilizes the <a href="group.html" class="m-doc">Group Manager</a> to build a spanning tree across the nodes that the collection is currently mapped to. This group makes broadcasts efficient and allows reductions to make progress without waiting for nodes that do not have collection elements.</p><p>The <a href="node-lb-data.html" class="m-doc">Node LB Data</a> component stores the LB data for live collections that then passes the instrumented data to the <a href="lb-manager.html" class="m-doc">LB Manager</a> component to apply load balancing strategies. You can use <code>--vt_lb_keep_last_elm</code> flag to prohibit load balancer from migrating last element in collection.</p><p>The preferred interface for constructing a new collection is <code><a href="namespacevt.html#a95c0d739e465e5324c2383f43ab2a145" class="m-doc">vt::<wbr />makeCollection</a>&lt;T&gt;()</code>. Using a fluent-style interface, <code>makeCollection</code> returns a configuration object to set properties of the collection before actually constructing the collection. Once it is configured, the <code>.wait()</code> or <code>.deferWithEpoch(callback)</code> methods allows one to either block until the collection is created or wait on the returned epoch until construction finishes (respectively). The <code>wait()</code> variant returns the proxy for use immediately (after blocking), whereas <code>deferWithEpoch(callback)</code> supplies the proxy when the epoch terminates by triggering the callback passed to it.</p><p>The function <code><a href="namespacevt.html#a95c0d739e465e5324c2383f43ab2a145" class="m-doc">vt::<wbr />makeCollection</a>&lt;T&gt;()</code> will create a collection in a collective fashion, meaning it must be called in tandem on all nodes. Alternatively, one may call <code><a href="namespacevt.html#a37806a29a810adceb5792f7cfd4de106" class="m-doc">vt::<wbr />makeCollectionRooted</a>&lt;T&gt;()</code> to construct a rooted collection, which is invoked only on a single rank. (and the proxy is returned to a single rank). After waiting for construction, elements will have been constructed on their appropriate ranks, and the provided collection proxy will be usable on any rank it&#x27;s sent to.</p><p>For collections without dynamic membership at runtime, one must call <code>.bounds(my_range)</code> to specify the bounds in each dimension for the collection or specify exactly one bulk insertion range (<code>.bulkInsert(my_range_1)</code>), where <code>my_range_1</code> will be the assumed bounds for the collection. Bulk insertion is one such way to specify how insertions should happen during construction. The <code>.bulkInsert()</code> method (with no parameter) tells the runtime to insert all collection elements within the bounds using the mapping function to determine placement. The user can also specify specific ranges to bulk insert using <code>.bulkInsert(my_range_1)</code> with a parameter (this can be called multiple times).</p><p>For collective collection constructions, one may also use list insertion (<code>.listInsert(my_index_list)</code>) to specify non-contiguous lists of indices that the runtime should insert at construction time. Finally, for collective constructions, one may call <code>.listInsertHere(my_index_list)</code> to specifically instruct the runtime to construct a list of collection elements on the particular rank where it is invoked. This overrides the mapping function that the user supplies.</p><p>By default, a mapping function is applied to every collection. If the collection has bounds, the system will choose a default blocked mapping (across all dimensions) for initial placement. For collections without bounds (ones with dynamic membership), the system uses a simple xor hash function to generate a valid initial location for each index deterministically. One may specify a mapping function in two ways: the user can provide a stateless function as a template argument to <code>.mapperFunc&lt;my_map&gt;()</code>, where <code>my_map</code> has the following definition (shown for a 1-dimensional collection):</p><pre class="m-code"><span class="n">vt</span><span class="o">::</span><span class="n">NodeType</span> <span class="n">my_map</span><span class="p">(</span><span class="n">vt</span><span class="o">::</span><span class="n">Index1D</span><span class="o">*</span> <span class="n">idx</span><span class="p">,</span> <span class="n">vt</span><span class="o">::</span><span class="n">Index1D</span><span class="o">*</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">vt</span><span class="o">::</span><span class="n">NodeType</span> <span class="n">num_nodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">idx</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">()</span> <span class="o">%</span> <span class="n">num_nodes</span><span class="p">;</span>
<span class="p">}</span></pre><p>Or, alternatively, one may specify a object group mapper, which contains an instance across all ranks that may communicate to determine placement. The <code>.mapperObjGroup(proxy)</code> method configures the mapping object with an object group instance that already exists by passing the proxy to it. Otherwise, one may just give the type and constructor arguments to create a new instance: <code>.mapperObjGroupConstruct&lt;MyObjectGroup&gt;(args...)</code>. An object group mapper must inherit from <code><a href="structvt_1_1mapping_1_1_base_mapper.html" class="m-doc">vt::<wbr />mapping::<wbr />BaseMapper</a></code> and implement the pure virtual method <code>NodeType map(IdxT* idx, int ndim, NodeType num_nodes)</code> to define the mapping for the runtime. As an example, the object group mapper used by default for unbounded collections is implemented as follows:</p><pre class="m-code"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IdxT</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">UnboundedDefaultMap</span> <span class="p">:</span> <span class="n">vt</span><span class="o">::</span><span class="n">mapping</span><span class="o">::</span><span class="n">BaseMapper</span><span class="o">&lt;</span><span class="n">IdxT</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="n">ObjGroupProxyType</span> <span class="n">construct</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">theObjGroup</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">makeCollective</span><span class="o">&lt;</span><span class="n">UnboundedDefaultMap</span><span class="o">&lt;</span><span class="n">IdxT</span><span class="o">&gt;&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">proxy</span><span class="p">.</span><span class="n">getProxy</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">NodeType</span> <span class="n">map</span><span class="p">(</span><span class="n">IdxT</span><span class="o">*</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">NodeType</span> <span class="n">num_nodes</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">typename</span> <span class="n">IdxT</span><span class="o">::</span><span class="n">DenseIndexType</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndim</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">val</span> <span class="o">^=</span> <span class="n">idx</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">val</span> <span class="o">%</span> <span class="n">num_nodes</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span></pre><p>Note that all collection mapping functions or object groups must be deterministic across all nodes for the same inputs.</p><p>By default, the collection type <code>T</code> (that inherits from the runtime base type <code><a href="namespacevt.html#ac72e048964e4bb536faaa8bc90f58db7" class="m-doc">vt::<wbr />Collection</a>&lt;T, IndexType&gt;</code>) must have a default constructor. However, this can be avoided by configuring the collection with a specialized element constructor using <code>.elementConstructor(x)</code>, where <code>x</code>&#x27;s type is <code>std::function&lt;std::unique_ptr&lt;ColT&gt;(IndexT idx)&gt;</code> and <code>ColT</code> is the collection type and <code>IndexT</code> is the index type for the collection. This configuration is only valid for collective constructions because the element constructor function can not be safely sent over the network. If this is provided, the collection manager will not try to default construct the collection elements, instead calling the user-provided constructor passed to this function.</p><p>By default, all collection elements are migratable and can be moved by the load balancer when it is invoked by the user. However, one may inform VT that collection is entirely non-migratable by setting the parameter <code>.migratable(false)</code> during construction. By doing this, work executed by its elements will be recorded as background load on the initially mapped rank and excluded from the load balancer migration decisions.</p><p>By default, collections do not have dynamic membership: they might be dense or sparse within the specified bounds, but the set of collection elements that are created at construction time persists (and never grows or shrinks) until the collection is completely destroyed. Dynamic membership allows the user to specify insertions and deletions as the program executes in a safe and orderly manner. To enable this, one must call <code>.dynamicMembership(true)</code>. Note that the previous requirement of specifying collection bounds becomes optional with dynamic membership.</p><p>Once a collection is constructed with dynamic membership, one must start a collective modification epoch to make changes to the collection&#x27;s membership. This is performed in the following way (note that this is a collective interface):</p><pre class="m-code"><span class="k">auto</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">makeCollection</span><span class="o">&lt;</span><span class="n">MyCollection</span><span class="o">&gt;</span><span class="p">()</span>
  <span class="p">.</span><span class="n">dynamicMembership</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
  <span class="p">.</span><span class="n">collective</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
  <span class="p">.</span><span class="n">wait</span><span class="p">();</span>

<span class="k">auto</span> <span class="n">range</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">Index1D</span><span class="p">(</span><span class="n">num_elms</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">token</span> <span class="o">=</span> <span class="n">proxy</span><span class="p">.</span><span class="n">beginModification</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">range</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">num_nodes</span> <span class="o">==</span> <span class="n">this_node</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">proxy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">insertAt</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">proxy</span><span class="p">.</span><span class="n">finishModification</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">token</span><span class="p">));</span></pre><p>The calls to <code>proxy.beginModification()</code> start the insertion/deletion epoch by returning a token that must be passed to the actual modification calls. To insert a new collection element, the interface provides several methods on the indexed proxy: <code>insert</code>, <code>insertAt</code>, <code>insertMsg</code> or <code>insertAtMsg</code>. The <code>insert</code> method performs the insertion at the location specified by the mapping function/mapping object group that is provided when the collection is constructed. The <code>insertAt</code> or <code>insertAtMsg</code> allow the user to specify exactly where the new element should reside overriding the default mapping for the element. The <code>insertMsg</code> or <code>insertAtMsg</code> calls allow the user to pass a message to the collection element which invokes a non-default constructor that has the user-specified message as an argument.</p><p>Finally, one may call <code>destroy</code> on the indexed proxy to delete an element. All these modifications take place after <code>finishModification</code> is invoked&mdash;a blocking call that enacts the changes across the system. Once <code>finishModification</code> returns, the runtime guarantees that all changes have taken place across the system and all spanning trees are reconstructed or modified based on the changes made.</p><p>If a reduction is ongoing while insertions or deletions happen, the new elements are still expected to contribute. That is, new collection elements are part of the next sequenced reduction that has not causally terminated across the distributed system. For code readability, we generally recommend that the user wait on termination of any reductions before membership modifications are made.</p><section id="rooted-hello-world-collection"><h2><a href="#rooted-hello-world-collection">Hello World 1D Dense Collection (Rooted)</a></h2><pre class="m-code"><span class="k">struct</span> <span class="nl">Hello</span> <span class="p">:</span> <span class="n">vt</span><span class="o">::</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">Hello</span><span class="p">,</span> <span class="n">vt</span><span class="o">::</span><span class="n">Index1D</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">Hello</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">Hello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vtAssert</span><span class="p">(</span><span class="n">counter_</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Must be equal&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">using</span> <span class="n">TestMsg</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">CollectionMessage</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">doWork</span><span class="p">(</span><span class="n">TestMsg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello from {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">());</span>
    <span class="n">counter_</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">int32_t</span> <span class="n">counter_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vt</span><span class="o">::</span><span class="n">initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

  <span class="n">vt</span><span class="o">::</span><span class="n">NodeType</span> <span class="n">this_node</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">theContext</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getNode</span><span class="p">();</span>

  <span class="kt">int</span> <span class="n">num_elms</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num_elms</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">this_node</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">range</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">Index1D</span><span class="p">(</span><span class="n">num_elms</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">makeCollectionRooted</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">&gt;</span><span class="p">()</span>
      <span class="p">.</span><span class="n">bounds</span><span class="p">(</span><span class="n">range</span><span class="p">)</span>
      <span class="p">.</span><span class="n">bulkInsert</span><span class="p">()</span>
      <span class="p">.</span><span class="n">wait</span><span class="p">();</span>
    <span class="n">proxy</span><span class="p">.</span><span class="n">broadcast</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">::</span><span class="n">TestMsg</span><span class="p">,</span><span class="o">&amp;</span><span class="n">Hello</span><span class="o">::</span><span class="n">doWork</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">vt</span><span class="o">::</span><span class="n">finalize</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></section><section id="collective-hello-world-collection"><h2><a href="#collective-hello-world-collection">Hello World 1D Dense Collection (Collective)</a></h2><pre class="m-code"><span class="k">struct</span> <span class="nl">Hello</span> <span class="p">:</span> <span class="n">vt</span><span class="o">::</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">Hello</span><span class="p">,</span> <span class="n">vt</span><span class="o">::</span><span class="n">Index1D</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">Hello</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">Hello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vt</span><span class="o">::</span><span class="n">NodeType</span> <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">theContext</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getNumNodes</span><span class="p">();</span>
    <span class="n">vtAssert</span><span class="p">(</span><span class="n">counter_</span> <span class="o">==</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="s">&quot;Should receive # nodes broadcasts&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">using</span> <span class="n">TestMsg</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">CollectionMessage</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">doWork</span><span class="p">(</span><span class="n">TestMsg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">counter_</span><span class="o">++</span><span class="p">;</span>
    <span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello from {}, counter_={}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">().</span><span class="n">x</span><span class="p">(),</span> <span class="n">counter_</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">counter_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vt</span><span class="o">::</span><span class="n">initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

  <span class="kt">int32_t</span> <span class="n">num_elms</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num_elms</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">range</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">Index1D</span><span class="p">(</span><span class="n">num_elms</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">makeCollection</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">.</span><span class="n">bounds</span><span class="p">(</span><span class="n">range</span><span class="p">)</span>
    <span class="p">.</span><span class="n">bulkInsert</span><span class="p">()</span>
    <span class="p">.</span><span class="n">wait</span><span class="p">();</span>

  <span class="c1">// All nodes send a broadcast to all elements</span>
  <span class="n">proxy</span><span class="p">.</span><span class="n">broadcast</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">::</span><span class="n">TestMsg</span><span class="p">,</span><span class="o">&amp;</span><span class="n">Hello</span><span class="o">::</span><span class="n">doWork</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">vt</span><span class="o">::</span><span class="n">finalize</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></section><section id="reduce-hello-world-collection"><h2><a href="#reduce-hello-world-collection">Hello World 1D Collection Reduce</a></h2><pre class="m-code"><span class="k">struct</span> <span class="nl">Hello</span> <span class="p">:</span> <span class="n">vt</span><span class="o">::</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">Hello</span><span class="p">,</span> <span class="n">vt</span><span class="o">::</span><span class="n">Index1D</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">ReduceMsg</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">collective</span><span class="o">::</span><span class="n">ReduceTMsg</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">done</span><span class="p">(</span><span class="n">ReduceMsg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Reduce complete at {} value {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(),</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="k">using</span> <span class="n">TestMsg</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">CollectionMessage</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">doWork</span><span class="p">(</span><span class="n">TestMsg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello from {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">());</span>

    <span class="c1">// Get the proxy for the collection</span>
    <span class="k">auto</span> <span class="n">proxy</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getCollectionProxy</span><span class="p">();</span>

    <span class="c1">// Create a callback for when the reduction finishes</span>
    <span class="k">auto</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">theCB</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">makeSend</span><span class="o">&lt;</span><span class="n">Hello</span><span class="p">,</span><span class="n">ReduceMsg</span><span class="p">,</span><span class="o">&amp;</span><span class="n">Hello</span><span class="o">::</span><span class="n">done</span><span class="o">&gt;</span><span class="p">(</span><span class="n">proxy</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

    <span class="c1">// Create and send the reduction message holding an int</span>
    <span class="k">auto</span> <span class="n">red_msg</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">makeMessage</span><span class="o">&lt;</span><span class="n">ReduceMsg</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">().</span><span class="n">x</span><span class="p">());</span>
    <span class="n">proxy</span><span class="p">.</span><span class="n">reduce</span><span class="o">&lt;</span><span class="n">vt</span><span class="o">::</span><span class="n">collective</span><span class="o">::</span><span class="n">PlusOp</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">red_msg</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="n">cb</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vt</span><span class="o">::</span><span class="n">initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

  <span class="n">vt</span><span class="o">::</span><span class="n">NodeType</span> <span class="n">this_node</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">theContext</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getNode</span><span class="p">();</span>

  <span class="kt">int32_t</span> <span class="n">num_elms</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num_elms</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">range</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">Index1D</span><span class="p">(</span><span class="n">num_elms</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">makeCollection</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">.</span><span class="n">bounds</span><span class="p">(</span><span class="n">range</span><span class="p">)</span>
    <span class="p">.</span><span class="n">bulkInsert</span><span class="p">()</span>
    <span class="p">.</span><span class="n">wait</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">this_node</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">proxy</span><span class="p">.</span><span class="n">broadcast</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">::</span><span class="n">TestMsg</span><span class="p">,</span><span class="o">&amp;</span><span class="n">Hello</span><span class="o">::</span><span class="n">doWork</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">vt</span><span class="o">::</span><span class="n">finalize</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></section><section id="staged-insert-hello-world-collection"><h2><a href="#staged-insert-hello-world-collection">Hello World 1D Collection Staged Insert</a></h2><pre class="m-code"><span class="k">struct</span> <span class="nl">Hello</span> <span class="p">:</span> <span class="n">vt</span><span class="o">::</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">Hello</span><span class="p">,</span> <span class="n">vt</span><span class="o">::</span><span class="n">Index1D</span><span class="o">&gt;</span> <span class="p">{</span>

  <span class="c1">// Default constructor for migration</span>
  <span class="n">Hello</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="c1">// Constructor used during insertion</span>
  <span class="k">explicit</span> <span class="nf">Hello</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">input_string</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">in</span><span class="p">(</span><span class="n">input_string</span><span class="p">)</span>
  <span class="p">{</span> <span class="p">}</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">Hello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vtAssert</span><span class="p">(</span><span class="n">counter_</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Must be equal&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">using</span> <span class="n">TestMsg</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">CollectionMessage</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">doWork</span><span class="p">(</span><span class="n">TestMsg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">counter_</span><span class="o">++</span><span class="p">;</span>

    <span class="n">vt</span><span class="o">::</span><span class="n">NodeType</span> <span class="n">this_node</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">theContext</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getNode</span><span class="p">();</span>
    <span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;{}: Hello from {}: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this_node</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(),</span> <span class="n">in</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">counter_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">in</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vt</span><span class="o">::</span><span class="n">initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

  <span class="n">vt</span><span class="o">::</span><span class="n">NodeType</span> <span class="n">this_node</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">theContext</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getNode</span><span class="p">();</span>
  <span class="n">vt</span><span class="o">::</span><span class="n">NodeType</span> <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">theContext</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getNumNodes</span><span class="p">();</span>

  <span class="k">if</span><span class="p">(</span><span class="n">num_nodes</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="n">vt</span><span class="o">::</span><span class="n">finalize</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">num_elms</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num_elms</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">range</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">Index1D</span><span class="p">(</span><span class="n">num_elms</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vt</span><span class="o">::</span><span class="n">Index1D</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">&gt;&gt;&gt;</span> <span class="n">elms</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_elms</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Insert even elements, round-robin the insertions from each node</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_nodes</span> <span class="o">==</span> <span class="n">this_node</span> <span class="n">and</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">str</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;inserted from {}&quot;</span><span class="p">,</span> <span class="n">this_node</span><span class="p">);</span>
      <span class="n">elms</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">vt</span><span class="o">::</span><span class="n">Index1D</span><span class="p">{</span><span class="n">i</span><span class="p">},</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">&gt;</span><span class="p">(</span><span class="n">str</span><span class="p">))</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">vt</span><span class="o">::</span><span class="n">makeCollection</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">.</span><span class="n">bounds</span><span class="p">(</span><span class="n">range</span><span class="p">)</span>
    <span class="p">.</span><span class="n">listInsertHere</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">elms</span><span class="p">))</span>
    <span class="p">.</span><span class="n">wait</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">this_node</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">proxy</span><span class="p">.</span><span class="n">broadcast</span><span class="o">&lt;</span><span class="n">Hello</span><span class="o">::</span><span class="n">TestMsg</span><span class="p">,</span><span class="o">&amp;</span><span class="n">Hello</span><span class="o">::</span><span class="n">doWork</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">vt</span><span class="o">::</span><span class="n">finalize</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim"></span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim"></span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>vt (Virtual Transport). Created with <a href="https://doxygen.org/">Doxygen</a> 1.8.13 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
