<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespacevt_1_1util" kind="namespace" language="C++">
    <compoundname>vt::util</compoundname>
    <innerclass refid="structvt_1_1util_1_1_bool_pack" prot="public">vt::util::BoolPack</innerclass>
    <innerclass refid="structvt_1_1util_1_1cond__" prot="public">vt::util::cond_</innerclass>
    <innerclass refid="structvt_1_1util_1_1cond___3_01false_00_01_t_00_01_f_01_4" prot="public">vt::util::cond_&lt; false, T, F &gt;</innerclass>
    <innerclass refid="structvt_1_1util_1_1_function_wrapper" prot="public">vt::util::FunctionWrapper</innerclass>
    <innerclass refid="structvt_1_1util_1_1_function_wrapper_3_01_return_t_07_5_08_07_args_t_8_8_8_08_4" prot="public">vt::util::FunctionWrapper&lt; ReturnT(*)(ArgsT...)&gt;</innerclass>
    <innerclass refid="structvt_1_1util_1_1_function_wrapper_3_01_return_t_07_functor_t_1_1_5_08_07_args_t_8_8_8_08_4" prot="public">vt::util::FunctionWrapper&lt; ReturnT(FunctorT::*)(ArgsT...)&gt;</innerclass>
    <innerclass refid="structvt_1_1util_1_1_functor_extractor" prot="public">vt::util::FunctorExtractor</innerclass>
    <innerclass refid="structvt_1_1util_1_1_functor_traits" prot="public">vt::util::FunctorTraits</innerclass>
    <innerclass refid="structvt_1_1util_1_1_functor_traits_3_01_return_t_07_functor_t_1_1_5_08_07_msg_t_01_5_08_4" prot="public">vt::util::FunctorTraits&lt; ReturnT(FunctorT::*)(MsgT *)&gt;</innerclass>
    <innerclass refid="structvt_1_1util_1_1meta__and" prot="public">vt::util::meta_and</innerclass>
    <innerclass refid="structvt_1_1util_1_1meta__and_3_01_t_00_01_ts_8_8_8_01_4" prot="public">vt::util::meta_and&lt; T, Ts... &gt;</innerclass>
    <innerclass refid="structvt_1_1util_1_1_msg_ptr_type" prot="public">vt::util::MsgPtrType</innerclass>
    <innerclass refid="structvt_1_1util_1_1_msg_ptr_type_3_01_msg_shared_ptr_3_01_msg_t_01_4_01_4" prot="public">vt::util::MsgPtrType&lt; MsgSharedPtr&lt; MsgT &gt; &gt;</innerclass>
    <innerclass refid="structvt_1_1util_1_1_msg_ptr_type_3_01_msg_t_01_5_01_4" prot="public">vt::util::MsgPtrType&lt; MsgT * &gt;</innerclass>
    <innernamespace refid="namespacevt_1_1util_1_1adt">vt::util::adt</innernamespace>
    <innernamespace refid="namespacevt_1_1util_1_1atomic">vt::util::atomic</innernamespace>
    <innernamespace refid="namespacevt_1_1util_1_1container">vt::util::container</innernamespace>
    <innernamespace refid="namespacevt_1_1util_1_1demangle">vt::util::demangle</innernamespace>
    <innernamespace refid="namespacevt_1_1util_1_1error">vt::util::error</innernamespace>
    <innernamespace refid="namespacevt_1_1util_1_1memory">vt::util::memory</innernamespace>
    <innernamespace refid="namespacevt_1_1util_1_1mpi__limits">vt::util::mpi_limits</innernamespace>
    <innernamespace refid="namespacevt_1_1util_1_1mutex">vt::util::mutex</innernamespace>
    <innernamespace refid="namespacevt_1_1util_1_1ptr">vt::util::ptr</innernamespace>
    <innernamespace refid="namespacevt_1_1util_1_1stats">vt::util::stats</innernamespace>
    <innernamespace refid="namespacevt_1_1util_1_1tls">vt::util::tls</innernamespace>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacevt_1_1util_1acdef825f3bbbffb020925d3ba6151df9" prot="public" static="no">
        <type><ref refid="structvt_1_1util_1_1mpi__limits_1_1_m_p_i___attr" kindref="compound">mpi_limits::MPI_Attr</ref></type>
        <definition>using vt::util::MPI_Attr = typedef mpi_limits::MPI_Attr</definition>
        <argsstring></argsstring>
        <name>MPI_Attr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/utils/mpi_limits/mpi_max_tag.h" line="88" column="1" bodyfile="src/vt/utils/mpi_limits/mpi_max_tag.h" bodystart="88" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacevt_1_1util_1a7d480434049896696b9a50c38a766202" prot="public" static="no">
        <type><ref refid="structvt_1_1util_1_1ptr_1_1_observer_ptr" kindref="compound">ptr::ObserverPtr</ref>&lt; T &gt;</type>
        <definition>using vt::util::ObserverPtr = typedef ptr::ObserverPtr&lt;T&gt;</definition>
        <argsstring></argsstring>
        <name>ObserverPtr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/utils/ptr/observer.h" line="108" column="1" bodyfile="src/vt/utils/ptr/observer.h" bodystart="108" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacevt_1_1util_1a3169b1fa334a1e8fa2326b8db648e446" prot="public" static="no">
        <type>std::is_same&lt; <ref refid="structvt_1_1util_1_1_bool_pack" kindref="compound">BoolPack</ref>&lt; bs..., true &gt;, <ref refid="structvt_1_1util_1_1_bool_pack" kindref="compound">BoolPack</ref>&lt; true, bs... &gt; &gt;</type>
        <definition>using vt::util::all_true = typedef std::is_same&lt;BoolPack&lt;bs..., true&gt;, BoolPack&lt;true, bs...&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>all_true</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/utils/static_checks/all_true.h" line="54" column="1" bodyfile="src/vt/utils/static_checks/all_true.h" bodystart="54" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacevt_1_1util_1a97df3e28837417537b3bc035c74f064d" prot="public" static="no">
        <type>std::enable_if_t&lt; std::is_same&lt; typename <ref refid="structvt_1_1util_1_1_function_wrapper" kindref="compound">FunctionWrapper</ref>&lt; FunctionType &gt;::ReturnType, void &gt;::value, void &gt;</type>
        <definition>using vt::util::IsVoidReturn = typedef std::enable_if_t&lt; std::is_same&lt; typename FunctionWrapper&lt;FunctionType&gt;::ReturnType, void&gt;::value, void &gt;</definition>
        <argsstring></argsstring>
        <name>IsVoidReturn</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/utils/static_checks/function_ret_check.h" line="71" column="1" bodyfile="src/vt/utils/static_checks/function_ret_check.h" bodystart="75" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacevt_1_1util_1ae9a553985cdc8e9bd4e55f55161f2929" prot="public" static="no">
        <type>std::enable_if_t&lt; !std::is_same&lt; Ret, void &gt;::value &amp;&amp;std::is_copy_constructible&lt; Ret &gt;::value, Ret &gt;</type>
        <definition>using vt::util::Copyable = typedef std::enable_if_t&lt; !std::is_same&lt;Ret, void&gt;::value &amp;&amp; std::is_copy_constructible&lt;Ret&gt;::value, Ret &gt;</definition>
        <argsstring></argsstring>
        <name>Copyable</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/utils/static_checks/function_ret_check.h" line="81" column="1" bodyfile="src/vt/utils/static_checks/function_ret_check.h" bodystart="84" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacevt_1_1util_1a0760a3963341a602dfe2dfc42d78c867" prot="public" static="no">
        <type>std::enable_if_t&lt; !std::is_same&lt; Ret, void &gt;::value &amp;&amp;!std::is_copy_constructible&lt; Ret &gt;::value, Ret &gt;</type>
        <definition>using vt::util::NotCopyable = typedef std::enable_if_t&lt; !std::is_same&lt;Ret, void&gt;::value &amp;&amp; !std::is_copy_constructible&lt;Ret&gt;::value, Ret &gt;</definition>
        <argsstring></argsstring>
        <name>NotCopyable</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/utils/static_checks/function_ret_check.h" line="90" column="1" bodyfile="src/vt/utils/static_checks/function_ret_check.h" bodystart="93" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacevt_1_1util_1aaa76da2983f12be56a31a96c017e8dd1" prot="public" static="no">
        <type><ref refid="structvt_1_1util_1_1meta__and" kindref="compound">meta_and</ref>&lt; std::is_same&lt; Ts, T &gt;... &gt;</type>
        <definition>using vt::util::meta_type_eq = typedef meta_and&lt;std::is_same&lt;Ts, T&gt;...&gt;</definition>
        <argsstring></argsstring>
        <name>meta_type_eq</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/utils/static_checks/meta_type_eq_.h" line="64" column="1" bodyfile="src/vt/utils/static_checks/meta_type_eq_.h" bodystart="64" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="src/vt/configs/error/keyval_printer.h" line="57" column="1"/>
  </compounddef>
</doxygen>
