<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456" kind="struct" language="C++" prot="public">
    <compoundname>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</compoundname>
    <basecompoundref refid="structvt_1_1rdma_1_1_base_typed_handle" prot="public" virt="non-virtual">vt::rdma::BaseTypedHandle&lt; T, E, vt::NodeType &gt;</basecompoundref>
    <includes refid="handle_8node_8h" local="no">handle.node.h</includes>
    <innerclass refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_bffc9b31b7d701a9d14f97993404e892" prot="public">vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;::NodeTagType</innerclass>
    <templateparamlist>
      <param>
        <type>typename T</type>
      </param>
      <param>
        <type><ref refid="namespacevt_1_1rdma_1a0234ff19cfb3c04718cfdfd36b2d6d88" kindref="member">HandleEnum</ref></type>
        <declname>E</declname>
        <defname>E</defname>
      </param>
      <param>
        <type>typename IndexT</type>
      </param>
    </templateparamlist>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a94cb0db8d9b038fb504cb01b1d1d37a9" prot="public" static="no">
        <type>typename <ref refid="structvt_1_1rdma_1_1_base_typed_handle" kindref="compound">BaseTypedHandle</ref>&lt; T, E, <ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref> &gt;::<ref refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a94cb0db8d9b038fb504cb01b1d1d37a9" kindref="member">RequestType</ref></type>
        <definition>using vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::RequestType =  typename BaseTypedHandle&lt;T, E, vt::NodeType&gt;::RequestType</definition>
        <argsstring></argsstring>
        <name>RequestType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="77" column="1" bodyfile="src/vt/rdmahandle/handle.node.h" bodystart="77" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a1fd6b9bc3f72bb2b64e602de3982929d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend struct</type>
        <definition>friend struct Manager</definition>
        <argsstring></argsstring>
        <name>Manager</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="79" column="1" bodyfile="src/vt/rdmahandle/handle.node.h" bodystart="79" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1aa597d7381f8793417b0656cbaf1625f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend struct</type>
        <definition>friend struct SubHandle&lt; T, E, IndexT &gt;</definition>
        <argsstring></argsstring>
        <name>SubHandle&lt; T, E, IndexT &gt;</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="79" column="1" bodyfile="src/vt/rdmahandle/handle.node.h" bodystart="80" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a1219d32435dff7029290180c23004b93" prot="protected" static="no" mutable="no">
        <type><ref refid="structvt_1_1rdma_1_1_handle_key" kindref="compound">HandleKey</ref></type>
        <definition>HandleKey vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::key_</definition>
        <argsstring></argsstring>
        <name>key_</name>
        <initializer>= {}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The key for identifying the handle </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="408" column="1" bodyfile="src/vt/rdmahandle/handle.node.h" bodystart="408" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1abdfe9dcf8a155c7e2bd91dabf6472702" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::Handle</definition>
        <argsstring>()=default</argsstring>
        <name>Handle</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="82" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a9362a80316cbbc4527bc1b93f24a5a0b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::Handle</definition>
        <argsstring>(Handle const &amp;)=default</argsstring>
        <name>Handle</name>
        <param>
          <type><ref refid="structvt_1_1rdma_1_1_handle" kindref="compound">Handle</ref> const &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="83" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a730e0d6dab39e85472500ad7e04add58" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::Handle</definition>
        <argsstring>(Handle &amp;&amp;)=default</argsstring>
        <name>Handle</name>
        <param>
          <type><ref refid="structvt_1_1rdma_1_1_handle" kindref="compound">Handle</ref> &amp;&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="84" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a9ebc139217531d3fe1d6d1cc1b824daf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structvt_1_1rdma_1_1_handle" kindref="compound">Handle</ref> &amp;</type>
        <definition>Handle&amp; vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::operator=</definition>
        <argsstring>(Handle const &amp;)=default</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="structvt_1_1rdma_1_1_handle" kindref="compound">Handle</ref> const &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="85" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a29355ec3a0a21b03da7b2b2098b5ad88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structvt_1_1rdma_1_1_handle" kindref="compound">Handle</ref> &amp;</type>
        <definition>Handle&amp; vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::operator=</definition>
        <argsstring>(Handle &amp;&amp;)=default</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="structvt_1_1rdma_1_1_handle" kindref="compound">Handle</ref> &amp;&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="86" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a8757ffe8f60317fccb422db99ee048e5" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::isInit</definition>
        <argsstring>() const</argsstring>
        <name>isInit</name>
        <briefdescription>
<para>Check if the handle is initialized. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>whether the handle is initialized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="118" column="1" bodyfile="src/vt/rdmahandle/handle.node.h" bodystart="118" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a7b01122fa292c1a2202c42a877ea207b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
        <definition>vt::NodeType vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::getNode</definition>
        <argsstring>() const</argsstring>
        <name>getNode</name>
        <briefdescription>
<para>Get the node this handle lives on. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>the node </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="125" column="1" bodyfile="src/vt/rdmahandle/handle.node.h" bodystart="125" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a860f35e2562f8ab0e5606281315d2e17" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::ready</definition>
        <argsstring>() const</argsstring>
        <name>ready</name>
        <briefdescription>
<para>Check if the handle is ready to be used; implies that all MPI windows are constructed across the machine. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>whether its ready </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="133" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1adc7b1058678ece326e044eac9d4c83cf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::readExclusive</definition>
        <argsstring>(std::function&lt; void(T const *, std::size_t count)&gt; fn)</argsstring>
        <name>readExclusive</name>
        <param>
          <type>std::function&lt; void(T const *, std::size_t <ref refid="structvt_1_1rdma_1_1_base_typed_handle_1a1e7937b5cf4b641a783c37675ae2cc35" kindref="member">count</ref>)&gt;</type>
          <declname>fn</declname>
        </param>
        <briefdescription>
<para>Read the local data for the handle with an exclusive lock. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fn</parametername>
</parameternamelist>
<parameterdescription>
<para>lambda to read the data </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="140" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a20ad220782a771d3b4b1a63b963f7adf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::readShared</definition>
        <argsstring>(std::function&lt; void(T const *, std::size_t count)&gt; fn)</argsstring>
        <name>readShared</name>
        <param>
          <type>std::function&lt; void(T const *, std::size_t <ref refid="structvt_1_1rdma_1_1_base_typed_handle_1a1e7937b5cf4b641a783c37675ae2cc35" kindref="member">count</ref>)&gt;</type>
          <declname>fn</declname>
        </param>
        <briefdescription>
<para>Read the local data for the handle with an shared lock. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fn</parametername>
</parameternamelist>
<parameterdescription>
<para>lambda to read the data </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="147" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a193a769321ba99cb7c999118d195d158" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::modifyExclusive</definition>
        <argsstring>(std::function&lt; void(T *, std::size_t count)&gt; fn)</argsstring>
        <name>modifyExclusive</name>
        <param>
          <type>std::function&lt; void(T *, std::size_t <ref refid="structvt_1_1rdma_1_1_base_typed_handle_1a1e7937b5cf4b641a783c37675ae2cc35" kindref="member">count</ref>)&gt;</type>
          <declname>fn</declname>
        </param>
        <briefdescription>
<para>Modify the local data for the handle with an exclusive lock. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fn</parametername>
</parameternamelist>
<parameterdescription>
<para>lambda to modify the data </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="154" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a1e54b62400f4e12e2e7e4862851352c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::modifyShared</definition>
        <argsstring>(std::function&lt; void(T *, std::size_t count)&gt; fn)</argsstring>
        <name>modifyShared</name>
        <param>
          <type>std::function&lt; void(T *, std::size_t <ref refid="structvt_1_1rdma_1_1_base_typed_handle_1a1e7937b5cf4b641a783c37675ae2cc35" kindref="member">count</ref>)&gt;</type>
          <declname>fn</declname>
        </param>
        <briefdescription>
<para>Modify the local data for the handle with an shared lock. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fn</parametername>
</parameternamelist>
<parameterdescription>
<para>lambda to modify the data </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="161" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1ac55effdd67bf32d8b645004e30ffa095" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::access</definition>
        <argsstring>(Lock l, std::function&lt; void(T *, std::size_t count)&gt; fn, std::size_t size)</argsstring>
        <name>access</name>
        <param>
          <type><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70" kindref="member">Lock</ref></type>
          <declname>l</declname>
        </param>
        <param>
          <type>std::function&lt; void(T *, std::size_t <ref refid="structvt_1_1rdma_1_1_base_typed_handle_1a1e7937b5cf4b641a783c37675ae2cc35" kindref="member">count</ref>)&gt;</type>
          <declname>fn</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>General access function for reading/modifying local data. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">l</parametername>
</parameternamelist>
<parameterdescription>
<para>lock to apply </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fn</parametername>
</parameternamelist>
<parameterdescription>
<para>lambda to access data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to read </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="170" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a0f1c345ac84d28f8c19f0d02a428c6a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::lock</definition>
        <argsstring>(Lock l, vt::NodeType node)</argsstring>
        <name>lock</name>
        <param>
          <type><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70" kindref="member">Lock</ref></type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
          <declname>node</declname>
        </param>
        <briefdescription>
<para>Lock the handle to apply multiple operations. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">l</parametername>
</parameternamelist>
<parameterdescription>
<para>lock to apply </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">node</parametername>
</parameternamelist>
<parameterdescription>
<para>which node to lock </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="180" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1aeb8b31602a46bc22042360280ef88b01" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::unlock</definition>
        <argsstring>()</argsstring>
        <name>unlock</name>
        <briefdescription>
<para>Unlock the handle. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="185" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a2b0167a409d6fb571fb87eab5ee07f1e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::fence</definition>
        <argsstring>(int assert=0)</argsstring>
        <name>fence</name>
        <param>
          <type>int</type>
          <declname>assert</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Perform fence synchronization on the underlying data window. </para>        </briefdescription>
        <detaileddescription>
<para>Applies an <computeroutput>MPI_Win_fence</computeroutput> to the underlying data window. One may specify the strength of the fence as the <computeroutput>assert</computeroutput> argument</para><para><computeroutput>MPI_MODE_NOSTORE</computeroutput> <mdash/> the local window was not updated by local stores (or local get or receive calls) since last synchronization.</para><para><computeroutput>MPI_MODE_NOPUT</computeroutput> <mdash/> the local window will not be updated by put or accumulate calls after the fence call, until the ensuing (fence) synchronization.</para><para><computeroutput>MPI_MODE_NOPRECEDE</computeroutput> <mdash/> the fence does not complete any sequence of locally issued RMA calls. If this assertion is given by any process in the window group, then it must be given by all processes in the group.</para><para><computeroutput>MPI_MODE_NOSUCCEED</computeroutput> <mdash/> the fence does not start any sequence of locally issued RMA calls. If the assertion is given by any process in the window group, then it must be given by all processes in the group.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">assert</parametername>
</parameternamelist>
<parameterdescription>
<para>program assertion (may be used for optimization) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="210" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1aee57964ac3427b7f8a2014ab2256efb1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::sync</definition>
        <argsstring>()</argsstring>
        <name>sync</name>
        <briefdescription>
<para>Perform a window sync on the data window <computeroutput>MPI_Win_sync</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="215" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a14d0274de1ef9b44f57e34caa57161f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::flush</definition>
        <argsstring>(vt::NodeType node)</argsstring>
        <name>flush</name>
        <param>
          <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
          <declname>node</declname>
        </param>
        <briefdescription>
<para>Perform a window flush on the data window <computeroutput>MPI_Win_flush</computeroutput> for a certain node. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="221" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a4e007e895ee92570468dddc3db749abb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::flushLocal</definition>
        <argsstring>(vt::NodeType node)</argsstring>
        <name>flushLocal</name>
        <param>
          <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
          <declname>node</declname>
        </param>
        <briefdescription>
<para>Perform a local window flush on the data window <computeroutput>MPI_Win_flush_local</computeroutput> for a certain node. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="227" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a93c57cb5e94d8421447898c079f21d77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::flushAll</definition>
        <argsstring>()</argsstring>
        <name>flushAll</name>
        <briefdescription>
<para>Perform a window flush on the data window <computeroutput>MPI_Win_flush_all</computeroutput> for all nodes. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="233" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a48a2d3e6af45dd8cad201db0eec2d7c2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::get</definition>
        <argsstring>(vt::NodeType node, std::size_t len, int offset, Lock l=Lock::None)</argsstring>
        <name>get</name>
        <param>
          <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
          <declname>node</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>offset</declname>
        </param>
        <param>
          <type><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70" kindref="member">Lock</ref></type>
          <declname>l</declname>
          <defval><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70a6adf97f83acf6453d4a6a4b1070f3754" kindref="member">Lock::None</ref></defval>
        </param>
        <briefdescription>
<para>Get data from the underlying MPI window on a remote process, calls down to <computeroutput>MPI_Get</computeroutput> or <computeroutput>MPI_Rget</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>This variant of <computeroutput>get</computeroutput> fetches into the buffer that is associated with the the handle. See <computeroutput>setBuffer</computeroutput> and <computeroutput>getBuffer</computeroutput> </para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">node</parametername>
</parameternamelist>
<parameterdescription>
<para>the process/node to target </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">len</parametername>
</parameternamelist>
<parameterdescription>
<para>the length to get </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">offset</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">l</parametername>
</parameternamelist>
<parameterdescription>
<para>the lock to apply for the get </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="248" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a0f8e9a21c754f0006c910a9d6325880f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::get</definition>
        <argsstring>(vt::NodeType node, T *ptr, std::size_t len, int offset, Lock l=Lock::None)</argsstring>
        <name>get</name>
        <param>
          <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
          <declname>node</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>offset</declname>
        </param>
        <param>
          <type><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70" kindref="member">Lock</ref></type>
          <declname>l</declname>
          <defval><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70a6adf97f83acf6453d4a6a4b1070f3754" kindref="member">Lock::None</ref></defval>
        </param>
        <briefdescription>
<para>Get data from the underlying MPI window on a remote process, calls down to <computeroutput>MPI_Get</computeroutput> or <computeroutput>MPI_Rget</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">node</parametername>
</parameternamelist>
<parameterdescription>
<para>the process/node to target </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>the pointer to write the fetched bytes to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">len</parametername>
</parameternamelist>
<parameterdescription>
<para>the length to get </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">offset</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">l</parametername>
</parameternamelist>
<parameterdescription>
<para>the lock to apply for the get </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="262" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a320194a1c7de498bcb788854eb5617b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::put</definition>
        <argsstring>(vt::NodeType node, T *ptr, std::size_t len, int offset, Lock l=Lock::None)</argsstring>
        <name>put</name>
        <param>
          <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
          <declname>node</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>offset</declname>
        </param>
        <param>
          <type><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70" kindref="member">Lock</ref></type>
          <declname>l</declname>
          <defval><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70a6adf97f83acf6453d4a6a4b1070f3754" kindref="member">Lock::None</ref></defval>
        </param>
        <briefdescription>
<para>Put data using the underlying MPI window on a remote process, calls down to <computeroutput>MPI_Put</computeroutput> or <computeroutput>MPI_Rput</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">node</parametername>
</parameternamelist>
<parameterdescription>
<para>the process/node to target </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>the pointer of data to put </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">len</parametername>
</parameternamelist>
<parameterdescription>
<para>the length to put </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">offset</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">l</parametername>
</parameternamelist>
<parameterdescription>
<para>the lock to apply for the put </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="276" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a7438912de64870912ba09f292d0b3679" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::accum</definition>
        <argsstring>(vt::NodeType node, T *ptr, std::size_t len, int offset, MPI_Op op, Lock l=Lock::None)</argsstring>
        <name>accum</name>
        <param>
          <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
          <declname>node</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>MPI_Op</type>
          <declname>op</declname>
        </param>
        <param>
          <type><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70" kindref="member">Lock</ref></type>
          <declname>l</declname>
          <defval><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70a6adf97f83acf6453d4a6a4b1070f3754" kindref="member">Lock::None</ref></defval>
        </param>
        <briefdescription>
<para>Accumulate data using the underlying MPI window on a remote process, calls down to <computeroutput>MPI_Accumulate</computeroutput> or <computeroutput>MPI_Raccumulate</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">node</parametername>
</parameternamelist>
<parameterdescription>
<para>the process/node to target </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>the pointer of data to accumulate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">len</parametername>
</parameternamelist>
<parameterdescription>
<para>the length to accumulate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">offset</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">op</parametername>
</parameternamelist>
<parameterdescription>
<para>the operation <computeroutput>MPI_Op</computeroutput> to apply for accumulate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">l</parametername>
</parameternamelist>
<parameterdescription>
<para>the lock to apply for the accumulate </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="291" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a9a598e2a98ac337bf922150ad104118d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a94cb0db8d9b038fb504cb01b1d1d37a9" kindref="member">RequestType</ref></type>
        <definition>RequestType vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::rget</definition>
        <argsstring>(vt::NodeType no, std::size_t len, int offset, Lock l=Lock::None)</argsstring>
        <name>rget</name>
        <param>
          <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
          <declname>no</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>offset</declname>
        </param>
        <param>
          <type><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70" kindref="member">Lock</ref></type>
          <declname>l</declname>
          <defval><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70a6adf97f83acf6453d4a6a4b1070f3754" kindref="member">Lock::None</ref></defval>
        </param>
        <briefdescription>
<para>Get data asynchronously from the underlying MPI window on a remote process, calls down to <computeroutput>MPI_Rget</computeroutput> when MPI 3 is enabled. </para>        </briefdescription>
        <detaileddescription>
<para>If MPI 3 is not enabled, it attaches a regular <computeroutput>MPI_Get</computeroutput> to the <computeroutput><ref refid="structvt_1_1rdma_1_1_request_holder" kindref="compound">RequestHolder</ref></computeroutput> that is dispatched when waited on. This variant of <computeroutput>get</computeroutput> fetches into the buffer that is associated with the the handle. See <computeroutput>setBuffer</computeroutput> and <computeroutput>getBuffer</computeroutput> </para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">node</parametername>
</parameternamelist>
<parameterdescription>
<para>the process/node to target </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">len</parametername>
</parameternamelist>
<parameterdescription>
<para>the length to get </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">offset</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">l</parametername>
</parameternamelist>
<parameterdescription>
<para>the lock to apply for the get</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the request holder to wait on </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="311" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1ae2b236e88c67028e6c8803d7b8f1cc5e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a94cb0db8d9b038fb504cb01b1d1d37a9" kindref="member">RequestType</ref></type>
        <definition>RequestType vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::rget</definition>
        <argsstring>(vt::NodeType node, T *ptr, std::size_t len, int offset, Lock l=Lock::None)</argsstring>
        <name>rget</name>
        <param>
          <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
          <declname>node</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>offset</declname>
        </param>
        <param>
          <type><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70" kindref="member">Lock</ref></type>
          <declname>l</declname>
          <defval><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70a6adf97f83acf6453d4a6a4b1070f3754" kindref="member">Lock::None</ref></defval>
        </param>
        <briefdescription>
<para>Get data asynchronously from the underlying MPI window on a remote process, calls down to <computeroutput>MPI_Rget</computeroutput> when MPI 3 is enabled. </para>        </briefdescription>
        <detaileddescription>
<para>If MPI 3 is not enabled, it attaches a regular <computeroutput>MPI_Get</computeroutput> to the <computeroutput><ref refid="structvt_1_1rdma_1_1_request_holder" kindref="compound">RequestHolder</ref></computeroutput> that is dispatched when waited on.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">node</parametername>
</parameternamelist>
<parameterdescription>
<para>the process/node to target </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>the pointer to write the fetched bytes to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">len</parametername>
</parameternamelist>
<parameterdescription>
<para>the length to get </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">offset</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">l</parametername>
</parameternamelist>
<parameterdescription>
<para>the lock to apply for the get</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the request holder to wait on </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="330" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a6c670a0bff69076a1d437e55c4514bda" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a94cb0db8d9b038fb504cb01b1d1d37a9" kindref="member">RequestType</ref></type>
        <definition>RequestType vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::rput</definition>
        <argsstring>(vt::NodeType node, T *ptr, std::size_t len, int offset, Lock l=Lock::None)</argsstring>
        <name>rput</name>
        <param>
          <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
          <declname>node</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>offset</declname>
        </param>
        <param>
          <type><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70" kindref="member">Lock</ref></type>
          <declname>l</declname>
          <defval><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70a6adf97f83acf6453d4a6a4b1070f3754" kindref="member">Lock::None</ref></defval>
        </param>
        <briefdescription>
<para>Put data asynchronously from the underlying MPI window on a remote process, calls down to <computeroutput>MPI_Rput</computeroutput> when MPI 3 is enabled. </para>        </briefdescription>
        <detaileddescription>
<para>If MPI 3 is not enabled, it attaches a regular <computeroutput>MPI_Put</computeroutput> to the <computeroutput><ref refid="structvt_1_1rdma_1_1_request_holder" kindref="compound">RequestHolder</ref></computeroutput> that is dispatched when waited on.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">node</parametername>
</parameternamelist>
<parameterdescription>
<para>the process/node to target </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>the pointer of data to put </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">len</parametername>
</parameternamelist>
<parameterdescription>
<para>the length to put </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">offset</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">l</parametername>
</parameternamelist>
<parameterdescription>
<para>the lock to apply for the put </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="347" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a17bded689684649b563f6379aeaf8b82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a94cb0db8d9b038fb504cb01b1d1d37a9" kindref="member">RequestType</ref></type>
        <definition>RequestType vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::raccum</definition>
        <argsstring>(vt::NodeType node, T *ptr, std::size_t len, int offset, MPI_Op op, Lock l=Lock::None)</argsstring>
        <name>raccum</name>
        <param>
          <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
          <declname>node</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>MPI_Op</type>
          <declname>op</declname>
        </param>
        <param>
          <type><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70" kindref="member">Lock</ref></type>
          <declname>l</declname>
          <defval><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70a6adf97f83acf6453d4a6a4b1070f3754" kindref="member">Lock::None</ref></defval>
        </param>
        <briefdescription>
<para>Accumulate data asynchronously using the underlying MPI window on a remote process, calls down to <computeroutput>MPI_Raccumulate</computeroutput> when MPI 3 is enabled. </para>        </briefdescription>
        <detaileddescription>
<para>If MPI 3 is not enabled, it attaches a regular <computeroutput>MPI_Accumulate</computeroutput> to the <computeroutput><ref refid="structvt_1_1rdma_1_1_request_holder" kindref="compound">RequestHolder</ref></computeroutput> that is dispatched when waited on.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">node</parametername>
</parameternamelist>
<parameterdescription>
<para>the process/node to target </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>the pointer of data to accumulate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">len</parametername>
</parameternamelist>
<parameterdescription>
<para>the length to accumulate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">offset</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">op</parametername>
</parameternamelist>
<parameterdescription>
<para>the operation <computeroutput>MPI_Op</computeroutput> to apply for accumulate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">l</parametername>
</parameternamelist>
<parameterdescription>
<para>the lock to apply for the accumulate </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="365" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1ad5a344cce3e66668c659bb69ee74c5e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>T</type>
        <definition>T vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::fetchOp</definition>
        <argsstring>(vt::NodeType node, T val, int offset, MPI_Op op, Lock l=Lock::None)</argsstring>
        <name>fetchOp</name>
        <param>
          <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
          <declname>node</declname>
        </param>
        <param>
          <type>T</type>
          <declname>val</declname>
        </param>
        <param>
          <type>int</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>MPI_Op</type>
          <declname>op</declname>
        </param>
        <param>
          <type><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70" kindref="member">Lock</ref></type>
          <declname>l</declname>
          <defval><ref refid="namespacevt_1_1rdma_1ac5c20b41a653e520b6305d4d454ecb70a6adf97f83acf6453d4a6a4b1070f3754" kindref="member">Lock::None</ref></defval>
        </param>
        <briefdescription>
<para>Perform one-sided read-modify-write using the underlying MPI window on a remote process, calls down to <computeroutput>MPI_Fetch_and_op</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">node</parametername>
</parameternamelist>
<parameterdescription>
<para>the process/node to target </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">val</parametername>
</parameternamelist>
<parameterdescription>
<para>the value to fetch-op </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">offset</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">op</parametername>
</parameternamelist>
<parameterdescription>
<para>the operation <computeroutput>MPI_Op</computeroutput> to apply for fetch-op </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">l</parametername>
</parameternamelist>
<parameterdescription>
<para>the lock to apply for the fetch-op</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the value fetched </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="382" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1af7ca568082262385b17598ae988d5c12" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::size_t</type>
        <definition>std::size_t vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::getCount</definition>
        <argsstring>(vt::NodeType node)</argsstring>
        <name>getCount</name>
        <param>
          <type><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref></type>
          <declname>node</declname>
        </param>
        <briefdescription>
<para>Get the count of the data window on a certain node. If the count is non-uniform, it will remotely fetch the count from that node. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">node</parametername>
</parameternamelist>
<parameterdescription>
<para>the node to request the count</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the length of the handle&apos;s data </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="394" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a861a97549fb4aaa9880401dbdf2e0a23" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename SerializerT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::serialize</definition>
        <argsstring>(SerializerT &amp;s)</argsstring>
        <name>serialize</name>
        <param>
          <type>SerializerT &amp;</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>Serializer for the handle. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">s</parametername>
</parameternamelist>
<parameterdescription>
<para>the serializer </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="402" column="1" bodyfile="src/vt/rdmahandle/handle.node.h" bodystart="402" bodyend="405"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a3d322fbc0fd7b9c8283b6fc5fed21a5d" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;::Handle</definition>
        <argsstring>(NodeTagType, HandleKey in_key, std::size_t in_count, std::size_t in_hoff=0, std::shared_ptr&lt; LockMPI &gt; in_lock=nullptr)</argsstring>
        <name>Handle</name>
        <param>
          <type>NodeTagType</type>
        </param>
        <param>
          <type><ref refid="structvt_1_1rdma_1_1_handle_key" kindref="compound">HandleKey</ref></type>
          <declname>in_key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>in_count</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>in_hoff</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="structvt_1_1rdma_1_1_lock_m_p_i" kindref="compound">LockMPI</ref> &gt;</type>
          <declname>in_lock</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
<para>Private constructor used the system factory method to construct a new node-level handle. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">in_key</parametername>
</parameternamelist>
<parameterdescription>
<para>the key for identifying the handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">in_count</parametername>
</parameternamelist>
<parameterdescription>
<para>count of local handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">in_hoff</parametername>
</parameternamelist>
<parameterdescription>
<para>local offset for handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">in_lock</parametername>
</parameternamelist>
<parameterdescription>
<para>handle lock </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/vt/rdmahandle/handle.node.h" line="100" column="1" bodyfile="src/vt/rdmahandle/handle.node.h" bodystart="100" bodyend="110"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="3088">
        <label>vt::rdma::BaseTypedHandle&lt; T, E, vt::NodeType &gt;</label>
        <link refid="structvt_1_1rdma_1_1_base_typed_handle"/>
        <childnode refid="3089" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3087">
        <label>vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;</label>
        <link refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456"/>
        <childnode refid="3088" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3089">
        <label>vt::rdma::BaseHandle</label>
        <link refid="structvt_1_1rdma_1_1_base_handle"/>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="3093">
        <label>T</label>
      </node>
      <node id="3094">
        <label>vt::rdma::HandleKey</label>
        <link refid="structvt_1_1rdma_1_1_handle_key"/>
      </node>
      <node id="3091">
        <label>vt::rdma::BaseTypedHandle&lt; T, E, vt::NodeType &gt;</label>
        <link refid="structvt_1_1rdma_1_1_base_typed_handle"/>
        <childnode refid="3092" relation="public-inheritance">
        </childnode>
        <childnode refid="3093" relation="usage">
          <edgelabel>user_buffer_</edgelabel>
        </childnode>
      </node>
      <node id="3090">
        <label>vt::rdma::value &gt;&gt;&lt; T, E, IndexT &gt;</label>
        <link refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456"/>
        <childnode refid="3091" relation="public-inheritance">
        </childnode>
        <childnode refid="3094" relation="usage">
          <edgelabel>key_</edgelabel>
        </childnode>
      </node>
      <node id="3092">
        <label>vt::rdma::BaseHandle</label>
        <link refid="structvt_1_1rdma_1_1_base_handle"/>
      </node>
    </collaborationgraph>
    <location file="src/vt/rdmahandle/handle.node.h" line="76" column="1" bodyfile="src/vt/rdmahandle/handle.node.h" bodystart="70" bodyend="409"/>
    <listofallmembers>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1ac55effdd67bf32d8b645004e30ffa095" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>access</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a7438912de64870912ba09f292d0b3679" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>accum</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a20c231fb671a38c3bb761d613dd42b3c" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>ActionDataType</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a448710fab012c50cd4eb02b955d2a240" prot="protected" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>actions_</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a7898a65aac6b27f5265ca3d0c2fa187a" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>addAction</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a268fefeb75b88a7642ac14d06b5da963" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>BaseTypedHandle</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1adfa889759392da4cdcea27e79e81a12f" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>BaseTypedHandle</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a89f1a34092464da223bc474deca0692e" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>BaseTypedHandle</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a95ecf3e18a04206024380385af06c007" prot="protected" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>BaseTypedHandle</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a48b8d5baf7532ee63c078d55ee90d6fe" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>clearActions</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a1e7937b5cf4b641a783c37675ae2cc35" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>count</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1ac474123342ec5f8f82d2346b09331fc4" prot="protected" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>count_</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a442fed4e2898c2fc2b7e8686283efdde" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>DataT</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a2b0167a409d6fb571fb87eab5ee07f1e" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>fence</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1ad5a344cce3e66668c659bb69ee74c5e3" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>fetchOp</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a14d0274de1ef9b44f57e34caa57161f7" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>flush</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a93c57cb5e94d8421447898c079f21d77" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>flushAll</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a4e007e895ee92570468dddc3db749abb" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>flushLocal</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a48a2d3e6af45dd8cad201db0eec2d7c2" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>get</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a0f8e9a21c754f0006c910a9d6325880f" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>get</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a6774922e581a9b8c19eccf749077f577" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>getBuffer</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1af7ca568082262385b17598ae988d5c12" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>getCount</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a7b01122fa292c1a2202c42a877ea207b" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>getNode</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1abdfe9dcf8a155c7e2bd91dabf6472702" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>Handle</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a9362a80316cbbc4527bc1b93f24a5a0b" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>Handle</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a730e0d6dab39e85472500ad7e04add58" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>Handle</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a3d322fbc0fd7b9c8283b6fc5fed21a5d" prot="private" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>Handle</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1afdff2a8569424f4b9be14ac0f2daf5ca" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>handle_type</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a465a9836d31034a5f96b5826ae3ba064" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>hasAction</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a98bab5e776934a84c4415952823f58e0" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>hoff</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a009a2f6951b5a3284f1f19bb9b56e4e2" prot="protected" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>hoff_</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1aca839871dda1f44f8e59a451174b9a2a" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>IndexType</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a8757ffe8f60317fccb422db99ee048e5" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>isInit</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a1219d32435dff7029290180c23004b93" prot="protected" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>key_</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a0f1c345ac84d28f8c19f0d02a428c6a1" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>lock</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1accff417789be0a3556fdc4695aba5a85" prot="protected" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>lock_</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a1fd6b9bc3f72bb2b64e602de3982929d" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>Manager</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a193a769321ba99cb7c999118d195d158" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>modifyExclusive</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a1e54b62400f4e12e2e7e4862851352c9" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>modifyShared</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a9ebc139217531d3fe1d6d1cc1b824daf" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>operator=</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a29355ec3a0a21b03da7b2b2098b5ad88" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>operator=</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1af7897dce38a16c31e3431cf65dec2792" prot="public" virt="non-virtual" ambiguityscope="BaseTypedHandle&lt; T, E, vt::NodeType &gt;::"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>operator=</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1a4f4dd9c546b56d3fc570500a79b048d8" prot="public" virt="non-virtual" ambiguityscope="BaseTypedHandle&lt; T, E, vt::NodeType &gt;::"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>operator=</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a320194a1c7de498bcb788854eb5617b5" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>put</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a17bded689684649b563f6379aeaf8b82" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>raccum</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1adc7b1058678ece326e044eac9d4c83cf" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>readExclusive</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a20ad220782a771d3b4b1a63b963f7adf" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>readShared</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a860f35e2562f8ab0e5606281315d2e17" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>ready</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a94cb0db8d9b038fb504cb01b1d1d37a9" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>RequestType</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a9a598e2a98ac337bf922150ad104118d" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>rget</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1ae2b236e88c67028e6c8803d7b8f1cc5e" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>rget</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a6c670a0bff69076a1d437e55c4514bda" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>rput</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1a861a97549fb4aaa9880401dbdf2e0a23" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>serialize</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1acd1c1ff4fa00ba44ff7d7d6d92e82e5b" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>setBuffer</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1aa597d7381f8793417b0656cbaf1625f0" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>SubHandle&lt; T, E, IndexT &gt;</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1aee57964ac3427b7f8a2014ab2256efb1" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>sync</name></member>
      <member refid="structvt_1_1rdma_1_1_handle_3_01_t_00_01_e_00_01_index_t_00_01typename_01std_1_1enable__if__t_3_d15dac1b5db6e2bc0fb0b8aca42b1456_1aeb8b31602a46bc22042360280ef88b01" prot="public" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>unlock</name></member>
      <member refid="structvt_1_1rdma_1_1_base_typed_handle_1af48b31b6d8f1319ee58c5544ad251bf9" prot="protected" virt="non-virtual"><scope>vt::rdma::Handle&lt; T, E, IndexT, typename std::enable_if_t&lt; std::is_same&lt; IndexT, vt::NodeType &gt;::value &gt;&gt;</scope><name>user_buffer_</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
