<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.16">
  <compounddef id="collection" kind="page">
    <compoundname>collection</compoundname>
    <title>Virtual Context Collection</title>
    <briefdescription>
<para>Collection of tasks. </para>
    </briefdescription>
    <detaileddescription>
<para>Collection of tasks</para>
<para>The virtual context collection component <computeroutput><ref refid="structvt_1_1vrt_1_1collection_1_1_collection_manager" kindref="compound">vt::vrt::collection::CollectionManager</ref></computeroutput>, accessed via <computeroutput><ref refid="namespacevt_1a1c45ce63bfd2c327ff7d76a319a371d8" kindref="member">vt::theCollection()</ref></computeroutput> is a core VT component that manages multi-dimensional collections of <emphasis>virtual context</emphasis> (or a migratable C++ object registered with <bold><emphasis>vt</emphasis></bold>) elements. It manages the creation, deletion, and messaging across elements at runtime supporting dense, sparse, on-demand, and staged insert modes. It utilizes the <ref refid="location" kindref="compound">Location Manager</ref> to manage the location of these elements to efficiently deliver messages. It also utilizes the <ref refid="group" kindref="compound">Group Manager</ref> to build a spanning tree across the nodes that the collection is currently mapped to. This group makes broadcasts efficient and allows reductions to make progress without waiting for nodes that do not have collection elements.</para>
<para>The <ref refid="node-lb-data" kindref="compound">Node LB Data</ref> component stores the LB data for live collections that then passes the instrumented data to the <ref refid="lb-manager" kindref="compound">LB Manager</ref> component to apply load balancing strategies. You can use <computeroutput>--vt_lb_keep_last_elm</computeroutput> flag to prohibit load balancer from migrating last element in collection.</para>
<sect2 id="collection_1collection-configuration">
<title>Configuring Collections</title>
<para>The preferred interface for constructing a new collection is <computeroutput><ref refid="namespacevt_1a19a89f0706559e09bbe84eec1ff9f1e7" kindref="member">vt::makeCollection</ref>&lt;T&gt;()</computeroutput>. Using a fluent-style interface, <computeroutput>makeCollection</computeroutput> returns a configuration object to set properties of the collection before actually constructing the collection. Once it is configured, the <computeroutput>.wait()</computeroutput> or <computeroutput>.deferWithEpoch(callback)</computeroutput> methods allows one to either block until the collection is created or wait on the returned epoch until construction finishes (respectively). The <computeroutput>wait()</computeroutput> variant returns the proxy for use immediately (after blocking), whereas <computeroutput>deferWithEpoch(callback)</computeroutput> supplies the proxy when the epoch terminates by triggering the callback passed to it.</para>
<sect3 id="collection_1collection-collective-vs-rooted">
<title>Collective vs. Rooted</title>
<para>The function <computeroutput><ref refid="namespacevt_1a19a89f0706559e09bbe84eec1ff9f1e7" kindref="member">vt::makeCollection</ref>&lt;T&gt;()</computeroutput> will create a collection in a collective fashion, meaning it must be called in tandem on all nodes. Alternatively, one may call <computeroutput><ref refid="namespacevt_1acbbf58b2c85959c964a7ae8c536fe9bc" kindref="member">vt::makeCollectionRooted</ref>&lt;T&gt;()</computeroutput> to construct a rooted collection, which is invoked only on a single rank. (and the proxy is returned to a single rank). After waiting for construction, elements will have been constructed on their appropriate ranks, and the provided collection proxy will be usable on any rank it&apos;s sent to.</para>
</sect3>
<sect3 id="collection_1collection-bounds-insertion">
<title>Bounds and Insertion</title>
<para>For collections without dynamic membership at runtime, one must call <computeroutput>.bounds(my_range)</computeroutput> to specify the bounds in each dimension for the collection or specify exactly one bulk insertion range (<computeroutput>.bulkInsert(my_range_1)</computeroutput>), where <computeroutput>my_range_1</computeroutput> will be the assumed bounds for the collection. Bulk insertion is one such way to specify how insertions should happen during construction. The <computeroutput>.bulkInsert()</computeroutput> method (with no parameter) tells the runtime to insert all collection elements within the bounds using the mapping function to determine placement. The user can also specify specific ranges to bulk insert using <computeroutput>.bulkInsert(my_range_1)</computeroutput> with a parameter (this can be called multiple times).</para>
<para>For collective collection constructions, one may also use list insertion (<computeroutput>.listInsert(my_index_list)</computeroutput>) to specify non-contiguous lists of indices that the runtime should insert at construction time. Finally, for collective constructions, one may call <computeroutput>.listInsertHere(my_index_list)</computeroutput> to specifically instruct the runtime to construct a list of collection elements on the particular rank where it is invoked. This overrides the mapping function that the user supplies.</para>
</sect3>
<sect3 id="collection_1collection-mapping">
<title>Mapping Functions and Object Groups</title>
<para>By default, a mapping function is applied to every collection. If the collection has bounds, the system will choose a default blocked mapping (across all dimensions) for initial placement. For collections without bounds (ones with dynamic membership), the system uses a simple xor hash function to generate a valid initial location for each index deterministically. One may specify a mapping function in two ways: the user can provide a stateless function as a template argument to <computeroutput>.mapperFunc&lt;my_map&gt;()</computeroutput>, where <computeroutput>my_map</computeroutput> has the following definition (shown for a 1-dimensional collection):</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref><sp/>my_map(<ref refid="structvt_1_1index_1_1_dense_index_array" kindref="compound">vt::Index1D</ref>*<sp/>idx,<sp/><ref refid="structvt_1_1index_1_1_dense_index_array" kindref="compound">vt::Index1D</ref>*<sp/>bounds,<sp/><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref><sp/>num_nodes)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>idx-&gt;<ref refid="structvt_1_1index_1_1_dense_index_array_1a0604b24914af854d09d4da97eae4ef74" kindref="member">x</ref>()<sp/>%<sp/>num_nodes;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Or, alternatively, one may specify a object group mapper, which contains an instance across all ranks that may communicate to determine placement. The <computeroutput>.mapperObjGroup(proxy)</computeroutput> method configures the mapping object with an object group instance that already exists by passing the proxy to it. Otherwise, one may just give the type and constructor arguments to create a new instance: <computeroutput>.mapperObjGroupConstruct&lt;MyObjectGroup&gt;(args...)</computeroutput>. An object group mapper must inherit from <computeroutput><ref refid="structvt_1_1mapping_1_1_base_mapper" kindref="compound">vt::mapping::BaseMapper</ref></computeroutput> and implement the pure virtual method <computeroutput>NodeType map(IdxT* idx, int ndim, NodeType num_nodes)</computeroutput> to define the mapping for the runtime. As an example, the object group mapper used by default for unbounded collections is implemented as follows:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>IdxT&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">UnboundedDefaultMap<sp/>:<sp/><ref refid="structvt_1_1mapping_1_1_base_mapper" kindref="compound">vt::mapping::BaseMapper</ref>&lt;IdxT&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="namespacevt_1ad7cae989df485fccca57f0792a880a8e" kindref="member">ObjGroupProxyType</ref><sp/>construct()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>proxy<sp/>=<sp/><ref refid="namespacevt_1a833f0115b692f578167cbd88e30d39c5" kindref="member">theObjGroup</ref>()-&gt;<ref refid="structvt_1_1objgroup_1_1_obj_group_manager_1a50e0d8498d142a05773ed5a046803b2b" kindref="member">makeCollective</ref>&lt;UnboundedDefaultMap&lt;IdxT&gt;&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>proxy.getProxy();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">NodeType</ref><sp/><ref refid="structvt_1_1mapping_1_1_base_mapper_1a940a3ea301c0f60b2b88218afbce5a4f" kindref="member">map</ref>(IdxT*<sp/>idx,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ndim,<sp/><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">NodeType</ref><sp/>num_nodes)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>IdxT::DenseIndexType<sp/>val<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ndim;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>val<sp/>^=<sp/>idx-&gt;get(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>val<sp/>%<sp/>num_nodes;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Note that all collection mapping functions or object groups must be deterministic across all nodes for the same inputs.</para>
</sect3>
<sect3 id="collection_1collection-element-construction">
<title>Element Construction</title>
<para>By default, the collection type <computeroutput>T</computeroutput> (that inherits from the runtime base type <computeroutput><ref refid="namespacevt_1ac72e048964e4bb536faaa8bc90f58db7" kindref="member">vt::Collection</ref>&lt;T, IndexType&gt;</computeroutput>) must have a default constructor. However, this can be avoided by configuring the collection with a specialized element constructor using <computeroutput>.elementConstructor(x)</computeroutput>, where <computeroutput>x</computeroutput>&apos;s type is <computeroutput>std::function&lt;std::unique_ptr&lt;ColT&gt;(IndexT idx)&gt;</computeroutput> and <computeroutput>ColT</computeroutput> is the collection type and <computeroutput>IndexT</computeroutput> is the index type for the collection. This configuration is only valid for collective constructions because the element constructor function can not be safely sent over the network. If this is provided, the collection manager will not try to default construct the collection elements, instead calling the user-provided constructor passed to this function.</para>
</sect3>
<sect3 id="collection_1collection-element-migratability">
<title>Element Migratability</title>
<para>By default, all collection elements are migratable and can be moved by the load balancer when it is invoked by the user. However, one may inform VT that collection is entirely non-migratable by setting the parameter <computeroutput>.migratable(false)</computeroutput> during construction. By doing this, work executed by its elements will be recorded as background load on the initially mapped rank and excluded from the load balancer migration decisions.</para>
</sect3>
<sect3 id="collection_1collection-dynamic-membership">
<title>Dynamic Membership</title>
<para>By default, collections do not have dynamic membership: they might be dense or sparse within the specified bounds, but the set of collection elements that are created at construction time persists (and never grows or shrinks) until the collection is completely destroyed. Dynamic membership allows the user to specify insertions and deletions as the program executes in a safe and orderly manner. To enable this, one must call <computeroutput>.dynamicMembership(true)</computeroutput>. Note that the previous requirement of specifying collection bounds becomes optional with dynamic membership.</para>
<para>Once a collection is constructed with dynamic membership, one must start a collective modification epoch to make changes to the collection&apos;s membership. This is performed in the following way (note that this is a collective interface):</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>proxy<sp/>=<sp/>vt::makeCollection&lt;MyCollection&gt;(</highlight><highlight class="stringliteral">&quot;collection_label&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>.dynamicMembership(</highlight><highlight class="keyword">true</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>.collective(</highlight><highlight class="keyword">true</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>.wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>range<sp/>=<sp/><ref refid="namespacevt_1a5540efc78234273e1796fb003fe4d234" kindref="member">vt::Index1D</ref>(num_elms);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>token<sp/>=<sp/>proxy.beginModification();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>range.x()<sp/>/<sp/>2;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(i<sp/>%<sp/>num_nodes<sp/>==<sp/>this_node)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>proxy[i].insertAt(token,<sp/>i<sp/>%<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">proxy.finishModification(std::move(token));</highlight></codeline>
</programlisting></para>
<para>The calls to <computeroutput>proxy.beginModification()</computeroutput> start the insertion/deletion epoch by returning a token that must be passed to the actual modification calls. To insert a new collection element, the interface provides several methods on the indexed proxy: <computeroutput>insert</computeroutput>, <computeroutput>insertAt</computeroutput>, <computeroutput>insertMsg</computeroutput> or <computeroutput>insertAtMsg</computeroutput>. The <computeroutput>insert</computeroutput> method performs the insertion at the location specified by the mapping function/mapping object group that is provided when the collection is constructed. The <computeroutput>insertAt</computeroutput> or <computeroutput>insertAtMsg</computeroutput> allow the user to specify exactly where the new element should reside overriding the default mapping for the element. The <computeroutput>insertMsg</computeroutput> or <computeroutput>insertAtMsg</computeroutput> calls allow the user to pass a message to the collection element which invokes a non-default constructor that has the user-specified message as an argument.</para>
<para>Finally, one may call <computeroutput>destroy</computeroutput> on the indexed proxy to delete an element. All these modifications take place after <computeroutput>finishModification</computeroutput> is invoked<mdash/>a blocking call that enacts the changes across the system. Once <computeroutput>finishModification</computeroutput> returns, the runtime guarantees that all changes have taken place across the system and all spanning trees are reconstructed or modified based on the changes made.</para>
<para>If a reduction is ongoing while insertions or deletions happen, the new elements are still expected to contribute. That is, new collection elements are part of the next sequenced reduction that has not causally terminated across the distributed system. For code readability, we generally recommend that the user wait on termination of any reductions before membership modifications are made.</para>
</sect3>
</sect2>
<sect1 id="collection_1rooted-hello-world-collection">
<title>Hello World 1D Dense Collection (Rooted)</title>
<para><programlisting filename="examples/hello_world/hello_world_collection.cc"><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Hello<sp/>:<sp/><ref refid="structvt_1_1vrt_1_1collection_1_1_collection" kindref="compound">vt::Collection</ref>&lt;Hello,<sp/>vt::Index1D&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Hello()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~Hello()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="config__assert_8h_1aeddd4990a496e91a0ca5d6c16437359b" kindref="member">vtAssert</ref>(counter_<sp/>==<sp/>1,<sp/></highlight><highlight class="stringliteral">&quot;Must<sp/>be<sp/>equal&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>doWork(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>val)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fmt::print(</highlight><highlight class="stringliteral">&quot;Hello<sp/>from<sp/>{}:<sp/>val={}\n&quot;</highlight><highlight class="normal">,<sp/>this-&gt;<ref refid="structvt_1_1vrt_1_1collection_1_1_indexable_1a28d05f23e7a20e12e94b8235305c1e82" kindref="member">getIndex</ref>(),<sp/>val);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>counter_++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int32_t<sp/>counter_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacevt_1a0b9d4884da642e4231dc1a27d14dff72" kindref="member">vt::initialize</ref>(argc,<sp/>argv);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref><sp/>this_node<sp/>=<sp/><ref refid="namespacevt_1a26551fe0e6e6a1371111df5b12c7e92c" kindref="member">vt::theContext</ref>()-&gt;<ref refid="structvt_1_1ctx_1_1_context_1a0d52c263ce8516546a67443d9a86fa5f" kindref="member">getNode</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_elms<sp/>=<sp/>64;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&gt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>num_elms<sp/>=<sp/>atoi(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(this_node<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>range<sp/>=<sp/><ref refid="namespacevt_1a5540efc78234273e1796fb003fe4d234" kindref="member">vt::Index1D</ref>(num_elms);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>proxy<sp/>=<sp/>vt::makeCollectionRooted&lt;Hello&gt;(</highlight><highlight class="stringliteral">&quot;examples_hello_world_collection&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.bounds(range)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.bulkInsert()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.wait();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>proxy.broadcast&lt;&amp;Hello::doWork&gt;(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacevt_1a540d90dbd6e97b69f1dcbc9ee9314cff" kindref="member">vt::finalize</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
</sect1>
<sect1 id="collection_1collective-hello-world-collection">
<title>Hello World 1D Dense Collection (Collective)</title>
<para><programlisting filename="examples/hello_world/hello_world_collection_collective.cc"><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Hello<sp/>:<sp/><ref refid="structvt_1_1vrt_1_1collection_1_1_collection" kindref="compound">vt::Collection</ref>&lt;Hello,<sp/>vt::Index1D&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Hello()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~Hello()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref><sp/>num_nodes<sp/>=<sp/><ref refid="namespacevt_1a26551fe0e6e6a1371111df5b12c7e92c" kindref="member">vt::theContext</ref>()-&gt;<ref refid="structvt_1_1ctx_1_1_context_1a7f41071aadf6d5fa9e1b6c703c5ff19d" kindref="member">getNumNodes</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="config__assert_8h_1aeddd4990a496e91a0ca5d6c16437359b" kindref="member">vtAssert</ref>(counter_<sp/>==<sp/>num_nodes,<sp/></highlight><highlight class="stringliteral">&quot;Should<sp/>receive<sp/>#<sp/>nodes<sp/>broadcasts&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>doWork(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>val)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>counter_++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fmt::print(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Hello<sp/>from<sp/>{},<sp/>val={},<sp/>counter_={}\n&quot;</highlight><highlight class="normal">,<sp/><ref refid="structvt_1_1vrt_1_1collection_1_1_indexable_1a28d05f23e7a20e12e94b8235305c1e82" kindref="member">getIndex</ref>(),<sp/>val,<sp/>counter_</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>counter_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacevt_1a0b9d4884da642e4231dc1a27d14dff72" kindref="member">vt::initialize</ref>(argc,<sp/>argv);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int32_t<sp/>num_elms<sp/>=<sp/>16;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&gt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>num_elms<sp/>=<sp/>atoi(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>range<sp/>=<sp/><ref refid="namespacevt_1a5540efc78234273e1796fb003fe4d234" kindref="member">vt::Index1D</ref>(num_elms);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>proxy<sp/>=<sp/>vt::makeCollection&lt;Hello&gt;(</highlight><highlight class="stringliteral">&quot;examples_hello_world_collection_collective&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.bounds(range)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.bulkInsert()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>All<sp/>nodes<sp/>send<sp/>a<sp/>broadcast<sp/>to<sp/>all<sp/>elements</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>proxy.broadcast&lt;&amp;Hello::doWork&gt;(29);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacevt_1a540d90dbd6e97b69f1dcbc9ee9314cff" kindref="member">vt::finalize</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
</sect1>
<sect1 id="collection_1reduce-hello-world-collection">
<title>Hello World 1D Collection Reduce</title>
<para><programlisting filename="examples/hello_world/hello_world_collection_reduce.cc"><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Hello<sp/>:<sp/><ref refid="structvt_1_1vrt_1_1collection_1_1_collection" kindref="compound">vt::Collection</ref>&lt;Hello,<sp/>vt::Index1D&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>done(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>val,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>val2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fmt::print(</highlight><highlight class="stringliteral">&quot;Reduce<sp/>complete<sp/>at<sp/>{}<sp/>values<sp/>{}<sp/>{}\n&quot;</highlight><highlight class="normal">,<sp/><ref refid="structvt_1_1vrt_1_1collection_1_1_indexable_1a28d05f23e7a20e12e94b8235305c1e82" kindref="member">getIndex</ref>(),<sp/>val,<sp/>val2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>doWork()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fmt::print(</highlight><highlight class="stringliteral">&quot;Hello<sp/>from<sp/>{}\n&quot;</highlight><highlight class="normal">,<sp/><ref refid="structvt_1_1vrt_1_1collection_1_1_indexable_1a28d05f23e7a20e12e94b8235305c1e82" kindref="member">getIndex</ref>());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>proxy<sp/>for<sp/>the<sp/>collection</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>proxy<sp/>=<sp/><ref refid="structvt_1_1vrt_1_1collection_1_1_collection_base_1ad97d9ab1a28fb535c5d7f82c15e99791" kindref="member">getCollectionProxy</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>val<sp/>=<sp/><ref refid="structvt_1_1vrt_1_1collection_1_1_indexable_1a28d05f23e7a20e12e94b8235305c1e82" kindref="member">getIndex</ref>().x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>val2<sp/>=<sp/>2.4;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>proxy.allreduce&lt;&amp;Hello::done,<sp/><ref refid="structvt_1_1collective_1_1reduce_1_1operators_1_1_plus_op" kindref="compound">vt::collective::PlusOp</ref>&gt;(val,<sp/>val2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacevt_1a0b9d4884da642e4231dc1a27d14dff72" kindref="member">vt::initialize</ref>(argc,<sp/>argv);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref><sp/>this_node<sp/>=<sp/><ref refid="namespacevt_1a26551fe0e6e6a1371111df5b12c7e92c" kindref="member">vt::theContext</ref>()-&gt;<ref refid="structvt_1_1ctx_1_1_context_1a0d52c263ce8516546a67443d9a86fa5f" kindref="member">getNode</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int32_t<sp/>num_elms<sp/>=<sp/>16;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&gt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>num_elms<sp/>=<sp/>atoi(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>range<sp/>=<sp/><ref refid="namespacevt_1a5540efc78234273e1796fb003fe4d234" kindref="member">vt::Index1D</ref>(num_elms);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>proxy<sp/>=<sp/>vt::makeCollection&lt;Hello&gt;(</highlight><highlight class="stringliteral">&quot;hello_world_collection_reduce&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.bounds(range)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.bulkInsert()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(this_node<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>proxy.broadcast&lt;&amp;Hello::doWork&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacevt_1a540d90dbd6e97b69f1dcbc9ee9314cff" kindref="member">vt::finalize</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
</sect1>
<sect1 id="collection_1staged-insert-hello-world-collection">
<title>Hello World 1D Collection Staged Insert</title>
<para><programlisting filename="examples/hello_world/hello_world_collection_staged_insert.cc"><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Hello<sp/>:<sp/><ref refid="structvt_1_1vrt_1_1collection_1_1_collection" kindref="compound">vt::Collection</ref>&lt;Hello,<sp/>vt::Index1D&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Default<sp/>constructor<sp/>for<sp/>migration</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Hello()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Constructor<sp/>used<sp/>during<sp/>insertion</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">explicit</highlight><highlight class="normal"><sp/>Hello(std::string<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>input_string)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>in(input_string)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~Hello()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="config__assert_8h_1aeddd4990a496e91a0ca5d6c16437359b" kindref="member">vtAssert</ref>(counter_<sp/>==<sp/>1,<sp/></highlight><highlight class="stringliteral">&quot;Must<sp/>be<sp/>equal&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>doWork()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>counter_++;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref><sp/>this_node<sp/>=<sp/><ref refid="namespacevt_1a26551fe0e6e6a1371111df5b12c7e92c" kindref="member">vt::theContext</ref>()-&gt;<ref refid="structvt_1_1ctx_1_1_context_1a0d52c263ce8516546a67443d9a86fa5f" kindref="member">getNode</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fmt::print(</highlight><highlight class="stringliteral">&quot;{}:<sp/>Hello<sp/>from<sp/>{}:<sp/>{}\n&quot;</highlight><highlight class="normal">,<sp/>this_node,<sp/>this-&gt;<ref refid="structvt_1_1vrt_1_1collection_1_1_indexable_1a28d05f23e7a20e12e94b8235305c1e82" kindref="member">getIndex</ref>(),<sp/>in);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>counter_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>in;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacevt_1a0b9d4884da642e4231dc1a27d14dff72" kindref="member">vt::initialize</ref>(argc,<sp/>argv);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref><sp/>this_node<sp/>=<sp/><ref refid="namespacevt_1a26551fe0e6e6a1371111df5b12c7e92c" kindref="member">vt::theContext</ref>()-&gt;<ref refid="structvt_1_1ctx_1_1_context_1a0d52c263ce8516546a67443d9a86fa5f" kindref="member">getNode</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacevt_1a866da9d0efc19c0a1ce79e9e492f47e2" kindref="member">vt::NodeType</ref><sp/>num_nodes<sp/>=<sp/><ref refid="namespacevt_1a26551fe0e6e6a1371111df5b12c7e92c" kindref="member">vt::theContext</ref>()-&gt;<ref refid="structvt_1_1ctx_1_1_context_1a7f41071aadf6d5fa9e1b6c703c5ff19d" kindref="member">getNumNodes</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(num_nodes<sp/>&lt;<sp/>2){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespacevt_1a540d90dbd6e97b69f1dcbc9ee9314cff" kindref="member">vt::finalize</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_elms<sp/>=<sp/>32;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(argc<sp/>&gt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>num_elms<sp/>=<sp/>atoi(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>range<sp/>=<sp/><ref refid="namespacevt_1a5540efc78234273e1796fb003fe4d234" kindref="member">vt::Index1D</ref>(num_elms);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;std::tuple&lt;vt::Index1D,<sp/>std::unique_ptr&lt;Hello&gt;&gt;&gt;<sp/>elms;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_elms;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>even<sp/>elements,<sp/>round-robin<sp/>the<sp/>insertions<sp/>from<sp/>each<sp/>node</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((i<sp/>/<sp/>2)<sp/>%<sp/>num_nodes<sp/>==<sp/>this_node<sp/>and<sp/>i<sp/>%<sp/>2<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>str<sp/>=<sp/>fmt::format(</highlight><highlight class="stringliteral">&quot;inserted<sp/>from<sp/>{}&quot;</highlight><highlight class="normal">,<sp/>this_node);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>elms.emplace_back(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::make_tuple(<ref refid="structvt_1_1index_1_1_dense_index_array" kindref="compound">vt::Index1D</ref>{i},<sp/>std::make_unique&lt;Hello&gt;(str))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>proxy<sp/>=<sp/>vt::makeCollection&lt;Hello&gt;(</highlight><highlight class="stringliteral">&quot;examples_hello_world_collection_staged_insert&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.bounds(range)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.listInsertHere(std::move(elms))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>.wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(this_node<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>proxy.broadcast&lt;&amp;Hello::doWork&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacevt_1a540d90dbd6e97b69f1dcbc9ee9314cff" kindref="member">vt::finalize</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
