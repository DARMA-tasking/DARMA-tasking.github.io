\hypertarget{structcheckpoint_1_1dispatch_1_1_standard}{}\doxysection{checkpoint\+::dispatch\+::Standard Struct Reference}
\label{structcheckpoint_1_1dispatch_1_1_standard}\index{checkpoint::dispatch::Standard@{checkpoint::dispatch::Standard}}


\mbox{\hyperlink{structcheckpoint_1_1dispatch_1_1_standard}{Standard}} traversals for sizing, packing and unpacking a class.  




{\ttfamily \#include $<$dispatch.\+h$>$}

\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T , typename SizerT , typename User\+Traits , typename... Args$>$ }\\static Serial\+Size\+Type \mbox{\hyperlink{structcheckpoint_1_1dispatch_1_1_standard_aa54a6b3e40e983f4f04121483203717e}{size}} (T \&target, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Recursively get the number of bytes to serialize {\ttfamily T}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename FootprinterT , typename User\+Traits , typename... Args$>$ }\\static Serial\+Size\+Type \mbox{\hyperlink{structcheckpoint_1_1dispatch_1_1_standard_ab5b0e7e603ef9ec661ac0ef07dc92d7b}{footprint}} (T \&target, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Recursively get the memory footprint of {\ttfamily T}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename PackerT , typename User\+Traits , typename... Args$>$ }\\static PackerT \mbox{\hyperlink{structcheckpoint_1_1dispatch_1_1_standard_a2d00c33c6b401f73c7e7b88b595e0266}{pack}} (T \&target, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Pack {\ttfamily target} that requires {\ttfamily size} number of bytes. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename UnpackerT , typename User\+Traits , typename... Args$>$ }\\static T $\ast$ \mbox{\hyperlink{structcheckpoint_1_1dispatch_1_1_standard_a38c1cc2f2f2168107803828c78d63aef}{unpack}} (T $\ast$mem, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Unpack {\ttfamily T} from packed byte-\/buffer {\ttfamily mem}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static T $\ast$ \mbox{\hyperlink{structcheckpoint_1_1dispatch_1_1_standard_a532b9767431c5a8515205209474aca11}{construct}} (Serial\+Byte\+Type $\ast$mem)
\begin{DoxyCompactList}\small\item\em Construct {\ttfamily T} on allocate memory {\ttfamily mem}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static Serial\+Byte\+Type $\ast$ \mbox{\hyperlink{structcheckpoint_1_1dispatch_1_1_standard_a289fce710a512a3dbbd96076ed8d721e}{allocate}} ()
\begin{DoxyCompactList}\small\item\em Allocate memory for {\ttfamily T}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\mbox{\hyperlink{structcheckpoint_1_1dispatch_1_1_standard}{Standard}} traversals for sizing, packing and unpacking a class. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{structcheckpoint_1_1dispatch_1_1_standard_a289fce710a512a3dbbd96076ed8d721e}\label{structcheckpoint_1_1dispatch_1_1_standard_a289fce710a512a3dbbd96076ed8d721e}} 
\index{checkpoint::dispatch::Standard@{checkpoint::dispatch::Standard}!allocate@{allocate}}
\index{allocate@{allocate}!checkpoint::dispatch::Standard@{checkpoint::dispatch::Standard}}
\doxysubsubsection{\texorpdfstring{allocate()}{allocate()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
Serial\+Byte\+Type $\ast$ checkpoint\+::dispatch\+::\+Standard\+::allocate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Allocate memory for {\ttfamily T}. 

\begin{DoxyReturn}{Returns}
allocated buffer 
\end{DoxyReturn}
\mbox{\Hypertarget{structcheckpoint_1_1dispatch_1_1_standard_a532b9767431c5a8515205209474aca11}\label{structcheckpoint_1_1dispatch_1_1_standard_a532b9767431c5a8515205209474aca11}} 
\index{checkpoint::dispatch::Standard@{checkpoint::dispatch::Standard}!construct@{construct}}
\index{construct@{construct}!checkpoint::dispatch::Standard@{checkpoint::dispatch::Standard}}
\doxysubsubsection{\texorpdfstring{construct()}{construct()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T $\ast$ checkpoint\+::dispatch\+::\+Standard\+::construct (\begin{DoxyParamCaption}\item[{Serial\+Byte\+Type $\ast$}]{mem }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Construct {\ttfamily T} on allocate memory {\ttfamily mem}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mem} & allocated buffer\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
constructed pointer to {\ttfamily T} 
\end{DoxyReturn}
\mbox{\Hypertarget{structcheckpoint_1_1dispatch_1_1_standard_ab5b0e7e603ef9ec661ac0ef07dc92d7b}\label{structcheckpoint_1_1dispatch_1_1_standard_ab5b0e7e603ef9ec661ac0ef07dc92d7b}} 
\index{checkpoint::dispatch::Standard@{checkpoint::dispatch::Standard}!footprint@{footprint}}
\index{footprint@{footprint}!checkpoint::dispatch::Standard@{checkpoint::dispatch::Standard}}
\doxysubsubsection{\texorpdfstring{footprint()}{footprint()}}
{\footnotesize\ttfamily template$<$typename T , typename FootprinterT , typename Traits , typename... Args$>$ \\
Serial\+Size\+Type checkpoint\+::dispatch\+::\+Standard\+::footprint (\begin{DoxyParamCaption}\item[{T \&}]{target,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Recursively get the memory footprint of {\ttfamily T}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em target} & the target to measure \\
\hline
\mbox{\texttt{ in}}  & {\em args} & arguments to the footprinter\textquotesingle{}s constructor\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
memory footprint of {\ttfamily T} 
\end{DoxyReturn}
\mbox{\Hypertarget{structcheckpoint_1_1dispatch_1_1_standard_a2d00c33c6b401f73c7e7b88b595e0266}\label{structcheckpoint_1_1dispatch_1_1_standard_a2d00c33c6b401f73c7e7b88b595e0266}} 
\index{checkpoint::dispatch::Standard@{checkpoint::dispatch::Standard}!pack@{pack}}
\index{pack@{pack}!checkpoint::dispatch::Standard@{checkpoint::dispatch::Standard}}
\doxysubsubsection{\texorpdfstring{pack()}{pack()}}
{\footnotesize\ttfamily template$<$typename T , typename PackerT , typename Traits , typename... Args$>$ \\
PackerT checkpoint\+::dispatch\+::\+Standard\+::pack (\begin{DoxyParamCaption}\item[{T \&}]{target,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Pack {\ttfamily target} that requires {\ttfamily size} number of bytes. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em target} & the target to pack \\
\hline
\mbox{\texttt{ in}}  & {\em args} & arguments to the packer\textquotesingle{}s constructor\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the packer after packing 
\end{DoxyReturn}
\mbox{\Hypertarget{structcheckpoint_1_1dispatch_1_1_standard_aa54a6b3e40e983f4f04121483203717e}\label{structcheckpoint_1_1dispatch_1_1_standard_aa54a6b3e40e983f4f04121483203717e}} 
\index{checkpoint::dispatch::Standard@{checkpoint::dispatch::Standard}!size@{size}}
\index{size@{size}!checkpoint::dispatch::Standard@{checkpoint::dispatch::Standard}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily template$<$typename T , typename SizerT , typename Traits , typename... Args$>$ \\
Serial\+Size\+Type checkpoint\+::dispatch\+::\+Standard\+::size (\begin{DoxyParamCaption}\item[{T \&}]{target,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Recursively get the number of bytes to serialize {\ttfamily T}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em target} & the target to size \\
\hline
\mbox{\texttt{ in}}  & {\em args} & arguments to the sizer\textquotesingle{}s constructor\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes 
\end{DoxyReturn}
\mbox{\Hypertarget{structcheckpoint_1_1dispatch_1_1_standard_a38c1cc2f2f2168107803828c78d63aef}\label{structcheckpoint_1_1dispatch_1_1_standard_a38c1cc2f2f2168107803828c78d63aef}} 
\index{checkpoint::dispatch::Standard@{checkpoint::dispatch::Standard}!unpack@{unpack}}
\index{unpack@{unpack}!checkpoint::dispatch::Standard@{checkpoint::dispatch::Standard}}
\doxysubsubsection{\texorpdfstring{unpack()}{unpack()}}
{\footnotesize\ttfamily template$<$typename T , typename UnpackerT , typename Traits , typename... Args$>$ \\
T $\ast$ checkpoint\+::dispatch\+::\+Standard\+::unpack (\begin{DoxyParamCaption}\item[{T $\ast$}]{mem,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Unpack {\ttfamily T} from packed byte-\/buffer {\ttfamily mem}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mem} & bytes holding a serialized {\ttfamily T} \\
\hline
\mbox{\texttt{ in}}  & {\em constructed} & whether mem is constructed {\ttfamily T} or not \\
\hline
\mbox{\texttt{ in}}  & {\em args} & arguments to the unpacker\textquotesingle{}s constructor\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to an unpacked {\ttfamily T} 
\end{DoxyReturn}


The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/checkpoint/dispatch/dispatch.\+h\item 
src/checkpoint/dispatch/dispatch.\+impl.\+h\end{DoxyCompactItemize}
